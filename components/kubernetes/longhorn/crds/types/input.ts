// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export namespace longhorn {
    export namespace v1beta1 {
        /**
         * BackingImage is where Longhorn stores backing image object.
         */
        export interface BackingImage {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta1">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"BackingImage">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<{[key: string]: any}>;
            status?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * BackingImageDataSource is where Longhorn stores backing image data source object.
         */
        export interface BackingImageDataSource {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta1">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"BackingImageDataSource">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<{[key: string]: any}>;
            status?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * BackingImageManager is where Longhorn stores backing image manager object.
         */
        export interface BackingImageManager {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta1">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"BackingImageManager">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<{[key: string]: any}>;
            status?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Backup is where Longhorn stores backup object.
         */
        export interface Backup {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta1">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"Backup">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<{[key: string]: any}>;
            status?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * BackupTarget is where Longhorn stores backup target object.
         */
        export interface BackupTarget {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta1">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"BackupTarget">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<{[key: string]: any}>;
            status?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * BackupVolume is where Longhorn stores backup volume object.
         */
        export interface BackupVolume {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta1">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"BackupVolume">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<{[key: string]: any}>;
            status?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Engine is where Longhorn stores engine object.
         */
        export interface Engine {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta1">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"Engine">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<{[key: string]: any}>;
            status?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * EngineImage is where Longhorn stores engine image object.
         */
        export interface EngineImage {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta1">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"EngineImage">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<{[key: string]: any}>;
            status?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * InstanceManager is where Longhorn stores instance manager object.
         */
        export interface InstanceManager {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta1">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"InstanceManager">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<{[key: string]: any}>;
            status?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Node is where Longhorn stores Longhorn node object.
         */
        export interface Node {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta1">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"Node">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<{[key: string]: any}>;
            status?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * RecurringJob is where Longhorn stores recurring job object.
         */
        export interface RecurringJob {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta1">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"RecurringJob">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<{[key: string]: any}>;
            status?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Replica is where Longhorn stores replica object.
         */
        export interface Replica {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta1">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"Replica">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<{[key: string]: any}>;
            status?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Setting is where Longhorn stores setting object.
         */
        export interface Setting {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta1">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"Setting">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            value?: pulumi.Input<string>;
        }

        /**
         * ShareManager is where Longhorn stores share manager object.
         */
        export interface ShareManager {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta1">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"ShareManager">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<{[key: string]: any}>;
            status?: pulumi.Input<{[key: string]: any}>;
        }

        /**
         * Volume is where Longhorn stores volume object.
         */
        export interface Volume {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta1">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"Volume">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<{[key: string]: any}>;
            status?: pulumi.Input<{[key: string]: any}>;
        }

    }

    export namespace v1beta2 {
        /**
         * BackingImage is where Longhorn stores backing image object.
         */
        export interface BackingImage {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta2">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"BackingImage">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.longhorn.v1beta2.BackingImageSpec>;
            status?: pulumi.Input<inputs.longhorn.v1beta2.BackingImageStatus>;
        }

        /**
         * BackingImageDataSource is where Longhorn stores backing image data source object.
         */
        export interface BackingImageDataSource {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta2">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"BackingImageDataSource">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.longhorn.v1beta2.BackingImageDataSourceSpec>;
            status?: pulumi.Input<inputs.longhorn.v1beta2.BackingImageDataSourceStatus>;
        }

        /**
         * BackingImageDataSourceSpec defines the desired state of the Longhorn backing image data source
         */
        export interface BackingImageDataSourceSpec {
            checksum?: pulumi.Input<string>;
            diskPath?: pulumi.Input<string>;
            diskUUID?: pulumi.Input<string>;
            fileTransferred?: pulumi.Input<boolean>;
            nodeID?: pulumi.Input<string>;
            parameters?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            sourceType?: pulumi.Input<string>;
            uuid?: pulumi.Input<string>;
        }

        /**
         * BackingImageDataSourceSpec defines the desired state of the Longhorn backing image data source
         */
        export interface BackingImageDataSourceSpecPatch {
            checksum?: pulumi.Input<string>;
            diskPath?: pulumi.Input<string>;
            diskUUID?: pulumi.Input<string>;
            fileTransferred?: pulumi.Input<boolean>;
            nodeID?: pulumi.Input<string>;
            parameters?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            sourceType?: pulumi.Input<string>;
            uuid?: pulumi.Input<string>;
        }

        /**
         * BackingImageDataSourceStatus defines the observed state of the Longhorn backing image data source
         */
        export interface BackingImageDataSourceStatus {
            checksum?: pulumi.Input<string>;
            currentState?: pulumi.Input<string>;
            ip?: pulumi.Input<string>;
            message?: pulumi.Input<string>;
            ownerID?: pulumi.Input<string>;
            progress?: pulumi.Input<number>;
            runningParameters?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            size?: pulumi.Input<number>;
            storageIP?: pulumi.Input<string>;
        }

        /**
         * BackingImageManager is where Longhorn stores backing image manager object.
         */
        export interface BackingImageManager {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta2">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"BackingImageManager">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.longhorn.v1beta2.BackingImageManagerSpec>;
            status?: pulumi.Input<inputs.longhorn.v1beta2.BackingImageManagerStatus>;
        }

        /**
         * BackingImageManagerSpec defines the desired state of the Longhorn backing image manager
         */
        export interface BackingImageManagerSpec {
            backingImages?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            diskPath?: pulumi.Input<string>;
            diskUUID?: pulumi.Input<string>;
            image?: pulumi.Input<string>;
            nodeID?: pulumi.Input<string>;
        }

        /**
         * BackingImageManagerSpec defines the desired state of the Longhorn backing image manager
         */
        export interface BackingImageManagerSpecPatch {
            backingImages?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            diskPath?: pulumi.Input<string>;
            diskUUID?: pulumi.Input<string>;
            image?: pulumi.Input<string>;
            nodeID?: pulumi.Input<string>;
        }

        /**
         * BackingImageManagerStatus defines the observed state of the Longhorn backing image manager
         */
        export interface BackingImageManagerStatus {
            apiMinVersion?: pulumi.Input<number>;
            apiVersion?: pulumi.Input<number>;
            backingImageFileMap?: pulumi.Input<{[key: string]: pulumi.Input<{[key: string]: pulumi.Input<string>}>}>;
            currentState?: pulumi.Input<string>;
            ip?: pulumi.Input<string>;
            ownerID?: pulumi.Input<string>;
            storageIP?: pulumi.Input<string>;
        }

        /**
         * BackingImageSpec defines the desired state of the Longhorn backing image
         */
        export interface BackingImageSpec {
            checksum?: pulumi.Input<string>;
            dataEngine?: pulumi.Input<string>;
            diskFileSpecMap?: pulumi.Input<{[key: string]: pulumi.Input<{[key: string]: pulumi.Input<string>}>}>;
            diskSelector?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Deprecated. We are now using DiskFileSpecMap to assign different spec to the file on different disks.
             */
            disks?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            minNumberOfCopies?: pulumi.Input<number>;
            nodeSelector?: pulumi.Input<pulumi.Input<string>[]>;
            secret?: pulumi.Input<string>;
            secretNamespace?: pulumi.Input<string>;
            sourceParameters?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            sourceType?: pulumi.Input<string>;
        }

        /**
         * BackingImageSpec defines the desired state of the Longhorn backing image
         */
        export interface BackingImageSpecPatch {
            checksum?: pulumi.Input<string>;
            dataEngine?: pulumi.Input<string>;
            diskFileSpecMap?: pulumi.Input<{[key: string]: pulumi.Input<{[key: string]: pulumi.Input<string>}>}>;
            diskSelector?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Deprecated. We are now using DiskFileSpecMap to assign different spec to the file on different disks.
             */
            disks?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            minNumberOfCopies?: pulumi.Input<number>;
            nodeSelector?: pulumi.Input<pulumi.Input<string>[]>;
            secret?: pulumi.Input<string>;
            secretNamespace?: pulumi.Input<string>;
            sourceParameters?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            sourceType?: pulumi.Input<string>;
        }

        /**
         * BackingImageStatus defines the observed state of the Longhorn backing image status
         */
        export interface BackingImageStatus {
            checksum?: pulumi.Input<string>;
            diskFileStatusMap?: pulumi.Input<{[key: string]: pulumi.Input<{[key: string]: pulumi.Input<string>}>}>;
            diskLastRefAtMap?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            ownerID?: pulumi.Input<string>;
            /**
             * Real size of image in bytes, which may be smaller than the size when the file is a sparse file. Will be zero until known (e.g. while a backing image is uploading)
             */
            realSize?: pulumi.Input<number>;
            size?: pulumi.Input<number>;
            uuid?: pulumi.Input<string>;
            v2FirstCopyDisk?: pulumi.Input<string>;
            /**
             * It is pending -> in-progress -> ready/failed
             */
            v2FirstCopyStatus?: pulumi.Input<string>;
            /**
             * Virtual size of image in bytes, which may be larger than physical size. Will be zero until known (e.g. while a backing image is uploading)
             */
            virtualSize?: pulumi.Input<number>;
        }

        /**
         * Backup is where Longhorn stores backup object.
         */
        export interface Backup {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta2">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"Backup">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.longhorn.v1beta2.BackupSpec>;
            status?: pulumi.Input<inputs.longhorn.v1beta2.BackupStatus>;
        }

        /**
         * BackupBackingImage is where Longhorn stores backing image backup object.
         */
        export interface BackupBackingImage {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta2">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"BackupBackingImage">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.longhorn.v1beta2.BackupBackingImageSpec>;
            status?: pulumi.Input<inputs.longhorn.v1beta2.BackupBackingImageStatus>;
        }

        /**
         * BackupBackingImageSpec defines the desired state of the Longhorn backing image backup
         */
        export interface BackupBackingImageSpec {
            /**
             * The backing image name.
             */
            backingImage?: pulumi.Input<string>;
            /**
             * The backup target name.
             */
            backupTargetName?: pulumi.Input<string>;
            /**
             * The labels of backing image backup.
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * The time to request run sync the remote backing image backup.
             */
            syncRequestedAt?: pulumi.Input<string>;
            /**
             * Is this CR created by user through API or UI.
             */
            userCreated?: pulumi.Input<boolean>;
        }

        /**
         * BackupBackingImageSpec defines the desired state of the Longhorn backing image backup
         */
        export interface BackupBackingImageSpecPatch {
            /**
             * The backing image name.
             */
            backingImage?: pulumi.Input<string>;
            /**
             * The backup target name.
             */
            backupTargetName?: pulumi.Input<string>;
            /**
             * The labels of backing image backup.
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * The time to request run sync the remote backing image backup.
             */
            syncRequestedAt?: pulumi.Input<string>;
            /**
             * Is this CR created by user through API or UI.
             */
            userCreated?: pulumi.Input<boolean>;
        }

        /**
         * BackupBackingImageStatus defines the observed state of the Longhorn backing image backup
         */
        export interface BackupBackingImageStatus {
            /**
             * The backing image name.
             */
            backingImage?: pulumi.Input<string>;
            /**
             * The backing image backup upload finished time.
             */
            backupCreatedAt?: pulumi.Input<string>;
            /**
             * The checksum of the backing image.
             */
            checksum?: pulumi.Input<string>;
            /**
             * Compression method
             */
            compressionMethod?: pulumi.Input<string>;
            /**
             * The error message when taking the backing image backup.
             */
            error?: pulumi.Input<string>;
            /**
             * The labels of backing image backup.
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * The last time that the backing image backup was synced with the remote backup target.
             */
            lastSyncedAt?: pulumi.Input<string>;
            /**
             * The address of the backing image manager that runs backing image backup.
             */
            managerAddress?: pulumi.Input<string>;
            /**
             * The error messages when listing or inspecting backing image backup.
             */
            messages?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * The node ID on which the controller is responsible to reconcile this CR.
             */
            ownerID?: pulumi.Input<string>;
            /**
             * The backing image backup progress.
             */
            progress?: pulumi.Input<number>;
            /**
             * Record the secret if this backup backing image is encrypted
             */
            secret?: pulumi.Input<string>;
            /**
             * Record the secret namespace if this backup backing image is encrypted
             */
            secretNamespace?: pulumi.Input<string>;
            /**
             * The backing image size.
             */
            size?: pulumi.Input<number>;
            /**
             * The backing image backup creation state.
             * Can be "", "InProgress", "Completed", "Error", "Unknown".
             */
            state?: pulumi.Input<string>;
            /**
             * The backing image backup URL.
             */
            url?: pulumi.Input<string>;
        }

        /**
         * BackupSpec defines the desired state of the Longhorn backup
         */
        export interface BackupSpec {
            /**
             * The backup mode of this backup.
             * Can be "full" or "incremental"
             */
            backupMode?: pulumi.Input<string>;
            /**
             * The labels of snapshot backup.
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * The snapshot name.
             */
            snapshotName?: pulumi.Input<string>;
            /**
             * The time to request run sync the remote backup.
             */
            syncRequestedAt?: pulumi.Input<string>;
        }

        /**
         * BackupSpec defines the desired state of the Longhorn backup
         */
        export interface BackupSpecPatch {
            /**
             * The backup mode of this backup.
             * Can be "full" or "incremental"
             */
            backupMode?: pulumi.Input<string>;
            /**
             * The labels of snapshot backup.
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * The snapshot name.
             */
            snapshotName?: pulumi.Input<string>;
            /**
             * The time to request run sync the remote backup.
             */
            syncRequestedAt?: pulumi.Input<string>;
        }

        /**
         * BackupStatus defines the observed state of the Longhorn backup
         */
        export interface BackupStatus {
            /**
             * The snapshot backup upload finished time.
             */
            backupCreatedAt?: pulumi.Input<string>;
            /**
             * The backup target name.
             */
            backupTargetName?: pulumi.Input<string>;
            /**
             * Compression method
             */
            compressionMethod?: pulumi.Input<string>;
            /**
             * The error message when taking the snapshot backup.
             */
            error?: pulumi.Input<string>;
            /**
             * The labels of snapshot backup.
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * The last time that the backup was synced with the remote backup target.
             */
            lastSyncedAt?: pulumi.Input<string>;
            /**
             * The error messages when calling longhorn engine on listing or inspecting backups.
             */
            messages?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Size in bytes of newly uploaded data
             */
            newlyUploadDataSize?: pulumi.Input<string>;
            /**
             * The node ID on which the controller is responsible to reconcile this backup CR.
             */
            ownerID?: pulumi.Input<string>;
            /**
             * The snapshot backup progress.
             */
            progress?: pulumi.Input<number>;
            /**
             * Size in bytes of reuploaded data
             */
            reUploadedDataSize?: pulumi.Input<string>;
            /**
             * The address of the replica that runs snapshot backup.
             */
            replicaAddress?: pulumi.Input<string>;
            /**
             * The snapshot size.
             */
            size?: pulumi.Input<string>;
            /**
             * The snapshot creation time.
             */
            snapshotCreatedAt?: pulumi.Input<string>;
            /**
             * The snapshot name.
             */
            snapshotName?: pulumi.Input<string>;
            /**
             * The backup creation state.
             * Can be "", "InProgress", "Completed", "Error", "Unknown".
             */
            state?: pulumi.Input<string>;
            /**
             * The snapshot backup URL.
             */
            url?: pulumi.Input<string>;
            /**
             * The volume's backing image name.
             */
            volumeBackingImageName?: pulumi.Input<string>;
            /**
             * The volume creation time.
             */
            volumeCreated?: pulumi.Input<string>;
            /**
             * The volume name.
             */
            volumeName?: pulumi.Input<string>;
            /**
             * The volume size.
             */
            volumeSize?: pulumi.Input<string>;
        }

        /**
         * BackupTarget is where Longhorn stores backup target object.
         */
        export interface BackupTarget {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta2">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"BackupTarget">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.longhorn.v1beta2.BackupTargetSpec>;
            status?: pulumi.Input<inputs.longhorn.v1beta2.BackupTargetStatus>;
        }

        /**
         * BackupTargetSpec defines the desired state of the Longhorn backup target
         */
        export interface BackupTargetSpec {
            /**
             * The backup target URL.
             */
            backupTargetURL?: pulumi.Input<string>;
            /**
             * The backup target credential secret.
             */
            credentialSecret?: pulumi.Input<string>;
            /**
             * The interval that the cluster needs to run sync with the backup target.
             */
            pollInterval?: pulumi.Input<string>;
            /**
             * The time to request run sync the remote backup target.
             */
            syncRequestedAt?: pulumi.Input<string>;
        }

        /**
         * BackupTargetSpec defines the desired state of the Longhorn backup target
         */
        export interface BackupTargetSpecPatch {
            /**
             * The backup target URL.
             */
            backupTargetURL?: pulumi.Input<string>;
            /**
             * The backup target credential secret.
             */
            credentialSecret?: pulumi.Input<string>;
            /**
             * The interval that the cluster needs to run sync with the backup target.
             */
            pollInterval?: pulumi.Input<string>;
            /**
             * The time to request run sync the remote backup target.
             */
            syncRequestedAt?: pulumi.Input<string>;
        }

        /**
         * BackupTargetStatus defines the observed state of the Longhorn backup target
         */
        export interface BackupTargetStatus {
            /**
             * Available indicates if the remote backup target is available or not.
             */
            available?: pulumi.Input<boolean>;
            /**
             * Records the reason on why the backup target is unavailable.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.longhorn.v1beta2.BackupTargetStatusConditions>[]>;
            /**
             * The last time that the controller synced with the remote backup target.
             */
            lastSyncedAt?: pulumi.Input<string>;
            /**
             * The node ID on which the controller is responsible to reconcile this backup target CR.
             */
            ownerID?: pulumi.Input<string>;
        }

        export interface BackupTargetStatusConditions {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime?: pulumi.Input<string>;
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * Human-readable message indicating details about last transition.
             */
            message?: pulumi.Input<string>;
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason?: pulumi.Input<string>;
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status?: pulumi.Input<string>;
            /**
             * Type is the type of the condition.
             */
            type?: pulumi.Input<string>;
        }

        /**
         * BackupVolume is where Longhorn stores backup volume object.
         */
        export interface BackupVolume {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta2">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"BackupVolume">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.longhorn.v1beta2.BackupVolumeSpec>;
            status?: pulumi.Input<inputs.longhorn.v1beta2.BackupVolumeStatus>;
        }

        /**
         * BackupVolumeSpec defines the desired state of the Longhorn backup volume
         */
        export interface BackupVolumeSpec {
            /**
             * The backup target name that the backup volume was synced.
             */
            backupTargetName?: pulumi.Input<string>;
            /**
             * The time to request run sync the remote backup volume.
             */
            syncRequestedAt?: pulumi.Input<string>;
            /**
             * The volume name that the backup volume was used to backup.
             */
            volumeName?: pulumi.Input<string>;
        }

        /**
         * BackupVolumeSpec defines the desired state of the Longhorn backup volume
         */
        export interface BackupVolumeSpecPatch {
            /**
             * The backup target name that the backup volume was synced.
             */
            backupTargetName?: pulumi.Input<string>;
            /**
             * The time to request run sync the remote backup volume.
             */
            syncRequestedAt?: pulumi.Input<string>;
            /**
             * The volume name that the backup volume was used to backup.
             */
            volumeName?: pulumi.Input<string>;
        }

        /**
         * BackupVolumeStatus defines the observed state of the Longhorn backup volume
         */
        export interface BackupVolumeStatus {
            /**
             * the backing image checksum.
             */
            backingImageChecksum?: pulumi.Input<string>;
            /**
             * The backing image name.
             */
            backingImageName?: pulumi.Input<string>;
            /**
             * The backup volume creation time.
             */
            createdAt?: pulumi.Input<string>;
            /**
             * The backup volume block count.
             */
            dataStored?: pulumi.Input<string>;
            /**
             * The backup volume labels.
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * The latest volume backup time.
             */
            lastBackupAt?: pulumi.Input<string>;
            /**
             * The latest volume backup name.
             */
            lastBackupName?: pulumi.Input<string>;
            /**
             * The backup volume config last modification time.
             */
            lastModificationTime?: pulumi.Input<string>;
            /**
             * The last time that the backup volume was synced into the cluster.
             */
            lastSyncedAt?: pulumi.Input<string>;
            /**
             * The error messages when call longhorn engine on list or inspect backup volumes.
             */
            messages?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * The node ID on which the controller is responsible to reconcile this backup volume CR.
             */
            ownerID?: pulumi.Input<string>;
            /**
             * The backup volume size.
             */
            size?: pulumi.Input<string>;
            /**
             * the storage class name of pv/pvc binding with the volume.
             */
            storageClassName?: pulumi.Input<string>;
        }

        /**
         * Engine is where Longhorn stores engine object.
         */
        export interface Engine {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta2">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"Engine">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.longhorn.v1beta2.EngineSpec>;
            status?: pulumi.Input<inputs.longhorn.v1beta2.EngineStatus>;
        }

        /**
         * EngineImage is where Longhorn stores engine image object.
         */
        export interface EngineImage {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta2">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"EngineImage">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.longhorn.v1beta2.EngineImageSpec>;
            status?: pulumi.Input<inputs.longhorn.v1beta2.EngineImageStatus>;
        }

        /**
         * EngineImageSpec defines the desired state of the Longhorn engine image
         */
        export interface EngineImageSpec {
            image?: pulumi.Input<string>;
        }

        /**
         * EngineImageSpec defines the desired state of the Longhorn engine image
         */
        export interface EngineImageSpecPatch {
            image?: pulumi.Input<string>;
        }

        /**
         * EngineImageStatus defines the observed state of the Longhorn engine image
         */
        export interface EngineImageStatus {
            buildDate?: pulumi.Input<string>;
            cliAPIMinVersion?: pulumi.Input<number>;
            cliAPIVersion?: pulumi.Input<number>;
            conditions?: pulumi.Input<pulumi.Input<inputs.longhorn.v1beta2.EngineImageStatusConditions>[]>;
            controllerAPIMinVersion?: pulumi.Input<number>;
            controllerAPIVersion?: pulumi.Input<number>;
            dataFormatMinVersion?: pulumi.Input<number>;
            dataFormatVersion?: pulumi.Input<number>;
            gitCommit?: pulumi.Input<string>;
            incompatible?: pulumi.Input<boolean>;
            noRefSince?: pulumi.Input<string>;
            nodeDeploymentMap?: pulumi.Input<{[key: string]: pulumi.Input<boolean>}>;
            ownerID?: pulumi.Input<string>;
            refCount?: pulumi.Input<number>;
            state?: pulumi.Input<string>;
            version?: pulumi.Input<string>;
        }

        export interface EngineImageStatusConditions {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime?: pulumi.Input<string>;
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * Human-readable message indicating details about last transition.
             */
            message?: pulumi.Input<string>;
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason?: pulumi.Input<string>;
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status?: pulumi.Input<string>;
            /**
             * Type is the type of the condition.
             */
            type?: pulumi.Input<string>;
        }

        /**
         * EngineSpec defines the desired state of the Longhorn engine
         */
        export interface EngineSpec {
            active?: pulumi.Input<boolean>;
            backupVolume?: pulumi.Input<string>;
            dataEngine?: pulumi.Input<string>;
            desireState?: pulumi.Input<string>;
            disableFrontend?: pulumi.Input<boolean>;
            frontend?: pulumi.Input<string>;
            image?: pulumi.Input<string>;
            logRequested?: pulumi.Input<boolean>;
            nodeID?: pulumi.Input<string>;
            replicaAddressMap?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            requestedBackupRestore?: pulumi.Input<string>;
            requestedDataSource?: pulumi.Input<string>;
            revisionCounterDisabled?: pulumi.Input<boolean>;
            salvageRequested?: pulumi.Input<boolean>;
            snapshotMaxCount?: pulumi.Input<number>;
            snapshotMaxSize?: pulumi.Input<string>;
            unmapMarkSnapChainRemovedEnabled?: pulumi.Input<boolean>;
            upgradedReplicaAddressMap?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            volumeName?: pulumi.Input<string>;
            volumeSize?: pulumi.Input<string>;
        }

        /**
         * EngineSpec defines the desired state of the Longhorn engine
         */
        export interface EngineSpecPatch {
            active?: pulumi.Input<boolean>;
            backupVolume?: pulumi.Input<string>;
            dataEngine?: pulumi.Input<string>;
            desireState?: pulumi.Input<string>;
            disableFrontend?: pulumi.Input<boolean>;
            frontend?: pulumi.Input<string>;
            image?: pulumi.Input<string>;
            logRequested?: pulumi.Input<boolean>;
            nodeID?: pulumi.Input<string>;
            replicaAddressMap?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            requestedBackupRestore?: pulumi.Input<string>;
            requestedDataSource?: pulumi.Input<string>;
            revisionCounterDisabled?: pulumi.Input<boolean>;
            salvageRequested?: pulumi.Input<boolean>;
            snapshotMaxCount?: pulumi.Input<number>;
            snapshotMaxSize?: pulumi.Input<string>;
            unmapMarkSnapChainRemovedEnabled?: pulumi.Input<boolean>;
            upgradedReplicaAddressMap?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            volumeName?: pulumi.Input<string>;
            volumeSize?: pulumi.Input<string>;
        }

        /**
         * EngineStatus defines the observed state of the Longhorn engine
         */
        export interface EngineStatus {
            backupStatus?: pulumi.Input<{[key: string]: pulumi.Input<{[key: string]: pulumi.Input<string>}>}>;
            cloneStatus?: pulumi.Input<{[key: string]: pulumi.Input<{[key: string]: pulumi.Input<string>}>}>;
            conditions?: pulumi.Input<pulumi.Input<inputs.longhorn.v1beta2.EngineStatusConditions>[]>;
            currentImage?: pulumi.Input<string>;
            currentReplicaAddressMap?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            currentSize?: pulumi.Input<string>;
            currentState?: pulumi.Input<string>;
            endpoint?: pulumi.Input<string>;
            instanceManagerName?: pulumi.Input<string>;
            ip?: pulumi.Input<string>;
            isExpanding?: pulumi.Input<boolean>;
            lastExpansionError?: pulumi.Input<string>;
            lastExpansionFailedAt?: pulumi.Input<string>;
            lastRestoredBackup?: pulumi.Input<string>;
            logFetched?: pulumi.Input<boolean>;
            ownerID?: pulumi.Input<string>;
            port?: pulumi.Input<number>;
            purgeStatus?: pulumi.Input<{[key: string]: pulumi.Input<{[key: string]: pulumi.Input<string>}>}>;
            rebuildStatus?: pulumi.Input<{[key: string]: pulumi.Input<{[key: string]: pulumi.Input<string>}>}>;
            replicaModeMap?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * ReplicaTransitionTimeMap records the time a replica in ReplicaModeMap transitions from one mode to another (or
             * from not being in the ReplicaModeMap to being in it). This information is sometimes required by other controllers
             * (e.g. the volume controller uses it to determine the correct value for replica.Spec.lastHealthyAt).
             */
            replicaTransitionTimeMap?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            restoreStatus?: pulumi.Input<{[key: string]: pulumi.Input<{[key: string]: pulumi.Input<string>}>}>;
            salvageExecuted?: pulumi.Input<boolean>;
            snapshotMaxCount?: pulumi.Input<number>;
            snapshotMaxSize?: pulumi.Input<string>;
            snapshots?: pulumi.Input<{[key: string]: pulumi.Input<{[key: string]: pulumi.Input<string>}>}>;
            snapshotsError?: pulumi.Input<string>;
            started?: pulumi.Input<boolean>;
            storageIP?: pulumi.Input<string>;
            ublkID?: pulumi.Input<number>;
            unmapMarkSnapChainRemovedEnabled?: pulumi.Input<boolean>;
            uuid?: pulumi.Input<string>;
        }

        export interface EngineStatusConditions {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime?: pulumi.Input<string>;
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * Human-readable message indicating details about last transition.
             */
            message?: pulumi.Input<string>;
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason?: pulumi.Input<string>;
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status?: pulumi.Input<string>;
            /**
             * Type is the type of the condition.
             */
            type?: pulumi.Input<string>;
        }

        /**
         * InstanceManager is where Longhorn stores instance manager object.
         */
        export interface InstanceManager {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta2">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"InstanceManager">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.longhorn.v1beta2.InstanceManagerSpec>;
            status?: pulumi.Input<inputs.longhorn.v1beta2.InstanceManagerStatus>;
        }

        /**
         * InstanceManagerSpec defines the desired state of the Longhorn instance manager
         */
        export interface InstanceManagerSpec {
            dataEngine?: pulumi.Input<string>;
            dataEngineSpec?: pulumi.Input<inputs.longhorn.v1beta2.InstanceManagerSpecDataEngineSpec>;
            image?: pulumi.Input<string>;
            nodeID?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
        }

        export interface InstanceManagerSpecDataEngineSpec {
            v2?: pulumi.Input<inputs.longhorn.v1beta2.InstanceManagerSpecDataEngineSpecV2>;
        }

        export interface InstanceManagerSpecDataEngineSpecPatch {
            v2?: pulumi.Input<inputs.longhorn.v1beta2.InstanceManagerSpecDataEngineSpecV2Patch>;
        }

        export interface InstanceManagerSpecDataEngineSpecV2 {
            cpuMask?: pulumi.Input<string>;
        }

        export interface InstanceManagerSpecDataEngineSpecV2Patch {
            cpuMask?: pulumi.Input<string>;
        }

        /**
         * InstanceManagerSpec defines the desired state of the Longhorn instance manager
         */
        export interface InstanceManagerSpecPatch {
            dataEngine?: pulumi.Input<string>;
            dataEngineSpec?: pulumi.Input<inputs.longhorn.v1beta2.InstanceManagerSpecDataEngineSpecPatch>;
            image?: pulumi.Input<string>;
            nodeID?: pulumi.Input<string>;
            type?: pulumi.Input<string>;
        }

        /**
         * InstanceManagerStatus defines the observed state of the Longhorn instance manager
         */
        export interface InstanceManagerStatus {
            apiMinVersion?: pulumi.Input<number>;
            apiVersion?: pulumi.Input<number>;
            backingImages?: pulumi.Input<{[key: string]: pulumi.Input<{[key: string]: pulumi.Input<string>}>}>;
            currentState?: pulumi.Input<string>;
            dataEngineStatus?: pulumi.Input<inputs.longhorn.v1beta2.InstanceManagerStatusDataEngineStatus>;
            instanceEngines?: pulumi.Input<{[key: string]: pulumi.Input<{[key: string]: pulumi.Input<string>}>}>;
            instanceReplicas?: pulumi.Input<{[key: string]: pulumi.Input<{[key: string]: pulumi.Input<string>}>}>;
            /**
             * Deprecated: Replaced by InstanceEngines and InstanceReplicas
             */
            instances?: pulumi.Input<{[key: string]: pulumi.Input<{[key: string]: pulumi.Input<string>}>}>;
            ip?: pulumi.Input<string>;
            ownerID?: pulumi.Input<string>;
            proxyApiMinVersion?: pulumi.Input<number>;
            proxyApiVersion?: pulumi.Input<number>;
        }

        export interface InstanceManagerStatusDataEngineStatus {
            v2?: pulumi.Input<inputs.longhorn.v1beta2.InstanceManagerStatusDataEngineStatusV2>;
        }

        export interface InstanceManagerStatusDataEngineStatusV2 {
            cpuMask?: pulumi.Input<string>;
        }

        /**
         * Node is where Longhorn stores Longhorn node object.
         */
        export interface Node {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta2">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"Node">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.longhorn.v1beta2.NodeSpec>;
            status?: pulumi.Input<inputs.longhorn.v1beta2.NodeStatus>;
        }

        /**
         * NodeSpec defines the desired state of the Longhorn node
         */
        export interface NodeSpec {
            allowScheduling?: pulumi.Input<boolean>;
            disks?: pulumi.Input<{[key: string]: pulumi.Input<{[key: string]: pulumi.Input<string>}>}>;
            evictionRequested?: pulumi.Input<boolean>;
            instanceManagerCPURequest?: pulumi.Input<number>;
            name?: pulumi.Input<string>;
            tags?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * NodeSpec defines the desired state of the Longhorn node
         */
        export interface NodeSpecPatch {
            allowScheduling?: pulumi.Input<boolean>;
            disks?: pulumi.Input<{[key: string]: pulumi.Input<{[key: string]: pulumi.Input<string>}>}>;
            evictionRequested?: pulumi.Input<boolean>;
            instanceManagerCPURequest?: pulumi.Input<number>;
            name?: pulumi.Input<string>;
            tags?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * NodeStatus defines the observed state of the Longhorn node
         */
        export interface NodeStatus {
            autoEvicting?: pulumi.Input<boolean>;
            conditions?: pulumi.Input<pulumi.Input<inputs.longhorn.v1beta2.NodeStatusConditions>[]>;
            diskStatus?: pulumi.Input<{[key: string]: pulumi.Input<{[key: string]: pulumi.Input<string>}>}>;
            region?: pulumi.Input<string>;
            snapshotCheckStatus?: pulumi.Input<inputs.longhorn.v1beta2.NodeStatusSnapshotCheckStatus>;
            zone?: pulumi.Input<string>;
        }

        export interface NodeStatusConditions {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime?: pulumi.Input<string>;
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * Human-readable message indicating details about last transition.
             */
            message?: pulumi.Input<string>;
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason?: pulumi.Input<string>;
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status?: pulumi.Input<string>;
            /**
             * Type is the type of the condition.
             */
            type?: pulumi.Input<string>;
        }

        export interface NodeStatusSnapshotCheckStatus {
            lastPeriodicCheckedAt?: pulumi.Input<string>;
        }

        /**
         * Orphan is where Longhorn stores orphan object.
         */
        export interface Orphan {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta2">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"Orphan">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.longhorn.v1beta2.OrphanSpec>;
            status?: pulumi.Input<inputs.longhorn.v1beta2.OrphanStatus>;
        }

        /**
         * OrphanSpec defines the desired state of the Longhorn orphaned data
         */
        export interface OrphanSpec {
            /**
             * The type of data engine for instance orphan.
             * Can be "v1", "v2".
             */
            dataEngine?: pulumi.Input<string>;
            /**
             * The node ID on which the controller is responsible to reconcile this orphan CR.
             */
            nodeID?: pulumi.Input<string>;
            /**
             * The type of the orphaned data.
             * Can be "replica".
             */
            orphanType?: pulumi.Input<string>;
            /**
             * The parameters of the orphaned data
             */
            parameters?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * OrphanSpec defines the desired state of the Longhorn orphaned data
         */
        export interface OrphanSpecPatch {
            /**
             * The type of data engine for instance orphan.
             * Can be "v1", "v2".
             */
            dataEngine?: pulumi.Input<string>;
            /**
             * The node ID on which the controller is responsible to reconcile this orphan CR.
             */
            nodeID?: pulumi.Input<string>;
            /**
             * The type of the orphaned data.
             * Can be "replica".
             */
            orphanType?: pulumi.Input<string>;
            /**
             * The parameters of the orphaned data
             */
            parameters?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * OrphanStatus defines the observed state of the Longhorn orphaned data
         */
        export interface OrphanStatus {
            conditions?: pulumi.Input<pulumi.Input<inputs.longhorn.v1beta2.OrphanStatusConditions>[]>;
            ownerID?: pulumi.Input<string>;
        }

        export interface OrphanStatusConditions {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime?: pulumi.Input<string>;
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * Human-readable message indicating details about last transition.
             */
            message?: pulumi.Input<string>;
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason?: pulumi.Input<string>;
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status?: pulumi.Input<string>;
            /**
             * Type is the type of the condition.
             */
            type?: pulumi.Input<string>;
        }

        /**
         * RecurringJob is where Longhorn stores recurring job object.
         */
        export interface RecurringJob {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta2">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"RecurringJob">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.longhorn.v1beta2.RecurringJobSpec>;
            status?: pulumi.Input<inputs.longhorn.v1beta2.RecurringJobStatus>;
        }

        /**
         * RecurringJobSpec defines the desired state of the Longhorn recurring job
         */
        export interface RecurringJobSpec {
            /**
             * The concurrency of taking the snapshot/backup.
             */
            concurrency?: pulumi.Input<number>;
            /**
             * The cron setting.
             */
            cron?: pulumi.Input<string>;
            /**
             * The recurring job group.
             */
            groups?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The label of the snapshot/backup.
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * The recurring job name.
             */
            name?: pulumi.Input<string>;
            /**
             * The parameters of the snapshot/backup.
             * Support parameters: "full-backup-interval", "volume-backup-policy".
             */
            parameters?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * The retain count of the snapshot/backup.
             */
            retain?: pulumi.Input<number>;
            /**
             * The recurring job task.
             * Can be "snapshot", "snapshot-force-create", "snapshot-cleanup", "snapshot-delete", "backup", "backup-force-create", "filesystem-trim" or "system-backup".
             */
            task?: pulumi.Input<string>;
        }

        /**
         * RecurringJobSpec defines the desired state of the Longhorn recurring job
         */
        export interface RecurringJobSpecPatch {
            /**
             * The concurrency of taking the snapshot/backup.
             */
            concurrency?: pulumi.Input<number>;
            /**
             * The cron setting.
             */
            cron?: pulumi.Input<string>;
            /**
             * The recurring job group.
             */
            groups?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * The label of the snapshot/backup.
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * The recurring job name.
             */
            name?: pulumi.Input<string>;
            /**
             * The parameters of the snapshot/backup.
             * Support parameters: "full-backup-interval", "volume-backup-policy".
             */
            parameters?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * The retain count of the snapshot/backup.
             */
            retain?: pulumi.Input<number>;
            /**
             * The recurring job task.
             * Can be "snapshot", "snapshot-force-create", "snapshot-cleanup", "snapshot-delete", "backup", "backup-force-create", "filesystem-trim" or "system-backup".
             */
            task?: pulumi.Input<string>;
        }

        /**
         * RecurringJobStatus defines the observed state of the Longhorn recurring job
         */
        export interface RecurringJobStatus {
            /**
             * The number of jobs that have been triggered.
             */
            executionCount?: pulumi.Input<number>;
            /**
             * The owner ID which is responsible to reconcile this recurring job CR.
             */
            ownerID?: pulumi.Input<string>;
        }

        /**
         * Replica is where Longhorn stores replica object.
         */
        export interface Replica {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta2">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"Replica">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.longhorn.v1beta2.ReplicaSpec>;
            status?: pulumi.Input<inputs.longhorn.v1beta2.ReplicaStatus>;
        }

        /**
         * ReplicaSpec defines the desired state of the Longhorn replica
         */
        export interface ReplicaSpec {
            active?: pulumi.Input<boolean>;
            backingImage?: pulumi.Input<string>;
            dataDirectoryName?: pulumi.Input<string>;
            dataEngine?: pulumi.Input<string>;
            desireState?: pulumi.Input<string>;
            diskID?: pulumi.Input<string>;
            diskPath?: pulumi.Input<string>;
            engineName?: pulumi.Input<string>;
            evictionRequested?: pulumi.Input<boolean>;
            /**
             * FailedAt is set when a running replica fails or when a running engine is unable to use a replica for any reason.
             * FailedAt indicates the time the failure occurred. When FailedAt is set, a replica is likely to have useful
             * (though possibly stale) data. A replica with FailedAt set must be rebuilt from a non-failed replica (or it can
             * be used in a salvage if all replicas are failed). FailedAt is cleared before a rebuild or salvage. FailedAt may
             * be later than the corresponding entry in an engine's replicaTransitionTimeMap because it is set when the volume
             * controller acknowledges the change.
             */
            failedAt?: pulumi.Input<string>;
            hardNodeAffinity?: pulumi.Input<string>;
            /**
             * HealthyAt is set the first time a replica becomes read/write in an engine after creation or rebuild. HealthyAt
             * indicates the time the last successful rebuild occurred. When HealthyAt is set, a replica is likely to have
             * useful (though possibly stale) data. HealthyAt is cleared before a rebuild. HealthyAt may be later than the
             * corresponding entry in an engine's replicaTransitionTimeMap because it is set when the volume controller
             * acknowledges the change.
             */
            healthyAt?: pulumi.Input<string>;
            image?: pulumi.Input<string>;
            /**
             * LastFailedAt is always set at the same time as FailedAt. Unlike FailedAt, LastFailedAt is never cleared.
             * LastFailedAt is not a reliable indicator of the state of a replica's data. For example, a replica with
             * LastFailedAt may already be healthy and in use again. However, because it is never cleared, it can be compared to
             * LastHealthyAt to help prevent dangerous replica deletion in some corner cases. LastFailedAt may be later than the
             * corresponding entry in an engine's replicaTransitionTimeMap because it is set when the volume controller
             * acknowledges the change.
             */
            lastFailedAt?: pulumi.Input<string>;
            /**
             * LastHealthyAt is set every time a replica becomes read/write in an engine. Unlike HealthyAt, LastHealthyAt is
             * never cleared. LastHealthyAt is not a reliable indicator of the state of a replica's data. For example, a
             * replica with LastHealthyAt set may be in the middle of a rebuild. However, because it is never cleared, it can be
             * compared to LastFailedAt to help prevent dangerous replica deletion in some corner cases. LastHealthyAt may be
             * later than the corresponding entry in an engine's replicaTransitionTimeMap because it is set when the volume
             * controller acknowledges the change.
             */
            lastHealthyAt?: pulumi.Input<string>;
            logRequested?: pulumi.Input<boolean>;
            /**
             * MigrationEngineName is indicating the migrating engine which current connected to this replica. This is only
             * used for live migration of v2 data engine
             */
            migrationEngineName?: pulumi.Input<string>;
            nodeID?: pulumi.Input<string>;
            rebuildRetryCount?: pulumi.Input<number>;
            revisionCounterDisabled?: pulumi.Input<boolean>;
            salvageRequested?: pulumi.Input<boolean>;
            snapshotMaxCount?: pulumi.Input<number>;
            snapshotMaxSize?: pulumi.Input<string>;
            unmapMarkDiskChainRemovedEnabled?: pulumi.Input<boolean>;
            volumeName?: pulumi.Input<string>;
            volumeSize?: pulumi.Input<string>;
        }

        /**
         * ReplicaSpec defines the desired state of the Longhorn replica
         */
        export interface ReplicaSpecPatch {
            active?: pulumi.Input<boolean>;
            backingImage?: pulumi.Input<string>;
            dataDirectoryName?: pulumi.Input<string>;
            dataEngine?: pulumi.Input<string>;
            desireState?: pulumi.Input<string>;
            diskID?: pulumi.Input<string>;
            diskPath?: pulumi.Input<string>;
            engineName?: pulumi.Input<string>;
            evictionRequested?: pulumi.Input<boolean>;
            /**
             * FailedAt is set when a running replica fails or when a running engine is unable to use a replica for any reason.
             * FailedAt indicates the time the failure occurred. When FailedAt is set, a replica is likely to have useful
             * (though possibly stale) data. A replica with FailedAt set must be rebuilt from a non-failed replica (or it can
             * be used in a salvage if all replicas are failed). FailedAt is cleared before a rebuild or salvage. FailedAt may
             * be later than the corresponding entry in an engine's replicaTransitionTimeMap because it is set when the volume
             * controller acknowledges the change.
             */
            failedAt?: pulumi.Input<string>;
            hardNodeAffinity?: pulumi.Input<string>;
            /**
             * HealthyAt is set the first time a replica becomes read/write in an engine after creation or rebuild. HealthyAt
             * indicates the time the last successful rebuild occurred. When HealthyAt is set, a replica is likely to have
             * useful (though possibly stale) data. HealthyAt is cleared before a rebuild. HealthyAt may be later than the
             * corresponding entry in an engine's replicaTransitionTimeMap because it is set when the volume controller
             * acknowledges the change.
             */
            healthyAt?: pulumi.Input<string>;
            image?: pulumi.Input<string>;
            /**
             * LastFailedAt is always set at the same time as FailedAt. Unlike FailedAt, LastFailedAt is never cleared.
             * LastFailedAt is not a reliable indicator of the state of a replica's data. For example, a replica with
             * LastFailedAt may already be healthy and in use again. However, because it is never cleared, it can be compared to
             * LastHealthyAt to help prevent dangerous replica deletion in some corner cases. LastFailedAt may be later than the
             * corresponding entry in an engine's replicaTransitionTimeMap because it is set when the volume controller
             * acknowledges the change.
             */
            lastFailedAt?: pulumi.Input<string>;
            /**
             * LastHealthyAt is set every time a replica becomes read/write in an engine. Unlike HealthyAt, LastHealthyAt is
             * never cleared. LastHealthyAt is not a reliable indicator of the state of a replica's data. For example, a
             * replica with LastHealthyAt set may be in the middle of a rebuild. However, because it is never cleared, it can be
             * compared to LastFailedAt to help prevent dangerous replica deletion in some corner cases. LastHealthyAt may be
             * later than the corresponding entry in an engine's replicaTransitionTimeMap because it is set when the volume
             * controller acknowledges the change.
             */
            lastHealthyAt?: pulumi.Input<string>;
            logRequested?: pulumi.Input<boolean>;
            /**
             * MigrationEngineName is indicating the migrating engine which current connected to this replica. This is only
             * used for live migration of v2 data engine
             */
            migrationEngineName?: pulumi.Input<string>;
            nodeID?: pulumi.Input<string>;
            rebuildRetryCount?: pulumi.Input<number>;
            revisionCounterDisabled?: pulumi.Input<boolean>;
            salvageRequested?: pulumi.Input<boolean>;
            snapshotMaxCount?: pulumi.Input<number>;
            snapshotMaxSize?: pulumi.Input<string>;
            unmapMarkDiskChainRemovedEnabled?: pulumi.Input<boolean>;
            volumeName?: pulumi.Input<string>;
            volumeSize?: pulumi.Input<string>;
        }

        /**
         * ReplicaStatus defines the observed state of the Longhorn replica
         */
        export interface ReplicaStatus {
            conditions?: pulumi.Input<pulumi.Input<inputs.longhorn.v1beta2.ReplicaStatusConditions>[]>;
            currentImage?: pulumi.Input<string>;
            currentState?: pulumi.Input<string>;
            /**
             * Deprecated: Replaced by field `spec.evictionRequested`.
             */
            evictionRequested?: pulumi.Input<boolean>;
            instanceManagerName?: pulumi.Input<string>;
            ip?: pulumi.Input<string>;
            logFetched?: pulumi.Input<boolean>;
            ownerID?: pulumi.Input<string>;
            port?: pulumi.Input<number>;
            salvageExecuted?: pulumi.Input<boolean>;
            started?: pulumi.Input<boolean>;
            storageIP?: pulumi.Input<string>;
            ublkID?: pulumi.Input<number>;
            uuid?: pulumi.Input<string>;
        }

        export interface ReplicaStatusConditions {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime?: pulumi.Input<string>;
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * Human-readable message indicating details about last transition.
             */
            message?: pulumi.Input<string>;
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason?: pulumi.Input<string>;
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status?: pulumi.Input<string>;
            /**
             * Type is the type of the condition.
             */
            type?: pulumi.Input<string>;
        }

        /**
         * Setting is where Longhorn stores setting object.
         */
        export interface Setting {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta2">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"Setting">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            status?: pulumi.Input<inputs.longhorn.v1beta2.SettingStatus>;
            /**
             * The value of the setting.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * The status of the setting.
         */
        export interface SettingStatus {
            /**
             * The setting is applied.
             */
            applied?: pulumi.Input<boolean>;
        }

        /**
         * ShareManager is where Longhorn stores share manager object.
         */
        export interface ShareManager {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta2">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"ShareManager">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.longhorn.v1beta2.ShareManagerSpec>;
            status?: pulumi.Input<inputs.longhorn.v1beta2.ShareManagerStatus>;
        }

        /**
         * ShareManagerSpec defines the desired state of the Longhorn share manager
         */
        export interface ShareManagerSpec {
            /**
             * Share manager image used for creating a share manager pod
             */
            image?: pulumi.Input<string>;
        }

        /**
         * ShareManagerSpec defines the desired state of the Longhorn share manager
         */
        export interface ShareManagerSpecPatch {
            /**
             * Share manager image used for creating a share manager pod
             */
            image?: pulumi.Input<string>;
        }

        /**
         * ShareManagerStatus defines the observed state of the Longhorn share manager
         */
        export interface ShareManagerStatus {
            /**
             * NFS endpoint that can access the mounted filesystem of the volume
             */
            endpoint?: pulumi.Input<string>;
            /**
             * The node ID on which the controller is responsible to reconcile this share manager resource
             */
            ownerID?: pulumi.Input<string>;
            /**
             * The state of the share manager resource
             */
            state?: pulumi.Input<string>;
        }

        /**
         * Snapshot is the Schema for the snapshots API
         */
        export interface Snapshot {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta2">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"Snapshot">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.longhorn.v1beta2.SnapshotSpec>;
            status?: pulumi.Input<inputs.longhorn.v1beta2.SnapshotStatus>;
        }

        /**
         * SnapshotSpec defines the desired state of Longhorn Snapshot
         */
        export interface SnapshotSpec {
            /**
             * require creating a new snapshot
             */
            createSnapshot?: pulumi.Input<boolean>;
            /**
             * The labels of snapshot
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * the volume that this snapshot belongs to.
             * This field is immutable after creation.
             */
            volume?: pulumi.Input<string>;
        }

        /**
         * SnapshotSpec defines the desired state of Longhorn Snapshot
         */
        export interface SnapshotSpecPatch {
            /**
             * require creating a new snapshot
             */
            createSnapshot?: pulumi.Input<boolean>;
            /**
             * The labels of snapshot
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * the volume that this snapshot belongs to.
             * This field is immutable after creation.
             */
            volume?: pulumi.Input<string>;
        }

        /**
         * SnapshotStatus defines the observed state of Longhorn Snapshot
         */
        export interface SnapshotStatus {
            checksum?: pulumi.Input<string>;
            children?: pulumi.Input<{[key: string]: pulumi.Input<boolean>}>;
            creationTime?: pulumi.Input<string>;
            error?: pulumi.Input<string>;
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            markRemoved?: pulumi.Input<boolean>;
            ownerID?: pulumi.Input<string>;
            parent?: pulumi.Input<string>;
            readyToUse?: pulumi.Input<boolean>;
            restoreSize?: pulumi.Input<number>;
            size?: pulumi.Input<number>;
            userCreated?: pulumi.Input<boolean>;
        }

        /**
         * SupportBundle is where Longhorn stores support bundle object
         */
        export interface SupportBundle {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta2">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"SupportBundle">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.longhorn.v1beta2.SupportBundleSpec>;
            status?: pulumi.Input<inputs.longhorn.v1beta2.SupportBundleStatus>;
        }

        /**
         * SupportBundleSpec defines the desired state of the Longhorn SupportBundle
         */
        export interface SupportBundleSpec {
            /**
             * A brief description of the issue
             */
            description?: pulumi.Input<string>;
            /**
             * The issue URL
             */
            issueURL?: pulumi.Input<string>;
            /**
             * The preferred responsible controller node ID.
             */
            nodeID?: pulumi.Input<string>;
        }

        /**
         * SupportBundleSpec defines the desired state of the Longhorn SupportBundle
         */
        export interface SupportBundleSpecPatch {
            /**
             * A brief description of the issue
             */
            description?: pulumi.Input<string>;
            /**
             * The issue URL
             */
            issueURL?: pulumi.Input<string>;
            /**
             * The preferred responsible controller node ID.
             */
            nodeID?: pulumi.Input<string>;
        }

        /**
         * SupportBundleStatus defines the observed state of the Longhorn SupportBundle
         */
        export interface SupportBundleStatus {
            conditions?: pulumi.Input<pulumi.Input<inputs.longhorn.v1beta2.SupportBundleStatusConditions>[]>;
            filename?: pulumi.Input<string>;
            filesize?: pulumi.Input<number>;
            /**
             * The support bundle manager image
             */
            image?: pulumi.Input<string>;
            /**
             * The support bundle manager IP
             */
            managerIP?: pulumi.Input<string>;
            /**
             * The current responsible controller node ID
             */
            ownerID?: pulumi.Input<string>;
            progress?: pulumi.Input<number>;
            state?: pulumi.Input<string>;
        }

        export interface SupportBundleStatusConditions {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime?: pulumi.Input<string>;
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * Human-readable message indicating details about last transition.
             */
            message?: pulumi.Input<string>;
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason?: pulumi.Input<string>;
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status?: pulumi.Input<string>;
            /**
             * Type is the type of the condition.
             */
            type?: pulumi.Input<string>;
        }

        /**
         * SystemBackup is where Longhorn stores system backup object
         */
        export interface SystemBackup {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta2">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"SystemBackup">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.longhorn.v1beta2.SystemBackupSpec>;
            status?: pulumi.Input<inputs.longhorn.v1beta2.SystemBackupStatus>;
        }

        /**
         * SystemBackupSpec defines the desired state of the Longhorn SystemBackup
         */
        export interface SystemBackupSpec {
            /**
             * The create volume backup policy
             * Can be "if-not-present", "always" or "disabled"
             */
            volumeBackupPolicy?: pulumi.Input<string>;
        }

        /**
         * SystemBackupSpec defines the desired state of the Longhorn SystemBackup
         */
        export interface SystemBackupSpecPatch {
            /**
             * The create volume backup policy
             * Can be "if-not-present", "always" or "disabled"
             */
            volumeBackupPolicy?: pulumi.Input<string>;
        }

        /**
         * SystemBackupStatus defines the observed state of the Longhorn SystemBackup
         */
        export interface SystemBackupStatus {
            conditions?: pulumi.Input<pulumi.Input<inputs.longhorn.v1beta2.SystemBackupStatusConditions>[]>;
            /**
             * The system backup creation time.
             */
            createdAt?: pulumi.Input<string>;
            /**
             * The saved Longhorn manager git commit.
             */
            gitCommit?: pulumi.Input<string>;
            /**
             * The last time that the system backup was synced into the cluster.
             */
            lastSyncedAt?: pulumi.Input<string>;
            /**
             * The saved manager image.
             */
            managerImage?: pulumi.Input<string>;
            /**
             * The node ID of the responsible controller to reconcile this SystemBackup.
             */
            ownerID?: pulumi.Input<string>;
            /**
             * The system backup state.
             */
            state?: pulumi.Input<string>;
            /**
             * The saved Longhorn version.
             */
            version?: pulumi.Input<string>;
        }

        export interface SystemBackupStatusConditions {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime?: pulumi.Input<string>;
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * Human-readable message indicating details about last transition.
             */
            message?: pulumi.Input<string>;
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason?: pulumi.Input<string>;
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status?: pulumi.Input<string>;
            /**
             * Type is the type of the condition.
             */
            type?: pulumi.Input<string>;
        }

        /**
         * SystemRestore is where Longhorn stores system restore object
         */
        export interface SystemRestore {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta2">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"SystemRestore">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.longhorn.v1beta2.SystemRestoreSpec>;
            status?: pulumi.Input<inputs.longhorn.v1beta2.SystemRestoreStatus>;
        }

        /**
         * SystemRestoreSpec defines the desired state of the Longhorn SystemRestore
         */
        export interface SystemRestoreSpec {
            /**
             * The system backup name in the object store.
             */
            systemBackup?: pulumi.Input<string>;
        }

        /**
         * SystemRestoreSpec defines the desired state of the Longhorn SystemRestore
         */
        export interface SystemRestoreSpecPatch {
            /**
             * The system backup name in the object store.
             */
            systemBackup?: pulumi.Input<string>;
        }

        /**
         * SystemRestoreStatus defines the observed state of the Longhorn SystemRestore
         */
        export interface SystemRestoreStatus {
            conditions?: pulumi.Input<pulumi.Input<inputs.longhorn.v1beta2.SystemRestoreStatusConditions>[]>;
            /**
             * The node ID of the responsible controller to reconcile this SystemRestore.
             */
            ownerID?: pulumi.Input<string>;
            /**
             * The source system backup URL.
             */
            sourceURL?: pulumi.Input<string>;
            /**
             * The system restore state.
             */
            state?: pulumi.Input<string>;
        }

        export interface SystemRestoreStatusConditions {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime?: pulumi.Input<string>;
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * Human-readable message indicating details about last transition.
             */
            message?: pulumi.Input<string>;
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason?: pulumi.Input<string>;
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status?: pulumi.Input<string>;
            /**
             * Type is the type of the condition.
             */
            type?: pulumi.Input<string>;
        }

        /**
         * Volume is where Longhorn stores volume object.
         */
        export interface Volume {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta2">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"Volume">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.longhorn.v1beta2.VolumeSpec>;
            status?: pulumi.Input<inputs.longhorn.v1beta2.VolumeStatus>;
        }

        /**
         * VolumeAttachment stores attachment information of a Longhorn volume
         */
        export interface VolumeAttachment {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion?: pulumi.Input<"longhorn.io/v1beta2">;
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<"VolumeAttachment">;
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata?: pulumi.Input<inputs.meta.v1.ObjectMeta>;
            spec?: pulumi.Input<inputs.longhorn.v1beta2.VolumeAttachmentSpec>;
            status?: pulumi.Input<inputs.longhorn.v1beta2.VolumeAttachmentStatus>;
        }

        /**
         * VolumeAttachmentSpec defines the desired state of Longhorn VolumeAttachment
         */
        export interface VolumeAttachmentSpec {
            attachmentTickets?: pulumi.Input<{[key: string]: pulumi.Input<{[key: string]: pulumi.Input<string>}>}>;
            /**
             * The name of Longhorn volume of this VolumeAttachment
             */
            volume?: pulumi.Input<string>;
        }

        /**
         * VolumeAttachmentSpec defines the desired state of Longhorn VolumeAttachment
         */
        export interface VolumeAttachmentSpecPatch {
            attachmentTickets?: pulumi.Input<{[key: string]: pulumi.Input<{[key: string]: pulumi.Input<string>}>}>;
            /**
             * The name of Longhorn volume of this VolumeAttachment
             */
            volume?: pulumi.Input<string>;
        }

        /**
         * VolumeAttachmentStatus defines the observed state of Longhorn VolumeAttachment
         */
        export interface VolumeAttachmentStatus {
            attachmentTicketStatuses?: pulumi.Input<{[key: string]: pulumi.Input<{[key: string]: pulumi.Input<string>}>}>;
        }

        /**
         * VolumeSpec defines the desired state of the Longhorn volume
         */
        export interface VolumeSpec {
            Standby?: pulumi.Input<boolean>;
            accessMode?: pulumi.Input<string>;
            backingImage?: pulumi.Input<string>;
            backupCompressionMethod?: pulumi.Input<string>;
            /**
             * The backup target name that the volume will be backed up to or is synced.
             */
            backupTargetName?: pulumi.Input<string>;
            dataEngine?: pulumi.Input<string>;
            dataLocality?: pulumi.Input<string>;
            dataSource?: pulumi.Input<string>;
            disableFrontend?: pulumi.Input<boolean>;
            diskSelector?: pulumi.Input<pulumi.Input<string>[]>;
            encrypted?: pulumi.Input<boolean>;
            /**
             * Setting that freezes the filesystem on the root partition before a snapshot is created.
             */
            freezeFilesystemForSnapshot?: pulumi.Input<string>;
            fromBackup?: pulumi.Input<string>;
            frontend?: pulumi.Input<string>;
            image?: pulumi.Input<string>;
            lastAttachedBy?: pulumi.Input<string>;
            migratable?: pulumi.Input<boolean>;
            migrationNodeID?: pulumi.Input<string>;
            nodeID?: pulumi.Input<string>;
            nodeSelector?: pulumi.Input<pulumi.Input<string>[]>;
            numberOfReplicas?: pulumi.Input<number>;
            /**
             * Specifies whether Longhorn should rebuild replicas while the detached volume is degraded.
             * - ignored: Use the global setting for offline replica rebuilding.
             * - enabled: Enable offline rebuilding for this volume, regardless of the global setting.
             * - disabled: Disable offline rebuilding for this volume, regardless of the global setting
             */
            offlineRebuilding?: pulumi.Input<string>;
            replicaAutoBalance?: pulumi.Input<string>;
            /**
             * Replica disk soft anti affinity of the volume. Set enabled to allow replicas to be scheduled in the same disk.
             */
            replicaDiskSoftAntiAffinity?: pulumi.Input<string>;
            /**
             * Replica soft anti affinity of the volume. Set enabled to allow replicas to be scheduled on the same node.
             */
            replicaSoftAntiAffinity?: pulumi.Input<string>;
            /**
             * Replica zone soft anti affinity of the volume. Set enabled to allow replicas to be scheduled in the same zone.
             */
            replicaZoneSoftAntiAffinity?: pulumi.Input<string>;
            restoreVolumeRecurringJob?: pulumi.Input<string>;
            revisionCounterDisabled?: pulumi.Input<boolean>;
            size?: pulumi.Input<string>;
            snapshotDataIntegrity?: pulumi.Input<string>;
            snapshotMaxCount?: pulumi.Input<number>;
            snapshotMaxSize?: pulumi.Input<string>;
            staleReplicaTimeout?: pulumi.Input<number>;
            unmapMarkSnapChainRemoved?: pulumi.Input<string>;
        }

        /**
         * VolumeSpec defines the desired state of the Longhorn volume
         */
        export interface VolumeSpecPatch {
            Standby?: pulumi.Input<boolean>;
            accessMode?: pulumi.Input<string>;
            backingImage?: pulumi.Input<string>;
            backupCompressionMethod?: pulumi.Input<string>;
            /**
             * The backup target name that the volume will be backed up to or is synced.
             */
            backupTargetName?: pulumi.Input<string>;
            dataEngine?: pulumi.Input<string>;
            dataLocality?: pulumi.Input<string>;
            dataSource?: pulumi.Input<string>;
            disableFrontend?: pulumi.Input<boolean>;
            diskSelector?: pulumi.Input<pulumi.Input<string>[]>;
            encrypted?: pulumi.Input<boolean>;
            /**
             * Setting that freezes the filesystem on the root partition before a snapshot is created.
             */
            freezeFilesystemForSnapshot?: pulumi.Input<string>;
            fromBackup?: pulumi.Input<string>;
            frontend?: pulumi.Input<string>;
            image?: pulumi.Input<string>;
            lastAttachedBy?: pulumi.Input<string>;
            migratable?: pulumi.Input<boolean>;
            migrationNodeID?: pulumi.Input<string>;
            nodeID?: pulumi.Input<string>;
            nodeSelector?: pulumi.Input<pulumi.Input<string>[]>;
            numberOfReplicas?: pulumi.Input<number>;
            /**
             * Specifies whether Longhorn should rebuild replicas while the detached volume is degraded.
             * - ignored: Use the global setting for offline replica rebuilding.
             * - enabled: Enable offline rebuilding for this volume, regardless of the global setting.
             * - disabled: Disable offline rebuilding for this volume, regardless of the global setting
             */
            offlineRebuilding?: pulumi.Input<string>;
            replicaAutoBalance?: pulumi.Input<string>;
            /**
             * Replica disk soft anti affinity of the volume. Set enabled to allow replicas to be scheduled in the same disk.
             */
            replicaDiskSoftAntiAffinity?: pulumi.Input<string>;
            /**
             * Replica soft anti affinity of the volume. Set enabled to allow replicas to be scheduled on the same node.
             */
            replicaSoftAntiAffinity?: pulumi.Input<string>;
            /**
             * Replica zone soft anti affinity of the volume. Set enabled to allow replicas to be scheduled in the same zone.
             */
            replicaZoneSoftAntiAffinity?: pulumi.Input<string>;
            restoreVolumeRecurringJob?: pulumi.Input<string>;
            revisionCounterDisabled?: pulumi.Input<boolean>;
            size?: pulumi.Input<string>;
            snapshotDataIntegrity?: pulumi.Input<string>;
            snapshotMaxCount?: pulumi.Input<number>;
            snapshotMaxSize?: pulumi.Input<string>;
            staleReplicaTimeout?: pulumi.Input<number>;
            unmapMarkSnapChainRemoved?: pulumi.Input<string>;
        }

        /**
         * VolumeStatus defines the observed state of the Longhorn volume
         */
        export interface VolumeStatus {
            actualSize?: pulumi.Input<number>;
            cloneStatus?: pulumi.Input<inputs.longhorn.v1beta2.VolumeStatusCloneStatus>;
            conditions?: pulumi.Input<pulumi.Input<inputs.longhorn.v1beta2.VolumeStatusConditions>[]>;
            currentImage?: pulumi.Input<string>;
            /**
             * the node that this volume is currently migrating to
             */
            currentMigrationNodeID?: pulumi.Input<string>;
            currentNodeID?: pulumi.Input<string>;
            expansionRequired?: pulumi.Input<boolean>;
            frontendDisabled?: pulumi.Input<boolean>;
            isStandby?: pulumi.Input<boolean>;
            kubernetesStatus?: pulumi.Input<inputs.longhorn.v1beta2.VolumeStatusKubernetesStatus>;
            lastBackup?: pulumi.Input<string>;
            lastBackupAt?: pulumi.Input<string>;
            lastDegradedAt?: pulumi.Input<string>;
            ownerID?: pulumi.Input<string>;
            remountRequestedAt?: pulumi.Input<string>;
            restoreInitiated?: pulumi.Input<boolean>;
            restoreRequired?: pulumi.Input<boolean>;
            robustness?: pulumi.Input<string>;
            shareEndpoint?: pulumi.Input<string>;
            shareState?: pulumi.Input<string>;
            state?: pulumi.Input<string>;
        }

        export interface VolumeStatusCloneStatus {
            attemptCount?: pulumi.Input<number>;
            nextAllowedAttemptAt?: pulumi.Input<string>;
            snapshot?: pulumi.Input<string>;
            sourceVolume?: pulumi.Input<string>;
            state?: pulumi.Input<string>;
        }

        export interface VolumeStatusConditions {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime?: pulumi.Input<string>;
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime?: pulumi.Input<string>;
            /**
             * Human-readable message indicating details about last transition.
             */
            message?: pulumi.Input<string>;
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason?: pulumi.Input<string>;
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status?: pulumi.Input<string>;
            /**
             * Type is the type of the condition.
             */
            type?: pulumi.Input<string>;
        }

        export interface VolumeStatusKubernetesStatus {
            lastPVCRefAt?: pulumi.Input<string>;
            lastPodRefAt?: pulumi.Input<string>;
            /**
             * determine if PVC/Namespace is history or not
             */
            namespace?: pulumi.Input<string>;
            pvName?: pulumi.Input<string>;
            pvStatus?: pulumi.Input<string>;
            pvcName?: pulumi.Input<string>;
            /**
             * determine if Pod/Workload is history or not
             */
            workloadsStatus?: pulumi.Input<pulumi.Input<inputs.longhorn.v1beta2.VolumeStatusKubernetesStatusWorkloadsStatus>[]>;
        }

        export interface VolumeStatusKubernetesStatusWorkloadsStatus {
            podName?: pulumi.Input<string>;
            podStatus?: pulumi.Input<string>;
            workloadName?: pulumi.Input<string>;
            workloadType?: pulumi.Input<string>;
        }

    }
}

export namespace meta {
    export namespace v1 {
        /**
         * ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
         */
        export interface ListMeta {
            /**
             * continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.
             */
            continue?: pulumi.Input<string>;
            /**
             * remainingItemCount is the number of subsequent items in the list which are not included in this list response. If the list request contained label or field selectors, then the number of remaining items is unknown and the field will be left unset and omitted during serialization. If the list is complete (either because it is not chunking or because this is the last chunk), then there are no more remaining items and this field will be left unset and omitted during serialization. Servers older than v1.15 do not set this field. The intended use of the remainingItemCount is *estimating* the size of a collection. Clients should not rely on the remainingItemCount to be set or to be exact.
             */
            remainingItemCount?: pulumi.Input<number>;
            /**
             * String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: pulumi.Input<string>;
            /**
             * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
             */
            selfLink?: pulumi.Input<string>;
        }

        /**
         * ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to.
         */
        export interface ManagedFieldsEntry {
            /**
             * APIVersion defines the version of this resource that this field set applies to. The format is "group/version" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: "FieldsV1"
             */
            fieldsType?: pulumi.Input<string>;
            /**
             * FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
             */
            fieldsV1?: any;
            /**
             * Manager is an identifier of the workflow managing these fields.
             */
            manager?: pulumi.Input<string>;
            /**
             * Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.
             */
            operation?: pulumi.Input<string>;
            /**
             * Subresource is the name of the subresource used to update that object, or empty string if the object was updated through the main resource. The value of this field is used to distinguish between managers, even if they share the same name. For example, a status update will be distinct from a regular update using the same manager name. Note that the APIVersion field is not related to the Subresource field and it always corresponds to the version of the main resource.
             */
            subresource?: pulumi.Input<string>;
            /**
             * Time is the timestamp of when the ManagedFields entry was added. The timestamp will also be updated if a field is added, the manager changes any of the owned fields value or removes a field. The timestamp does not update when a field is removed from the entry because another manager took it over.
             */
            time?: pulumi.Input<string>;
        }

        /**
         * ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to.
         */
        export interface ManagedFieldsEntryPatch {
            /**
             * APIVersion defines the version of this resource that this field set applies to. The format is "group/version" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: "FieldsV1"
             */
            fieldsType?: pulumi.Input<string>;
            /**
             * FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
             */
            fieldsV1?: any;
            /**
             * Manager is an identifier of the workflow managing these fields.
             */
            manager?: pulumi.Input<string>;
            /**
             * Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.
             */
            operation?: pulumi.Input<string>;
            /**
             * Subresource is the name of the subresource used to update that object, or empty string if the object was updated through the main resource. The value of this field is used to distinguish between managers, even if they share the same name. For example, a status update will be distinct from a regular update using the same manager name. Note that the APIVersion field is not related to the Subresource field and it always corresponds to the version of the main resource.
             */
            subresource?: pulumi.Input<string>;
            /**
             * Time is the timestamp of when the ManagedFields entry was added. The timestamp will also be updated if a field is added, the manager changes any of the owned fields value or removes a field. The timestamp does not update when a field is removed from the entry because another manager took it over.
             */
            time?: pulumi.Input<string>;
        }

        /**
         * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
         */
        export interface ObjectMeta {
            /**
             * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
             */
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.
             *
             * Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            creationTimestamp?: pulumi.Input<string>;
            /**
             * Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
             */
            deletionGracePeriodSeconds?: pulumi.Input<number>;
            /**
             * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested.
             *
             * Populated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            deletionTimestamp?: pulumi.Input<string>;
            /**
             * Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list.
             */
            finalizers?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
             *
             * If this field is specified and the generated name exists, the server will return a 409.
             *
             * Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
             */
            generateName?: pulumi.Input<string>;
            /**
             * A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.
             */
            generation?: pulumi.Input<number>;
            /**
             * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like "ci-cd". The set of fields is always in the version that the workflow used when modifying the object.
             */
            managedFields?: pulumi.Input<pulumi.Input<inputs.meta.v1.ManagedFieldsEntry>[]>;
            /**
             * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
             *
             * Must be a DNS_LABEL. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
             */
            namespace?: pulumi.Input<string>;
            /**
             * List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.
             */
            ownerReferences?: pulumi.Input<pulumi.Input<inputs.meta.v1.OwnerReference>[]>;
            /**
             * An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.
             *
             * Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: pulumi.Input<string>;
            /**
             * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
             */
            selfLink?: pulumi.Input<string>;
            /**
             * UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.
             *
             * Populated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
             */
            uid?: pulumi.Input<string>;
        }

        /**
         * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
         */
        export interface ObjectMetaPatch {
            /**
             * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
             */
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.
             *
             * Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            creationTimestamp?: pulumi.Input<string>;
            /**
             * Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
             */
            deletionGracePeriodSeconds?: pulumi.Input<number>;
            /**
             * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested.
             *
             * Populated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            deletionTimestamp?: pulumi.Input<string>;
            /**
             * Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list.
             */
            finalizers?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
             *
             * If this field is specified and the generated name exists, the server will return a 409.
             *
             * Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
             */
            generateName?: pulumi.Input<string>;
            /**
             * A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.
             */
            generation?: pulumi.Input<number>;
            /**
             * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like "ci-cd". The set of fields is always in the version that the workflow used when modifying the object.
             */
            managedFields?: pulumi.Input<pulumi.Input<inputs.meta.v1.ManagedFieldsEntryPatch>[]>;
            /**
             * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
             */
            name?: pulumi.Input<string>;
            /**
             * Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
             *
             * Must be a DNS_LABEL. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
             */
            namespace?: pulumi.Input<string>;
            /**
             * List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.
             */
            ownerReferences?: pulumi.Input<pulumi.Input<inputs.meta.v1.OwnerReferencePatch>[]>;
            /**
             * An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.
             *
             * Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion?: pulumi.Input<string>;
            /**
             * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
             */
            selfLink?: pulumi.Input<string>;
            /**
             * UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.
             *
             * Populated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
             */
            uid?: pulumi.Input<string>;
        }

        /**
         * OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.
         */
        export interface OwnerReference {
            /**
             * API version of the referent.
             */
            apiVersion: pulumi.Input<string>;
            /**
             * If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion for how the garbage collector interacts with this field and enforces the foreground deletion. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
             */
            blockOwnerDeletion?: pulumi.Input<boolean>;
            /**
             * If true, this reference points to the managing controller.
             */
            controller?: pulumi.Input<boolean>;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
             */
            name: pulumi.Input<string>;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
             */
            uid: pulumi.Input<string>;
        }

        /**
         * OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.
         */
        export interface OwnerReferencePatch {
            /**
             * API version of the referent.
             */
            apiVersion?: pulumi.Input<string>;
            /**
             * If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion for how the garbage collector interacts with this field and enforces the foreground deletion. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
             */
            blockOwnerDeletion?: pulumi.Input<boolean>;
            /**
             * If true, this reference points to the managing controller.
             */
            controller?: pulumi.Input<boolean>;
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind?: pulumi.Input<string>;
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
             */
            name?: pulumi.Input<string>;
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
             */
            uid?: pulumi.Input<string>;
        }

    }
}
