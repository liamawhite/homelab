// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from '@pulumi/pulumi'
import * as inputs from '../types/input'
import * as outputs from '../types/output'

export namespace longhorn {
    export namespace v1beta1 {
        /**
         * BackingImage is where Longhorn stores backing image object.
         */
        export interface BackingImage {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta1'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'BackingImage'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: { [key: string]: any }
            status: { [key: string]: any }
        }

        /**
         * BackingImageDataSource is where Longhorn stores backing image data source object.
         */
        export interface BackingImageDataSource {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta1'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'BackingImageDataSource'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: { [key: string]: any }
            status: { [key: string]: any }
        }

        /**
         * BackingImageManager is where Longhorn stores backing image manager object.
         */
        export interface BackingImageManager {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta1'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'BackingImageManager'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: { [key: string]: any }
            status: { [key: string]: any }
        }

        /**
         * Backup is where Longhorn stores backup object.
         */
        export interface Backup {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta1'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'Backup'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: { [key: string]: any }
            status: { [key: string]: any }
        }

        /**
         * BackupTarget is where Longhorn stores backup target object.
         */
        export interface BackupTarget {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta1'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'BackupTarget'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: { [key: string]: any }
            status: { [key: string]: any }
        }

        /**
         * BackupVolume is where Longhorn stores backup volume object.
         */
        export interface BackupVolume {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta1'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'BackupVolume'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: { [key: string]: any }
            status: { [key: string]: any }
        }

        /**
         * Engine is where Longhorn stores engine object.
         */
        export interface Engine {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta1'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'Engine'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: { [key: string]: any }
            status: { [key: string]: any }
        }

        /**
         * EngineImage is where Longhorn stores engine image object.
         */
        export interface EngineImage {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta1'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'EngineImage'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: { [key: string]: any }
            status: { [key: string]: any }
        }

        /**
         * InstanceManager is where Longhorn stores instance manager object.
         */
        export interface InstanceManager {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta1'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'InstanceManager'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: { [key: string]: any }
            status: { [key: string]: any }
        }

        /**
         * Node is where Longhorn stores Longhorn node object.
         */
        export interface Node {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta1'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'Node'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: { [key: string]: any }
            status: { [key: string]: any }
        }

        /**
         * RecurringJob is where Longhorn stores recurring job object.
         */
        export interface RecurringJob {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta1'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'RecurringJob'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: { [key: string]: any }
            status: { [key: string]: any }
        }

        /**
         * Replica is where Longhorn stores replica object.
         */
        export interface Replica {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta1'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'Replica'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: { [key: string]: any }
            status: { [key: string]: any }
        }

        /**
         * Setting is where Longhorn stores setting object.
         */
        export interface Setting {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta1'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'Setting'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            value: string
        }

        /**
         * ShareManager is where Longhorn stores share manager object.
         */
        export interface ShareManager {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta1'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'ShareManager'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: { [key: string]: any }
            status: { [key: string]: any }
        }

        /**
         * Volume is where Longhorn stores volume object.
         */
        export interface Volume {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta1'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'Volume'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: { [key: string]: any }
            status: { [key: string]: any }
        }
    }

    export namespace v1beta2 {
        /**
         * BackingImage is where Longhorn stores backing image object.
         */
        export interface BackingImage {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta2'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'BackingImage'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: outputs.longhorn.v1beta2.BackingImageSpec
            status: outputs.longhorn.v1beta2.BackingImageStatus
        }

        /**
         * BackingImageDataSource is where Longhorn stores backing image data source object.
         */
        export interface BackingImageDataSource {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta2'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'BackingImageDataSource'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: outputs.longhorn.v1beta2.BackingImageDataSourceSpec
            status: outputs.longhorn.v1beta2.BackingImageDataSourceStatus
        }

        /**
         * BackingImageDataSourceSpec defines the desired state of the Longhorn backing image data source
         */
        export interface BackingImageDataSourceSpec {
            checksum: string
            diskPath: string
            diskUUID: string
            fileTransferred: boolean
            nodeID: string
            parameters: { [key: string]: string }
            sourceType: string
            uuid: string
        }

        /**
         * BackingImageDataSourceSpec defines the desired state of the Longhorn backing image data source
         */
        export interface BackingImageDataSourceSpecPatch {
            checksum: string
            diskPath: string
            diskUUID: string
            fileTransferred: boolean
            nodeID: string
            parameters: { [key: string]: string }
            sourceType: string
            uuid: string
        }

        /**
         * BackingImageDataSourceStatus defines the observed state of the Longhorn backing image data source
         */
        export interface BackingImageDataSourceStatus {
            checksum: string
            currentState: string
            ip: string
            message: string
            ownerID: string
            progress: number
            runningParameters: { [key: string]: string }
            size: number
            storageIP: string
        }

        /**
         * BackingImageDataSourceStatus defines the observed state of the Longhorn backing image data source
         */
        export interface BackingImageDataSourceStatusPatch {
            checksum: string
            currentState: string
            ip: string
            message: string
            ownerID: string
            progress: number
            runningParameters: { [key: string]: string }
            size: number
            storageIP: string
        }

        /**
         * BackingImageManager is where Longhorn stores backing image manager object.
         */
        export interface BackingImageManager {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta2'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'BackingImageManager'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: outputs.longhorn.v1beta2.BackingImageManagerSpec
            status: outputs.longhorn.v1beta2.BackingImageManagerStatus
        }

        /**
         * BackingImageManagerSpec defines the desired state of the Longhorn backing image manager
         */
        export interface BackingImageManagerSpec {
            backingImages: { [key: string]: string }
            diskPath: string
            diskUUID: string
            image: string
            nodeID: string
        }

        /**
         * BackingImageManagerSpec defines the desired state of the Longhorn backing image manager
         */
        export interface BackingImageManagerSpecPatch {
            backingImages: { [key: string]: string }
            diskPath: string
            diskUUID: string
            image: string
            nodeID: string
        }

        /**
         * BackingImageManagerStatus defines the observed state of the Longhorn backing image manager
         */
        export interface BackingImageManagerStatus {
            apiMinVersion: number
            apiVersion: number
            backingImageFileMap: { [key: string]: { [key: string]: string } }
            currentState: string
            ip: string
            ownerID: string
            storageIP: string
        }

        /**
         * BackingImageManagerStatus defines the observed state of the Longhorn backing image manager
         */
        export interface BackingImageManagerStatusPatch {
            apiMinVersion: number
            apiVersion: number
            backingImageFileMap: { [key: string]: { [key: string]: string } }
            currentState: string
            ip: string
            ownerID: string
            storageIP: string
        }

        /**
         * BackingImageSpec defines the desired state of the Longhorn backing image
         */
        export interface BackingImageSpec {
            checksum: string
            dataEngine: string
            diskFileSpecMap: { [key: string]: { [key: string]: string } }
            diskSelector: string[]
            /**
             * Deprecated. We are now using DiskFileSpecMap to assign different spec to the file on different disks.
             */
            disks: { [key: string]: string }
            minNumberOfCopies: number
            nodeSelector: string[]
            secret: string
            secretNamespace: string
            sourceParameters: { [key: string]: string }
            sourceType: string
        }

        /**
         * BackingImageSpec defines the desired state of the Longhorn backing image
         */
        export interface BackingImageSpecPatch {
            checksum: string
            dataEngine: string
            diskFileSpecMap: { [key: string]: { [key: string]: string } }
            diskSelector: string[]
            /**
             * Deprecated. We are now using DiskFileSpecMap to assign different spec to the file on different disks.
             */
            disks: { [key: string]: string }
            minNumberOfCopies: number
            nodeSelector: string[]
            secret: string
            secretNamespace: string
            sourceParameters: { [key: string]: string }
            sourceType: string
        }

        /**
         * BackingImageStatus defines the observed state of the Longhorn backing image status
         */
        export interface BackingImageStatus {
            checksum: string
            diskFileStatusMap: { [key: string]: { [key: string]: string } }
            diskLastRefAtMap: { [key: string]: string }
            ownerID: string
            /**
             * Real size of image in bytes, which may be smaller than the size when the file is a sparse file. Will be zero until known (e.g. while a backing image is uploading)
             */
            realSize: number
            size: number
            uuid: string
            v2FirstCopyDisk: string
            /**
             * It is pending -> in-progress -> ready/failed
             */
            v2FirstCopyStatus: string
            /**
             * Virtual size of image in bytes, which may be larger than physical size. Will be zero until known (e.g. while a backing image is uploading)
             */
            virtualSize: number
        }

        /**
         * BackingImageStatus defines the observed state of the Longhorn backing image status
         */
        export interface BackingImageStatusPatch {
            checksum: string
            diskFileStatusMap: { [key: string]: { [key: string]: string } }
            diskLastRefAtMap: { [key: string]: string }
            ownerID: string
            /**
             * Real size of image in bytes, which may be smaller than the size when the file is a sparse file. Will be zero until known (e.g. while a backing image is uploading)
             */
            realSize: number
            size: number
            uuid: string
            v2FirstCopyDisk: string
            /**
             * It is pending -> in-progress -> ready/failed
             */
            v2FirstCopyStatus: string
            /**
             * Virtual size of image in bytes, which may be larger than physical size. Will be zero until known (e.g. while a backing image is uploading)
             */
            virtualSize: number
        }

        /**
         * Backup is where Longhorn stores backup object.
         */
        export interface Backup {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta2'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'Backup'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: outputs.longhorn.v1beta2.BackupSpec
            status: outputs.longhorn.v1beta2.BackupStatus
        }

        /**
         * BackupBackingImage is where Longhorn stores backing image backup object.
         */
        export interface BackupBackingImage {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta2'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'BackupBackingImage'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: outputs.longhorn.v1beta2.BackupBackingImageSpec
            status: outputs.longhorn.v1beta2.BackupBackingImageStatus
        }

        /**
         * BackupBackingImageSpec defines the desired state of the Longhorn backing image backup
         */
        export interface BackupBackingImageSpec {
            /**
             * The backing image name.
             */
            backingImage: string
            /**
             * The backup target name.
             */
            backupTargetName: string
            /**
             * The labels of backing image backup.
             */
            labels: { [key: string]: string }
            /**
             * The time to request run sync the remote backing image backup.
             */
            syncRequestedAt: string
            /**
             * Is this CR created by user through API or UI.
             */
            userCreated: boolean
        }

        /**
         * BackupBackingImageSpec defines the desired state of the Longhorn backing image backup
         */
        export interface BackupBackingImageSpecPatch {
            /**
             * The backing image name.
             */
            backingImage: string
            /**
             * The backup target name.
             */
            backupTargetName: string
            /**
             * The labels of backing image backup.
             */
            labels: { [key: string]: string }
            /**
             * The time to request run sync the remote backing image backup.
             */
            syncRequestedAt: string
            /**
             * Is this CR created by user through API or UI.
             */
            userCreated: boolean
        }

        /**
         * BackupBackingImageStatus defines the observed state of the Longhorn backing image backup
         */
        export interface BackupBackingImageStatus {
            /**
             * The backing image name.
             */
            backingImage: string
            /**
             * The backing image backup upload finished time.
             */
            backupCreatedAt: string
            /**
             * The checksum of the backing image.
             */
            checksum: string
            /**
             * Compression method
             */
            compressionMethod: string
            /**
             * The error message when taking the backing image backup.
             */
            error: string
            /**
             * The labels of backing image backup.
             */
            labels: { [key: string]: string }
            /**
             * The last time that the backing image backup was synced with the remote backup target.
             */
            lastSyncedAt: string
            /**
             * The address of the backing image manager that runs backing image backup.
             */
            managerAddress: string
            /**
             * The error messages when listing or inspecting backing image backup.
             */
            messages: { [key: string]: string }
            /**
             * The node ID on which the controller is responsible to reconcile this CR.
             */
            ownerID: string
            /**
             * The backing image backup progress.
             */
            progress: number
            /**
             * Record the secret if this backup backing image is encrypted
             */
            secret: string
            /**
             * Record the secret namespace if this backup backing image is encrypted
             */
            secretNamespace: string
            /**
             * The backing image size.
             */
            size: number
            /**
             * The backing image backup creation state.
             * Can be "", "InProgress", "Completed", "Error", "Unknown".
             */
            state: string
            /**
             * The backing image backup URL.
             */
            url: string
        }

        /**
         * BackupBackingImageStatus defines the observed state of the Longhorn backing image backup
         */
        export interface BackupBackingImageStatusPatch {
            /**
             * The backing image name.
             */
            backingImage: string
            /**
             * The backing image backup upload finished time.
             */
            backupCreatedAt: string
            /**
             * The checksum of the backing image.
             */
            checksum: string
            /**
             * Compression method
             */
            compressionMethod: string
            /**
             * The error message when taking the backing image backup.
             */
            error: string
            /**
             * The labels of backing image backup.
             */
            labels: { [key: string]: string }
            /**
             * The last time that the backing image backup was synced with the remote backup target.
             */
            lastSyncedAt: string
            /**
             * The address of the backing image manager that runs backing image backup.
             */
            managerAddress: string
            /**
             * The error messages when listing or inspecting backing image backup.
             */
            messages: { [key: string]: string }
            /**
             * The node ID on which the controller is responsible to reconcile this CR.
             */
            ownerID: string
            /**
             * The backing image backup progress.
             */
            progress: number
            /**
             * Record the secret if this backup backing image is encrypted
             */
            secret: string
            /**
             * Record the secret namespace if this backup backing image is encrypted
             */
            secretNamespace: string
            /**
             * The backing image size.
             */
            size: number
            /**
             * The backing image backup creation state.
             * Can be "", "InProgress", "Completed", "Error", "Unknown".
             */
            state: string
            /**
             * The backing image backup URL.
             */
            url: string
        }

        /**
         * BackupSpec defines the desired state of the Longhorn backup
         */
        export interface BackupSpec {
            /**
             * The backup mode of this backup.
             * Can be "full" or "incremental"
             */
            backupMode: string
            /**
             * The labels of snapshot backup.
             */
            labels: { [key: string]: string }
            /**
             * The snapshot name.
             */
            snapshotName: string
            /**
             * The time to request run sync the remote backup.
             */
            syncRequestedAt: string
        }

        /**
         * BackupSpec defines the desired state of the Longhorn backup
         */
        export interface BackupSpecPatch {
            /**
             * The backup mode of this backup.
             * Can be "full" or "incremental"
             */
            backupMode: string
            /**
             * The labels of snapshot backup.
             */
            labels: { [key: string]: string }
            /**
             * The snapshot name.
             */
            snapshotName: string
            /**
             * The time to request run sync the remote backup.
             */
            syncRequestedAt: string
        }

        /**
         * BackupStatus defines the observed state of the Longhorn backup
         */
        export interface BackupStatus {
            /**
             * The snapshot backup upload finished time.
             */
            backupCreatedAt: string
            /**
             * The backup target name.
             */
            backupTargetName: string
            /**
             * Compression method
             */
            compressionMethod: string
            /**
             * The error message when taking the snapshot backup.
             */
            error: string
            /**
             * The labels of snapshot backup.
             */
            labels: { [key: string]: string }
            /**
             * The last time that the backup was synced with the remote backup target.
             */
            lastSyncedAt: string
            /**
             * The error messages when calling longhorn engine on listing or inspecting backups.
             */
            messages: { [key: string]: string }
            /**
             * Size in bytes of newly uploaded data
             */
            newlyUploadDataSize: string
            /**
             * The node ID on which the controller is responsible to reconcile this backup CR.
             */
            ownerID: string
            /**
             * The snapshot backup progress.
             */
            progress: number
            /**
             * Size in bytes of reuploaded data
             */
            reUploadedDataSize: string
            /**
             * The address of the replica that runs snapshot backup.
             */
            replicaAddress: string
            /**
             * The snapshot size.
             */
            size: string
            /**
             * The snapshot creation time.
             */
            snapshotCreatedAt: string
            /**
             * The snapshot name.
             */
            snapshotName: string
            /**
             * The backup creation state.
             * Can be "", "InProgress", "Completed", "Error", "Unknown".
             */
            state: string
            /**
             * The snapshot backup URL.
             */
            url: string
            /**
             * The volume's backing image name.
             */
            volumeBackingImageName: string
            /**
             * The volume creation time.
             */
            volumeCreated: string
            /**
             * The volume name.
             */
            volumeName: string
            /**
             * The volume size.
             */
            volumeSize: string
        }

        /**
         * BackupStatus defines the observed state of the Longhorn backup
         */
        export interface BackupStatusPatch {
            /**
             * The snapshot backup upload finished time.
             */
            backupCreatedAt: string
            /**
             * The backup target name.
             */
            backupTargetName: string
            /**
             * Compression method
             */
            compressionMethod: string
            /**
             * The error message when taking the snapshot backup.
             */
            error: string
            /**
             * The labels of snapshot backup.
             */
            labels: { [key: string]: string }
            /**
             * The last time that the backup was synced with the remote backup target.
             */
            lastSyncedAt: string
            /**
             * The error messages when calling longhorn engine on listing or inspecting backups.
             */
            messages: { [key: string]: string }
            /**
             * Size in bytes of newly uploaded data
             */
            newlyUploadDataSize: string
            /**
             * The node ID on which the controller is responsible to reconcile this backup CR.
             */
            ownerID: string
            /**
             * The snapshot backup progress.
             */
            progress: number
            /**
             * Size in bytes of reuploaded data
             */
            reUploadedDataSize: string
            /**
             * The address of the replica that runs snapshot backup.
             */
            replicaAddress: string
            /**
             * The snapshot size.
             */
            size: string
            /**
             * The snapshot creation time.
             */
            snapshotCreatedAt: string
            /**
             * The snapshot name.
             */
            snapshotName: string
            /**
             * The backup creation state.
             * Can be "", "InProgress", "Completed", "Error", "Unknown".
             */
            state: string
            /**
             * The snapshot backup URL.
             */
            url: string
            /**
             * The volume's backing image name.
             */
            volumeBackingImageName: string
            /**
             * The volume creation time.
             */
            volumeCreated: string
            /**
             * The volume name.
             */
            volumeName: string
            /**
             * The volume size.
             */
            volumeSize: string
        }

        /**
         * BackupTarget is where Longhorn stores backup target object.
         */
        export interface BackupTarget {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta2'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'BackupTarget'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: outputs.longhorn.v1beta2.BackupTargetSpec
            status: outputs.longhorn.v1beta2.BackupTargetStatus
        }

        /**
         * BackupTargetSpec defines the desired state of the Longhorn backup target
         */
        export interface BackupTargetSpec {
            /**
             * The backup target URL.
             */
            backupTargetURL: string
            /**
             * The backup target credential secret.
             */
            credentialSecret: string
            /**
             * The interval that the cluster needs to run sync with the backup target.
             */
            pollInterval: string
            /**
             * The time to request run sync the remote backup target.
             */
            syncRequestedAt: string
        }

        /**
         * BackupTargetSpec defines the desired state of the Longhorn backup target
         */
        export interface BackupTargetSpecPatch {
            /**
             * The backup target URL.
             */
            backupTargetURL: string
            /**
             * The backup target credential secret.
             */
            credentialSecret: string
            /**
             * The interval that the cluster needs to run sync with the backup target.
             */
            pollInterval: string
            /**
             * The time to request run sync the remote backup target.
             */
            syncRequestedAt: string
        }

        /**
         * BackupTargetStatus defines the observed state of the Longhorn backup target
         */
        export interface BackupTargetStatus {
            /**
             * Available indicates if the remote backup target is available or not.
             */
            available: boolean
            /**
             * Records the reason on why the backup target is unavailable.
             */
            conditions: outputs.longhorn.v1beta2.BackupTargetStatusConditions[]
            /**
             * The last time that the controller synced with the remote backup target.
             */
            lastSyncedAt: string
            /**
             * The node ID on which the controller is responsible to reconcile this backup target CR.
             */
            ownerID: string
        }

        export interface BackupTargetStatusConditions {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime: string
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime: string
            /**
             * Human-readable message indicating details about last transition.
             */
            message: string
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason: string
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status: string
            /**
             * Type is the type of the condition.
             */
            type: string
        }

        export interface BackupTargetStatusConditionsPatch {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime: string
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime: string
            /**
             * Human-readable message indicating details about last transition.
             */
            message: string
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason: string
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status: string
            /**
             * Type is the type of the condition.
             */
            type: string
        }

        /**
         * BackupTargetStatus defines the observed state of the Longhorn backup target
         */
        export interface BackupTargetStatusPatch {
            /**
             * Available indicates if the remote backup target is available or not.
             */
            available: boolean
            /**
             * Records the reason on why the backup target is unavailable.
             */
            conditions: outputs.longhorn.v1beta2.BackupTargetStatusConditionsPatch[]
            /**
             * The last time that the controller synced with the remote backup target.
             */
            lastSyncedAt: string
            /**
             * The node ID on which the controller is responsible to reconcile this backup target CR.
             */
            ownerID: string
        }

        /**
         * BackupVolume is where Longhorn stores backup volume object.
         */
        export interface BackupVolume {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta2'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'BackupVolume'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: outputs.longhorn.v1beta2.BackupVolumeSpec
            status: outputs.longhorn.v1beta2.BackupVolumeStatus
        }

        /**
         * BackupVolumeSpec defines the desired state of the Longhorn backup volume
         */
        export interface BackupVolumeSpec {
            /**
             * The backup target name that the backup volume was synced.
             */
            backupTargetName: string
            /**
             * The time to request run sync the remote backup volume.
             */
            syncRequestedAt: string
            /**
             * The volume name that the backup volume was used to backup.
             */
            volumeName: string
        }

        /**
         * BackupVolumeSpec defines the desired state of the Longhorn backup volume
         */
        export interface BackupVolumeSpecPatch {
            /**
             * The backup target name that the backup volume was synced.
             */
            backupTargetName: string
            /**
             * The time to request run sync the remote backup volume.
             */
            syncRequestedAt: string
            /**
             * The volume name that the backup volume was used to backup.
             */
            volumeName: string
        }

        /**
         * BackupVolumeStatus defines the observed state of the Longhorn backup volume
         */
        export interface BackupVolumeStatus {
            /**
             * the backing image checksum.
             */
            backingImageChecksum: string
            /**
             * The backing image name.
             */
            backingImageName: string
            /**
             * The backup volume creation time.
             */
            createdAt: string
            /**
             * The backup volume block count.
             */
            dataStored: string
            /**
             * The backup volume labels.
             */
            labels: { [key: string]: string }
            /**
             * The latest volume backup time.
             */
            lastBackupAt: string
            /**
             * The latest volume backup name.
             */
            lastBackupName: string
            /**
             * The backup volume config last modification time.
             */
            lastModificationTime: string
            /**
             * The last time that the backup volume was synced into the cluster.
             */
            lastSyncedAt: string
            /**
             * The error messages when call longhorn engine on list or inspect backup volumes.
             */
            messages: { [key: string]: string }
            /**
             * The node ID on which the controller is responsible to reconcile this backup volume CR.
             */
            ownerID: string
            /**
             * The backup volume size.
             */
            size: string
            /**
             * the storage class name of pv/pvc binding with the volume.
             */
            storageClassName: string
        }

        /**
         * BackupVolumeStatus defines the observed state of the Longhorn backup volume
         */
        export interface BackupVolumeStatusPatch {
            /**
             * the backing image checksum.
             */
            backingImageChecksum: string
            /**
             * The backing image name.
             */
            backingImageName: string
            /**
             * The backup volume creation time.
             */
            createdAt: string
            /**
             * The backup volume block count.
             */
            dataStored: string
            /**
             * The backup volume labels.
             */
            labels: { [key: string]: string }
            /**
             * The latest volume backup time.
             */
            lastBackupAt: string
            /**
             * The latest volume backup name.
             */
            lastBackupName: string
            /**
             * The backup volume config last modification time.
             */
            lastModificationTime: string
            /**
             * The last time that the backup volume was synced into the cluster.
             */
            lastSyncedAt: string
            /**
             * The error messages when call longhorn engine on list or inspect backup volumes.
             */
            messages: { [key: string]: string }
            /**
             * The node ID on which the controller is responsible to reconcile this backup volume CR.
             */
            ownerID: string
            /**
             * The backup volume size.
             */
            size: string
            /**
             * the storage class name of pv/pvc binding with the volume.
             */
            storageClassName: string
        }

        /**
         * Engine is where Longhorn stores engine object.
         */
        export interface Engine {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta2'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'Engine'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: outputs.longhorn.v1beta2.EngineSpec
            status: outputs.longhorn.v1beta2.EngineStatus
        }

        /**
         * EngineImage is where Longhorn stores engine image object.
         */
        export interface EngineImage {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta2'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'EngineImage'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: outputs.longhorn.v1beta2.EngineImageSpec
            status: outputs.longhorn.v1beta2.EngineImageStatus
        }

        /**
         * EngineImageSpec defines the desired state of the Longhorn engine image
         */
        export interface EngineImageSpec {
            image: string
        }

        /**
         * EngineImageSpec defines the desired state of the Longhorn engine image
         */
        export interface EngineImageSpecPatch {
            image: string
        }

        /**
         * EngineImageStatus defines the observed state of the Longhorn engine image
         */
        export interface EngineImageStatus {
            buildDate: string
            cliAPIMinVersion: number
            cliAPIVersion: number
            conditions: outputs.longhorn.v1beta2.EngineImageStatusConditions[]
            controllerAPIMinVersion: number
            controllerAPIVersion: number
            dataFormatMinVersion: number
            dataFormatVersion: number
            gitCommit: string
            incompatible: boolean
            noRefSince: string
            nodeDeploymentMap: { [key: string]: boolean }
            ownerID: string
            refCount: number
            state: string
            version: string
        }

        export interface EngineImageStatusConditions {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime: string
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime: string
            /**
             * Human-readable message indicating details about last transition.
             */
            message: string
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason: string
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status: string
            /**
             * Type is the type of the condition.
             */
            type: string
        }

        export interface EngineImageStatusConditionsPatch {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime: string
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime: string
            /**
             * Human-readable message indicating details about last transition.
             */
            message: string
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason: string
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status: string
            /**
             * Type is the type of the condition.
             */
            type: string
        }

        /**
         * EngineImageStatus defines the observed state of the Longhorn engine image
         */
        export interface EngineImageStatusPatch {
            buildDate: string
            cliAPIMinVersion: number
            cliAPIVersion: number
            conditions: outputs.longhorn.v1beta2.EngineImageStatusConditionsPatch[]
            controllerAPIMinVersion: number
            controllerAPIVersion: number
            dataFormatMinVersion: number
            dataFormatVersion: number
            gitCommit: string
            incompatible: boolean
            noRefSince: string
            nodeDeploymentMap: { [key: string]: boolean }
            ownerID: string
            refCount: number
            state: string
            version: string
        }

        /**
         * EngineSpec defines the desired state of the Longhorn engine
         */
        export interface EngineSpec {
            active: boolean
            backupVolume: string
            dataEngine: string
            desireState: string
            disableFrontend: boolean
            frontend: string
            image: string
            logRequested: boolean
            nodeID: string
            replicaAddressMap: { [key: string]: string }
            requestedBackupRestore: string
            requestedDataSource: string
            revisionCounterDisabled: boolean
            salvageRequested: boolean
            snapshotMaxCount: number
            snapshotMaxSize: string
            unmapMarkSnapChainRemovedEnabled: boolean
            upgradedReplicaAddressMap: { [key: string]: string }
            volumeName: string
            volumeSize: string
        }

        /**
         * EngineSpec defines the desired state of the Longhorn engine
         */
        export interface EngineSpecPatch {
            active: boolean
            backupVolume: string
            dataEngine: string
            desireState: string
            disableFrontend: boolean
            frontend: string
            image: string
            logRequested: boolean
            nodeID: string
            replicaAddressMap: { [key: string]: string }
            requestedBackupRestore: string
            requestedDataSource: string
            revisionCounterDisabled: boolean
            salvageRequested: boolean
            snapshotMaxCount: number
            snapshotMaxSize: string
            unmapMarkSnapChainRemovedEnabled: boolean
            upgradedReplicaAddressMap: { [key: string]: string }
            volumeName: string
            volumeSize: string
        }

        /**
         * EngineStatus defines the observed state of the Longhorn engine
         */
        export interface EngineStatus {
            backupStatus: { [key: string]: { [key: string]: string } }
            cloneStatus: { [key: string]: { [key: string]: string } }
            conditions: outputs.longhorn.v1beta2.EngineStatusConditions[]
            currentImage: string
            currentReplicaAddressMap: { [key: string]: string }
            currentSize: string
            currentState: string
            endpoint: string
            instanceManagerName: string
            ip: string
            isExpanding: boolean
            lastExpansionError: string
            lastExpansionFailedAt: string
            lastRestoredBackup: string
            logFetched: boolean
            ownerID: string
            port: number
            purgeStatus: { [key: string]: { [key: string]: string } }
            rebuildStatus: { [key: string]: { [key: string]: string } }
            replicaModeMap: { [key: string]: string }
            /**
             * ReplicaTransitionTimeMap records the time a replica in ReplicaModeMap transitions from one mode to another (or
             * from not being in the ReplicaModeMap to being in it). This information is sometimes required by other controllers
             * (e.g. the volume controller uses it to determine the correct value for replica.Spec.lastHealthyAt).
             */
            replicaTransitionTimeMap: { [key: string]: string }
            restoreStatus: { [key: string]: { [key: string]: string } }
            salvageExecuted: boolean
            snapshotMaxCount: number
            snapshotMaxSize: string
            snapshots: { [key: string]: { [key: string]: string } }
            snapshotsError: string
            started: boolean
            storageIP: string
            ublkID: number
            unmapMarkSnapChainRemovedEnabled: boolean
            uuid: string
        }

        export interface EngineStatusConditions {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime: string
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime: string
            /**
             * Human-readable message indicating details about last transition.
             */
            message: string
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason: string
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status: string
            /**
             * Type is the type of the condition.
             */
            type: string
        }

        export interface EngineStatusConditionsPatch {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime: string
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime: string
            /**
             * Human-readable message indicating details about last transition.
             */
            message: string
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason: string
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status: string
            /**
             * Type is the type of the condition.
             */
            type: string
        }

        /**
         * EngineStatus defines the observed state of the Longhorn engine
         */
        export interface EngineStatusPatch {
            backupStatus: { [key: string]: { [key: string]: string } }
            cloneStatus: { [key: string]: { [key: string]: string } }
            conditions: outputs.longhorn.v1beta2.EngineStatusConditionsPatch[]
            currentImage: string
            currentReplicaAddressMap: { [key: string]: string }
            currentSize: string
            currentState: string
            endpoint: string
            instanceManagerName: string
            ip: string
            isExpanding: boolean
            lastExpansionError: string
            lastExpansionFailedAt: string
            lastRestoredBackup: string
            logFetched: boolean
            ownerID: string
            port: number
            purgeStatus: { [key: string]: { [key: string]: string } }
            rebuildStatus: { [key: string]: { [key: string]: string } }
            replicaModeMap: { [key: string]: string }
            /**
             * ReplicaTransitionTimeMap records the time a replica in ReplicaModeMap transitions from one mode to another (or
             * from not being in the ReplicaModeMap to being in it). This information is sometimes required by other controllers
             * (e.g. the volume controller uses it to determine the correct value for replica.Spec.lastHealthyAt).
             */
            replicaTransitionTimeMap: { [key: string]: string }
            restoreStatus: { [key: string]: { [key: string]: string } }
            salvageExecuted: boolean
            snapshotMaxCount: number
            snapshotMaxSize: string
            snapshots: { [key: string]: { [key: string]: string } }
            snapshotsError: string
            started: boolean
            storageIP: string
            ublkID: number
            unmapMarkSnapChainRemovedEnabled: boolean
            uuid: string
        }

        /**
         * InstanceManager is where Longhorn stores instance manager object.
         */
        export interface InstanceManager {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta2'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'InstanceManager'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: outputs.longhorn.v1beta2.InstanceManagerSpec
            status: outputs.longhorn.v1beta2.InstanceManagerStatus
        }

        /**
         * InstanceManagerSpec defines the desired state of the Longhorn instance manager
         */
        export interface InstanceManagerSpec {
            dataEngine: string
            dataEngineSpec: outputs.longhorn.v1beta2.InstanceManagerSpecDataEngineSpec
            image: string
            nodeID: string
            type: string
        }

        export interface InstanceManagerSpecDataEngineSpec {
            v2: outputs.longhorn.v1beta2.InstanceManagerSpecDataEngineSpecV2
        }

        export interface InstanceManagerSpecDataEngineSpecPatch {
            v2: outputs.longhorn.v1beta2.InstanceManagerSpecDataEngineSpecV2Patch
        }

        export interface InstanceManagerSpecDataEngineSpecV2 {
            cpuMask: string
        }

        export interface InstanceManagerSpecDataEngineSpecV2Patch {
            cpuMask: string
        }

        /**
         * InstanceManagerSpec defines the desired state of the Longhorn instance manager
         */
        export interface InstanceManagerSpecPatch {
            dataEngine: string
            dataEngineSpec: outputs.longhorn.v1beta2.InstanceManagerSpecDataEngineSpecPatch
            image: string
            nodeID: string
            type: string
        }

        /**
         * InstanceManagerStatus defines the observed state of the Longhorn instance manager
         */
        export interface InstanceManagerStatus {
            apiMinVersion: number
            apiVersion: number
            backingImages: { [key: string]: { [key: string]: string } }
            currentState: string
            dataEngineStatus: outputs.longhorn.v1beta2.InstanceManagerStatusDataEngineStatus
            instanceEngines: { [key: string]: { [key: string]: string } }
            instanceReplicas: { [key: string]: { [key: string]: string } }
            /**
             * Deprecated: Replaced by InstanceEngines and InstanceReplicas
             */
            instances: { [key: string]: { [key: string]: string } }
            ip: string
            ownerID: string
            proxyApiMinVersion: number
            proxyApiVersion: number
        }

        export interface InstanceManagerStatusDataEngineStatus {
            v2: outputs.longhorn.v1beta2.InstanceManagerStatusDataEngineStatusV2
        }

        export interface InstanceManagerStatusDataEngineStatusPatch {
            v2: outputs.longhorn.v1beta2.InstanceManagerStatusDataEngineStatusV2Patch
        }

        export interface InstanceManagerStatusDataEngineStatusV2 {
            cpuMask: string
        }

        export interface InstanceManagerStatusDataEngineStatusV2Patch {
            cpuMask: string
        }

        /**
         * InstanceManagerStatus defines the observed state of the Longhorn instance manager
         */
        export interface InstanceManagerStatusPatch {
            apiMinVersion: number
            apiVersion: number
            backingImages: { [key: string]: { [key: string]: string } }
            currentState: string
            dataEngineStatus: outputs.longhorn.v1beta2.InstanceManagerStatusDataEngineStatusPatch
            instanceEngines: { [key: string]: { [key: string]: string } }
            instanceReplicas: { [key: string]: { [key: string]: string } }
            /**
             * Deprecated: Replaced by InstanceEngines and InstanceReplicas
             */
            instances: { [key: string]: { [key: string]: string } }
            ip: string
            ownerID: string
            proxyApiMinVersion: number
            proxyApiVersion: number
        }

        /**
         * Node is where Longhorn stores Longhorn node object.
         */
        export interface Node {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta2'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'Node'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: outputs.longhorn.v1beta2.NodeSpec
            status: outputs.longhorn.v1beta2.NodeStatus
        }

        /**
         * NodeSpec defines the desired state of the Longhorn node
         */
        export interface NodeSpec {
            allowScheduling: boolean
            disks: { [key: string]: { [key: string]: string } }
            evictionRequested: boolean
            instanceManagerCPURequest: number
            name: string
            tags: string[]
        }

        /**
         * NodeSpec defines the desired state of the Longhorn node
         */
        export interface NodeSpecPatch {
            allowScheduling: boolean
            disks: { [key: string]: { [key: string]: string } }
            evictionRequested: boolean
            instanceManagerCPURequest: number
            name: string
            tags: string[]
        }

        /**
         * NodeStatus defines the observed state of the Longhorn node
         */
        export interface NodeStatus {
            autoEvicting: boolean
            conditions: outputs.longhorn.v1beta2.NodeStatusConditions[]
            diskStatus: { [key: string]: { [key: string]: string } }
            region: string
            snapshotCheckStatus: outputs.longhorn.v1beta2.NodeStatusSnapshotCheckStatus
            zone: string
        }

        export interface NodeStatusConditions {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime: string
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime: string
            /**
             * Human-readable message indicating details about last transition.
             */
            message: string
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason: string
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status: string
            /**
             * Type is the type of the condition.
             */
            type: string
        }

        export interface NodeStatusConditionsPatch {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime: string
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime: string
            /**
             * Human-readable message indicating details about last transition.
             */
            message: string
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason: string
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status: string
            /**
             * Type is the type of the condition.
             */
            type: string
        }

        /**
         * NodeStatus defines the observed state of the Longhorn node
         */
        export interface NodeStatusPatch {
            autoEvicting: boolean
            conditions: outputs.longhorn.v1beta2.NodeStatusConditionsPatch[]
            diskStatus: { [key: string]: { [key: string]: string } }
            region: string
            snapshotCheckStatus: outputs.longhorn.v1beta2.NodeStatusSnapshotCheckStatusPatch
            zone: string
        }

        export interface NodeStatusSnapshotCheckStatus {
            lastPeriodicCheckedAt: string
        }

        export interface NodeStatusSnapshotCheckStatusPatch {
            lastPeriodicCheckedAt: string
        }

        /**
         * Orphan is where Longhorn stores orphan object.
         */
        export interface Orphan {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta2'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'Orphan'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: outputs.longhorn.v1beta2.OrphanSpec
            status: outputs.longhorn.v1beta2.OrphanStatus
        }

        /**
         * OrphanSpec defines the desired state of the Longhorn orphaned data
         */
        export interface OrphanSpec {
            /**
             * The type of data engine for instance orphan.
             * Can be "v1", "v2".
             */
            dataEngine: string
            /**
             * The node ID on which the controller is responsible to reconcile this orphan CR.
             */
            nodeID: string
            /**
             * The type of the orphaned data.
             * Can be "replica".
             */
            orphanType: string
            /**
             * The parameters of the orphaned data
             */
            parameters: { [key: string]: string }
        }

        /**
         * OrphanSpec defines the desired state of the Longhorn orphaned data
         */
        export interface OrphanSpecPatch {
            /**
             * The type of data engine for instance orphan.
             * Can be "v1", "v2".
             */
            dataEngine: string
            /**
             * The node ID on which the controller is responsible to reconcile this orphan CR.
             */
            nodeID: string
            /**
             * The type of the orphaned data.
             * Can be "replica".
             */
            orphanType: string
            /**
             * The parameters of the orphaned data
             */
            parameters: { [key: string]: string }
        }

        /**
         * OrphanStatus defines the observed state of the Longhorn orphaned data
         */
        export interface OrphanStatus {
            conditions: outputs.longhorn.v1beta2.OrphanStatusConditions[]
            ownerID: string
        }

        export interface OrphanStatusConditions {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime: string
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime: string
            /**
             * Human-readable message indicating details about last transition.
             */
            message: string
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason: string
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status: string
            /**
             * Type is the type of the condition.
             */
            type: string
        }

        export interface OrphanStatusConditionsPatch {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime: string
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime: string
            /**
             * Human-readable message indicating details about last transition.
             */
            message: string
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason: string
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status: string
            /**
             * Type is the type of the condition.
             */
            type: string
        }

        /**
         * OrphanStatus defines the observed state of the Longhorn orphaned data
         */
        export interface OrphanStatusPatch {
            conditions: outputs.longhorn.v1beta2.OrphanStatusConditionsPatch[]
            ownerID: string
        }

        /**
         * RecurringJob is where Longhorn stores recurring job object.
         */
        export interface RecurringJob {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta2'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'RecurringJob'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: outputs.longhorn.v1beta2.RecurringJobSpec
            status: outputs.longhorn.v1beta2.RecurringJobStatus
        }

        /**
         * RecurringJobSpec defines the desired state of the Longhorn recurring job
         */
        export interface RecurringJobSpec {
            /**
             * The concurrency of taking the snapshot/backup.
             */
            concurrency: number
            /**
             * The cron setting.
             */
            cron: string
            /**
             * The recurring job group.
             */
            groups: string[]
            /**
             * The label of the snapshot/backup.
             */
            labels: { [key: string]: string }
            /**
             * The recurring job name.
             */
            name: string
            /**
             * The parameters of the snapshot/backup.
             * Support parameters: "full-backup-interval", "volume-backup-policy".
             */
            parameters: { [key: string]: string }
            /**
             * The retain count of the snapshot/backup.
             */
            retain: number
            /**
             * The recurring job task.
             * Can be "snapshot", "snapshot-force-create", "snapshot-cleanup", "snapshot-delete", "backup", "backup-force-create", "filesystem-trim" or "system-backup".
             */
            task: string
        }

        /**
         * RecurringJobSpec defines the desired state of the Longhorn recurring job
         */
        export interface RecurringJobSpecPatch {
            /**
             * The concurrency of taking the snapshot/backup.
             */
            concurrency: number
            /**
             * The cron setting.
             */
            cron: string
            /**
             * The recurring job group.
             */
            groups: string[]
            /**
             * The label of the snapshot/backup.
             */
            labels: { [key: string]: string }
            /**
             * The recurring job name.
             */
            name: string
            /**
             * The parameters of the snapshot/backup.
             * Support parameters: "full-backup-interval", "volume-backup-policy".
             */
            parameters: { [key: string]: string }
            /**
             * The retain count of the snapshot/backup.
             */
            retain: number
            /**
             * The recurring job task.
             * Can be "snapshot", "snapshot-force-create", "snapshot-cleanup", "snapshot-delete", "backup", "backup-force-create", "filesystem-trim" or "system-backup".
             */
            task: string
        }

        /**
         * RecurringJobStatus defines the observed state of the Longhorn recurring job
         */
        export interface RecurringJobStatus {
            /**
             * The number of jobs that have been triggered.
             */
            executionCount: number
            /**
             * The owner ID which is responsible to reconcile this recurring job CR.
             */
            ownerID: string
        }

        /**
         * RecurringJobStatus defines the observed state of the Longhorn recurring job
         */
        export interface RecurringJobStatusPatch {
            /**
             * The number of jobs that have been triggered.
             */
            executionCount: number
            /**
             * The owner ID which is responsible to reconcile this recurring job CR.
             */
            ownerID: string
        }

        /**
         * Replica is where Longhorn stores replica object.
         */
        export interface Replica {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta2'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'Replica'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: outputs.longhorn.v1beta2.ReplicaSpec
            status: outputs.longhorn.v1beta2.ReplicaStatus
        }

        /**
         * ReplicaSpec defines the desired state of the Longhorn replica
         */
        export interface ReplicaSpec {
            active: boolean
            backingImage: string
            dataDirectoryName: string
            dataEngine: string
            desireState: string
            diskID: string
            diskPath: string
            engineName: string
            evictionRequested: boolean
            /**
             * FailedAt is set when a running replica fails or when a running engine is unable to use a replica for any reason.
             * FailedAt indicates the time the failure occurred. When FailedAt is set, a replica is likely to have useful
             * (though possibly stale) data. A replica with FailedAt set must be rebuilt from a non-failed replica (or it can
             * be used in a salvage if all replicas are failed). FailedAt is cleared before a rebuild or salvage. FailedAt may
             * be later than the corresponding entry in an engine's replicaTransitionTimeMap because it is set when the volume
             * controller acknowledges the change.
             */
            failedAt: string
            hardNodeAffinity: string
            /**
             * HealthyAt is set the first time a replica becomes read/write in an engine after creation or rebuild. HealthyAt
             * indicates the time the last successful rebuild occurred. When HealthyAt is set, a replica is likely to have
             * useful (though possibly stale) data. HealthyAt is cleared before a rebuild. HealthyAt may be later than the
             * corresponding entry in an engine's replicaTransitionTimeMap because it is set when the volume controller
             * acknowledges the change.
             */
            healthyAt: string
            image: string
            /**
             * LastFailedAt is always set at the same time as FailedAt. Unlike FailedAt, LastFailedAt is never cleared.
             * LastFailedAt is not a reliable indicator of the state of a replica's data. For example, a replica with
             * LastFailedAt may already be healthy and in use again. However, because it is never cleared, it can be compared to
             * LastHealthyAt to help prevent dangerous replica deletion in some corner cases. LastFailedAt may be later than the
             * corresponding entry in an engine's replicaTransitionTimeMap because it is set when the volume controller
             * acknowledges the change.
             */
            lastFailedAt: string
            /**
             * LastHealthyAt is set every time a replica becomes read/write in an engine. Unlike HealthyAt, LastHealthyAt is
             * never cleared. LastHealthyAt is not a reliable indicator of the state of a replica's data. For example, a
             * replica with LastHealthyAt set may be in the middle of a rebuild. However, because it is never cleared, it can be
             * compared to LastFailedAt to help prevent dangerous replica deletion in some corner cases. LastHealthyAt may be
             * later than the corresponding entry in an engine's replicaTransitionTimeMap because it is set when the volume
             * controller acknowledges the change.
             */
            lastHealthyAt: string
            logRequested: boolean
            /**
             * MigrationEngineName is indicating the migrating engine which current connected to this replica. This is only
             * used for live migration of v2 data engine
             */
            migrationEngineName: string
            nodeID: string
            rebuildRetryCount: number
            revisionCounterDisabled: boolean
            salvageRequested: boolean
            snapshotMaxCount: number
            snapshotMaxSize: string
            unmapMarkDiskChainRemovedEnabled: boolean
            volumeName: string
            volumeSize: string
        }

        /**
         * ReplicaSpec defines the desired state of the Longhorn replica
         */
        export interface ReplicaSpecPatch {
            active: boolean
            backingImage: string
            dataDirectoryName: string
            dataEngine: string
            desireState: string
            diskID: string
            diskPath: string
            engineName: string
            evictionRequested: boolean
            /**
             * FailedAt is set when a running replica fails or when a running engine is unable to use a replica for any reason.
             * FailedAt indicates the time the failure occurred. When FailedAt is set, a replica is likely to have useful
             * (though possibly stale) data. A replica with FailedAt set must be rebuilt from a non-failed replica (or it can
             * be used in a salvage if all replicas are failed). FailedAt is cleared before a rebuild or salvage. FailedAt may
             * be later than the corresponding entry in an engine's replicaTransitionTimeMap because it is set when the volume
             * controller acknowledges the change.
             */
            failedAt: string
            hardNodeAffinity: string
            /**
             * HealthyAt is set the first time a replica becomes read/write in an engine after creation or rebuild. HealthyAt
             * indicates the time the last successful rebuild occurred. When HealthyAt is set, a replica is likely to have
             * useful (though possibly stale) data. HealthyAt is cleared before a rebuild. HealthyAt may be later than the
             * corresponding entry in an engine's replicaTransitionTimeMap because it is set when the volume controller
             * acknowledges the change.
             */
            healthyAt: string
            image: string
            /**
             * LastFailedAt is always set at the same time as FailedAt. Unlike FailedAt, LastFailedAt is never cleared.
             * LastFailedAt is not a reliable indicator of the state of a replica's data. For example, a replica with
             * LastFailedAt may already be healthy and in use again. However, because it is never cleared, it can be compared to
             * LastHealthyAt to help prevent dangerous replica deletion in some corner cases. LastFailedAt may be later than the
             * corresponding entry in an engine's replicaTransitionTimeMap because it is set when the volume controller
             * acknowledges the change.
             */
            lastFailedAt: string
            /**
             * LastHealthyAt is set every time a replica becomes read/write in an engine. Unlike HealthyAt, LastHealthyAt is
             * never cleared. LastHealthyAt is not a reliable indicator of the state of a replica's data. For example, a
             * replica with LastHealthyAt set may be in the middle of a rebuild. However, because it is never cleared, it can be
             * compared to LastFailedAt to help prevent dangerous replica deletion in some corner cases. LastHealthyAt may be
             * later than the corresponding entry in an engine's replicaTransitionTimeMap because it is set when the volume
             * controller acknowledges the change.
             */
            lastHealthyAt: string
            logRequested: boolean
            /**
             * MigrationEngineName is indicating the migrating engine which current connected to this replica. This is only
             * used for live migration of v2 data engine
             */
            migrationEngineName: string
            nodeID: string
            rebuildRetryCount: number
            revisionCounterDisabled: boolean
            salvageRequested: boolean
            snapshotMaxCount: number
            snapshotMaxSize: string
            unmapMarkDiskChainRemovedEnabled: boolean
            volumeName: string
            volumeSize: string
        }

        /**
         * ReplicaStatus defines the observed state of the Longhorn replica
         */
        export interface ReplicaStatus {
            conditions: outputs.longhorn.v1beta2.ReplicaStatusConditions[]
            currentImage: string
            currentState: string
            /**
             * Deprecated: Replaced by field `spec.evictionRequested`.
             */
            evictionRequested: boolean
            instanceManagerName: string
            ip: string
            logFetched: boolean
            ownerID: string
            port: number
            salvageExecuted: boolean
            started: boolean
            storageIP: string
            ublkID: number
            uuid: string
        }

        export interface ReplicaStatusConditions {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime: string
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime: string
            /**
             * Human-readable message indicating details about last transition.
             */
            message: string
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason: string
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status: string
            /**
             * Type is the type of the condition.
             */
            type: string
        }

        export interface ReplicaStatusConditionsPatch {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime: string
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime: string
            /**
             * Human-readable message indicating details about last transition.
             */
            message: string
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason: string
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status: string
            /**
             * Type is the type of the condition.
             */
            type: string
        }

        /**
         * ReplicaStatus defines the observed state of the Longhorn replica
         */
        export interface ReplicaStatusPatch {
            conditions: outputs.longhorn.v1beta2.ReplicaStatusConditionsPatch[]
            currentImage: string
            currentState: string
            /**
             * Deprecated: Replaced by field `spec.evictionRequested`.
             */
            evictionRequested: boolean
            instanceManagerName: string
            ip: string
            logFetched: boolean
            ownerID: string
            port: number
            salvageExecuted: boolean
            started: boolean
            storageIP: string
            ublkID: number
            uuid: string
        }

        /**
         * Setting is where Longhorn stores setting object.
         */
        export interface Setting {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta2'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'Setting'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            status: outputs.longhorn.v1beta2.SettingStatus
            /**
             * The value of the setting.
             */
            value: string
        }

        /**
         * The status of the setting.
         */
        export interface SettingStatus {
            /**
             * The setting is applied.
             */
            applied: boolean
        }

        /**
         * The status of the setting.
         */
        export interface SettingStatusPatch {
            /**
             * The setting is applied.
             */
            applied: boolean
        }

        /**
         * ShareManager is where Longhorn stores share manager object.
         */
        export interface ShareManager {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta2'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'ShareManager'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: outputs.longhorn.v1beta2.ShareManagerSpec
            status: outputs.longhorn.v1beta2.ShareManagerStatus
        }

        /**
         * ShareManagerSpec defines the desired state of the Longhorn share manager
         */
        export interface ShareManagerSpec {
            /**
             * Share manager image used for creating a share manager pod
             */
            image: string
        }

        /**
         * ShareManagerSpec defines the desired state of the Longhorn share manager
         */
        export interface ShareManagerSpecPatch {
            /**
             * Share manager image used for creating a share manager pod
             */
            image: string
        }

        /**
         * ShareManagerStatus defines the observed state of the Longhorn share manager
         */
        export interface ShareManagerStatus {
            /**
             * NFS endpoint that can access the mounted filesystem of the volume
             */
            endpoint: string
            /**
             * The node ID on which the controller is responsible to reconcile this share manager resource
             */
            ownerID: string
            /**
             * The state of the share manager resource
             */
            state: string
        }

        /**
         * ShareManagerStatus defines the observed state of the Longhorn share manager
         */
        export interface ShareManagerStatusPatch {
            /**
             * NFS endpoint that can access the mounted filesystem of the volume
             */
            endpoint: string
            /**
             * The node ID on which the controller is responsible to reconcile this share manager resource
             */
            ownerID: string
            /**
             * The state of the share manager resource
             */
            state: string
        }

        /**
         * Snapshot is the Schema for the snapshots API
         */
        export interface Snapshot {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta2'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'Snapshot'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: outputs.longhorn.v1beta2.SnapshotSpec
            status: outputs.longhorn.v1beta2.SnapshotStatus
        }

        /**
         * SnapshotSpec defines the desired state of Longhorn Snapshot
         */
        export interface SnapshotSpec {
            /**
             * require creating a new snapshot
             */
            createSnapshot: boolean
            /**
             * The labels of snapshot
             */
            labels: { [key: string]: string }
            /**
             * the volume that this snapshot belongs to.
             * This field is immutable after creation.
             */
            volume: string
        }

        /**
         * SnapshotSpec defines the desired state of Longhorn Snapshot
         */
        export interface SnapshotSpecPatch {
            /**
             * require creating a new snapshot
             */
            createSnapshot: boolean
            /**
             * The labels of snapshot
             */
            labels: { [key: string]: string }
            /**
             * the volume that this snapshot belongs to.
             * This field is immutable after creation.
             */
            volume: string
        }

        /**
         * SnapshotStatus defines the observed state of Longhorn Snapshot
         */
        export interface SnapshotStatus {
            checksum: string
            children: { [key: string]: boolean }
            creationTime: string
            error: string
            labels: { [key: string]: string }
            markRemoved: boolean
            ownerID: string
            parent: string
            readyToUse: boolean
            restoreSize: number
            size: number
            userCreated: boolean
        }

        /**
         * SnapshotStatus defines the observed state of Longhorn Snapshot
         */
        export interface SnapshotStatusPatch {
            checksum: string
            children: { [key: string]: boolean }
            creationTime: string
            error: string
            labels: { [key: string]: string }
            markRemoved: boolean
            ownerID: string
            parent: string
            readyToUse: boolean
            restoreSize: number
            size: number
            userCreated: boolean
        }

        /**
         * SupportBundle is where Longhorn stores support bundle object
         */
        export interface SupportBundle {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta2'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'SupportBundle'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: outputs.longhorn.v1beta2.SupportBundleSpec
            status: outputs.longhorn.v1beta2.SupportBundleStatus
        }

        /**
         * SupportBundleSpec defines the desired state of the Longhorn SupportBundle
         */
        export interface SupportBundleSpec {
            /**
             * A brief description of the issue
             */
            description: string
            /**
             * The issue URL
             */
            issueURL: string
            /**
             * The preferred responsible controller node ID.
             */
            nodeID: string
        }

        /**
         * SupportBundleSpec defines the desired state of the Longhorn SupportBundle
         */
        export interface SupportBundleSpecPatch {
            /**
             * A brief description of the issue
             */
            description: string
            /**
             * The issue URL
             */
            issueURL: string
            /**
             * The preferred responsible controller node ID.
             */
            nodeID: string
        }

        /**
         * SupportBundleStatus defines the observed state of the Longhorn SupportBundle
         */
        export interface SupportBundleStatus {
            conditions: outputs.longhorn.v1beta2.SupportBundleStatusConditions[]
            filename: string
            filesize: number
            /**
             * The support bundle manager image
             */
            image: string
            /**
             * The support bundle manager IP
             */
            managerIP: string
            /**
             * The current responsible controller node ID
             */
            ownerID: string
            progress: number
            state: string
        }

        export interface SupportBundleStatusConditions {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime: string
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime: string
            /**
             * Human-readable message indicating details about last transition.
             */
            message: string
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason: string
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status: string
            /**
             * Type is the type of the condition.
             */
            type: string
        }

        export interface SupportBundleStatusConditionsPatch {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime: string
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime: string
            /**
             * Human-readable message indicating details about last transition.
             */
            message: string
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason: string
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status: string
            /**
             * Type is the type of the condition.
             */
            type: string
        }

        /**
         * SupportBundleStatus defines the observed state of the Longhorn SupportBundle
         */
        export interface SupportBundleStatusPatch {
            conditions: outputs.longhorn.v1beta2.SupportBundleStatusConditionsPatch[]
            filename: string
            filesize: number
            /**
             * The support bundle manager image
             */
            image: string
            /**
             * The support bundle manager IP
             */
            managerIP: string
            /**
             * The current responsible controller node ID
             */
            ownerID: string
            progress: number
            state: string
        }

        /**
         * SystemBackup is where Longhorn stores system backup object
         */
        export interface SystemBackup {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta2'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'SystemBackup'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: outputs.longhorn.v1beta2.SystemBackupSpec
            status: outputs.longhorn.v1beta2.SystemBackupStatus
        }

        /**
         * SystemBackupSpec defines the desired state of the Longhorn SystemBackup
         */
        export interface SystemBackupSpec {
            /**
             * The create volume backup policy
             * Can be "if-not-present", "always" or "disabled"
             */
            volumeBackupPolicy: string
        }

        /**
         * SystemBackupSpec defines the desired state of the Longhorn SystemBackup
         */
        export interface SystemBackupSpecPatch {
            /**
             * The create volume backup policy
             * Can be "if-not-present", "always" or "disabled"
             */
            volumeBackupPolicy: string
        }

        /**
         * SystemBackupStatus defines the observed state of the Longhorn SystemBackup
         */
        export interface SystemBackupStatus {
            conditions: outputs.longhorn.v1beta2.SystemBackupStatusConditions[]
            /**
             * The system backup creation time.
             */
            createdAt: string
            /**
             * The saved Longhorn manager git commit.
             */
            gitCommit: string
            /**
             * The last time that the system backup was synced into the cluster.
             */
            lastSyncedAt: string
            /**
             * The saved manager image.
             */
            managerImage: string
            /**
             * The node ID of the responsible controller to reconcile this SystemBackup.
             */
            ownerID: string
            /**
             * The system backup state.
             */
            state: string
            /**
             * The saved Longhorn version.
             */
            version: string
        }

        export interface SystemBackupStatusConditions {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime: string
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime: string
            /**
             * Human-readable message indicating details about last transition.
             */
            message: string
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason: string
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status: string
            /**
             * Type is the type of the condition.
             */
            type: string
        }

        export interface SystemBackupStatusConditionsPatch {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime: string
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime: string
            /**
             * Human-readable message indicating details about last transition.
             */
            message: string
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason: string
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status: string
            /**
             * Type is the type of the condition.
             */
            type: string
        }

        /**
         * SystemBackupStatus defines the observed state of the Longhorn SystemBackup
         */
        export interface SystemBackupStatusPatch {
            conditions: outputs.longhorn.v1beta2.SystemBackupStatusConditionsPatch[]
            /**
             * The system backup creation time.
             */
            createdAt: string
            /**
             * The saved Longhorn manager git commit.
             */
            gitCommit: string
            /**
             * The last time that the system backup was synced into the cluster.
             */
            lastSyncedAt: string
            /**
             * The saved manager image.
             */
            managerImage: string
            /**
             * The node ID of the responsible controller to reconcile this SystemBackup.
             */
            ownerID: string
            /**
             * The system backup state.
             */
            state: string
            /**
             * The saved Longhorn version.
             */
            version: string
        }

        /**
         * SystemRestore is where Longhorn stores system restore object
         */
        export interface SystemRestore {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta2'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'SystemRestore'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: outputs.longhorn.v1beta2.SystemRestoreSpec
            status: outputs.longhorn.v1beta2.SystemRestoreStatus
        }

        /**
         * SystemRestoreSpec defines the desired state of the Longhorn SystemRestore
         */
        export interface SystemRestoreSpec {
            /**
             * The system backup name in the object store.
             */
            systemBackup: string
        }

        /**
         * SystemRestoreSpec defines the desired state of the Longhorn SystemRestore
         */
        export interface SystemRestoreSpecPatch {
            /**
             * The system backup name in the object store.
             */
            systemBackup: string
        }

        /**
         * SystemRestoreStatus defines the observed state of the Longhorn SystemRestore
         */
        export interface SystemRestoreStatus {
            conditions: outputs.longhorn.v1beta2.SystemRestoreStatusConditions[]
            /**
             * The node ID of the responsible controller to reconcile this SystemRestore.
             */
            ownerID: string
            /**
             * The source system backup URL.
             */
            sourceURL: string
            /**
             * The system restore state.
             */
            state: string
        }

        export interface SystemRestoreStatusConditions {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime: string
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime: string
            /**
             * Human-readable message indicating details about last transition.
             */
            message: string
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason: string
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status: string
            /**
             * Type is the type of the condition.
             */
            type: string
        }

        export interface SystemRestoreStatusConditionsPatch {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime: string
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime: string
            /**
             * Human-readable message indicating details about last transition.
             */
            message: string
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason: string
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status: string
            /**
             * Type is the type of the condition.
             */
            type: string
        }

        /**
         * SystemRestoreStatus defines the observed state of the Longhorn SystemRestore
         */
        export interface SystemRestoreStatusPatch {
            conditions: outputs.longhorn.v1beta2.SystemRestoreStatusConditionsPatch[]
            /**
             * The node ID of the responsible controller to reconcile this SystemRestore.
             */
            ownerID: string
            /**
             * The source system backup URL.
             */
            sourceURL: string
            /**
             * The system restore state.
             */
            state: string
        }

        /**
         * Volume is where Longhorn stores volume object.
         */
        export interface Volume {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta2'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'Volume'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: outputs.longhorn.v1beta2.VolumeSpec
            status: outputs.longhorn.v1beta2.VolumeStatus
        }

        /**
         * VolumeAttachment stores attachment information of a Longhorn volume
         */
        export interface VolumeAttachment {
            /**
             * APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
             */
            apiVersion: 'longhorn.io/v1beta2'
            /**
             * Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: 'VolumeAttachment'
            /**
             * Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            metadata: outputs.meta.v1.ObjectMeta
            spec: outputs.longhorn.v1beta2.VolumeAttachmentSpec
            status: outputs.longhorn.v1beta2.VolumeAttachmentStatus
        }

        /**
         * VolumeAttachmentSpec defines the desired state of Longhorn VolumeAttachment
         */
        export interface VolumeAttachmentSpec {
            attachmentTickets: { [key: string]: { [key: string]: string } }
            /**
             * The name of Longhorn volume of this VolumeAttachment
             */
            volume: string
        }

        /**
         * VolumeAttachmentSpec defines the desired state of Longhorn VolumeAttachment
         */
        export interface VolumeAttachmentSpecPatch {
            attachmentTickets: { [key: string]: { [key: string]: string } }
            /**
             * The name of Longhorn volume of this VolumeAttachment
             */
            volume: string
        }

        /**
         * VolumeAttachmentStatus defines the observed state of Longhorn VolumeAttachment
         */
        export interface VolumeAttachmentStatus {
            attachmentTicketStatuses: { [key: string]: { [key: string]: string } }
        }

        /**
         * VolumeAttachmentStatus defines the observed state of Longhorn VolumeAttachment
         */
        export interface VolumeAttachmentStatusPatch {
            attachmentTicketStatuses: { [key: string]: { [key: string]: string } }
        }

        /**
         * VolumeSpec defines the desired state of the Longhorn volume
         */
        export interface VolumeSpec {
            Standby: boolean
            accessMode: string
            backingImage: string
            backupCompressionMethod: string
            /**
             * The backup target name that the volume will be backed up to or is synced.
             */
            backupTargetName: string
            dataEngine: string
            dataLocality: string
            dataSource: string
            disableFrontend: boolean
            diskSelector: string[]
            encrypted: boolean
            /**
             * Setting that freezes the filesystem on the root partition before a snapshot is created.
             */
            freezeFilesystemForSnapshot: string
            fromBackup: string
            frontend: string
            image: string
            lastAttachedBy: string
            migratable: boolean
            migrationNodeID: string
            nodeID: string
            nodeSelector: string[]
            numberOfReplicas: number
            /**
             * Specifies whether Longhorn should rebuild replicas while the detached volume is degraded.
             * - ignored: Use the global setting for offline replica rebuilding.
             * - enabled: Enable offline rebuilding for this volume, regardless of the global setting.
             * - disabled: Disable offline rebuilding for this volume, regardless of the global setting
             */
            offlineRebuilding: string
            replicaAutoBalance: string
            /**
             * Replica disk soft anti affinity of the volume. Set enabled to allow replicas to be scheduled in the same disk.
             */
            replicaDiskSoftAntiAffinity: string
            /**
             * Replica soft anti affinity of the volume. Set enabled to allow replicas to be scheduled on the same node.
             */
            replicaSoftAntiAffinity: string
            /**
             * Replica zone soft anti affinity of the volume. Set enabled to allow replicas to be scheduled in the same zone.
             */
            replicaZoneSoftAntiAffinity: string
            restoreVolumeRecurringJob: string
            revisionCounterDisabled: boolean
            size: string
            snapshotDataIntegrity: string
            snapshotMaxCount: number
            snapshotMaxSize: string
            staleReplicaTimeout: number
            unmapMarkSnapChainRemoved: string
        }

        /**
         * VolumeSpec defines the desired state of the Longhorn volume
         */
        export interface VolumeSpecPatch {
            Standby: boolean
            accessMode: string
            backingImage: string
            backupCompressionMethod: string
            /**
             * The backup target name that the volume will be backed up to or is synced.
             */
            backupTargetName: string
            dataEngine: string
            dataLocality: string
            dataSource: string
            disableFrontend: boolean
            diskSelector: string[]
            encrypted: boolean
            /**
             * Setting that freezes the filesystem on the root partition before a snapshot is created.
             */
            freezeFilesystemForSnapshot: string
            fromBackup: string
            frontend: string
            image: string
            lastAttachedBy: string
            migratable: boolean
            migrationNodeID: string
            nodeID: string
            nodeSelector: string[]
            numberOfReplicas: number
            /**
             * Specifies whether Longhorn should rebuild replicas while the detached volume is degraded.
             * - ignored: Use the global setting for offline replica rebuilding.
             * - enabled: Enable offline rebuilding for this volume, regardless of the global setting.
             * - disabled: Disable offline rebuilding for this volume, regardless of the global setting
             */
            offlineRebuilding: string
            replicaAutoBalance: string
            /**
             * Replica disk soft anti affinity of the volume. Set enabled to allow replicas to be scheduled in the same disk.
             */
            replicaDiskSoftAntiAffinity: string
            /**
             * Replica soft anti affinity of the volume. Set enabled to allow replicas to be scheduled on the same node.
             */
            replicaSoftAntiAffinity: string
            /**
             * Replica zone soft anti affinity of the volume. Set enabled to allow replicas to be scheduled in the same zone.
             */
            replicaZoneSoftAntiAffinity: string
            restoreVolumeRecurringJob: string
            revisionCounterDisabled: boolean
            size: string
            snapshotDataIntegrity: string
            snapshotMaxCount: number
            snapshotMaxSize: string
            staleReplicaTimeout: number
            unmapMarkSnapChainRemoved: string
        }

        /**
         * VolumeStatus defines the observed state of the Longhorn volume
         */
        export interface VolumeStatus {
            actualSize: number
            cloneStatus: outputs.longhorn.v1beta2.VolumeStatusCloneStatus
            conditions: outputs.longhorn.v1beta2.VolumeStatusConditions[]
            currentImage: string
            /**
             * the node that this volume is currently migrating to
             */
            currentMigrationNodeID: string
            currentNodeID: string
            expansionRequired: boolean
            frontendDisabled: boolean
            isStandby: boolean
            kubernetesStatus: outputs.longhorn.v1beta2.VolumeStatusKubernetesStatus
            lastBackup: string
            lastBackupAt: string
            lastDegradedAt: string
            ownerID: string
            remountRequestedAt: string
            restoreInitiated: boolean
            restoreRequired: boolean
            robustness: string
            shareEndpoint: string
            shareState: string
            state: string
        }

        export interface VolumeStatusCloneStatus {
            attemptCount: number
            nextAllowedAttemptAt: string
            snapshot: string
            sourceVolume: string
            state: string
        }

        export interface VolumeStatusCloneStatusPatch {
            attemptCount: number
            nextAllowedAttemptAt: string
            snapshot: string
            sourceVolume: string
            state: string
        }

        export interface VolumeStatusConditions {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime: string
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime: string
            /**
             * Human-readable message indicating details about last transition.
             */
            message: string
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason: string
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status: string
            /**
             * Type is the type of the condition.
             */
            type: string
        }

        export interface VolumeStatusConditionsPatch {
            /**
             * Last time we probed the condition.
             */
            lastProbeTime: string
            /**
             * Last time the condition transitioned from one status to another.
             */
            lastTransitionTime: string
            /**
             * Human-readable message indicating details about last transition.
             */
            message: string
            /**
             * Unique, one-word, CamelCase reason for the condition's last transition.
             */
            reason: string
            /**
             * Status is the status of the condition.
             * Can be True, False, Unknown.
             */
            status: string
            /**
             * Type is the type of the condition.
             */
            type: string
        }

        export interface VolumeStatusKubernetesStatus {
            lastPVCRefAt: string
            lastPodRefAt: string
            /**
             * determine if PVC/Namespace is history or not
             */
            namespace: string
            pvName: string
            pvStatus: string
            pvcName: string
            /**
             * determine if Pod/Workload is history or not
             */
            workloadsStatus: outputs.longhorn.v1beta2.VolumeStatusKubernetesStatusWorkloadsStatus[]
        }

        export interface VolumeStatusKubernetesStatusPatch {
            lastPVCRefAt: string
            lastPodRefAt: string
            /**
             * determine if PVC/Namespace is history or not
             */
            namespace: string
            pvName: string
            pvStatus: string
            pvcName: string
            /**
             * determine if Pod/Workload is history or not
             */
            workloadsStatus: outputs.longhorn.v1beta2.VolumeStatusKubernetesStatusWorkloadsStatusPatch[]
        }

        export interface VolumeStatusKubernetesStatusWorkloadsStatus {
            podName: string
            podStatus: string
            workloadName: string
            workloadType: string
        }

        export interface VolumeStatusKubernetesStatusWorkloadsStatusPatch {
            podName: string
            podStatus: string
            workloadName: string
            workloadType: string
        }

        /**
         * VolumeStatus defines the observed state of the Longhorn volume
         */
        export interface VolumeStatusPatch {
            actualSize: number
            cloneStatus: outputs.longhorn.v1beta2.VolumeStatusCloneStatusPatch
            conditions: outputs.longhorn.v1beta2.VolumeStatusConditionsPatch[]
            currentImage: string
            /**
             * the node that this volume is currently migrating to
             */
            currentMigrationNodeID: string
            currentNodeID: string
            expansionRequired: boolean
            frontendDisabled: boolean
            isStandby: boolean
            kubernetesStatus: outputs.longhorn.v1beta2.VolumeStatusKubernetesStatusPatch
            lastBackup: string
            lastBackupAt: string
            lastDegradedAt: string
            ownerID: string
            remountRequestedAt: string
            restoreInitiated: boolean
            restoreRequired: boolean
            robustness: string
            shareEndpoint: string
            shareState: string
            state: string
        }
    }
}

export namespace meta {
    export namespace v1 {
        /**
         * ListMeta describes metadata that synthetic resources must have, including lists and various status objects. A resource may have only one of {ObjectMeta, ListMeta}.
         */
        export interface ListMeta {
            /**
             * continue may be set if the user set a limit on the number of items returned, and indicates that the server has more data available. The value is opaque and may be used to issue another request to the endpoint that served this list to retrieve the next set of available objects. Continuing a consistent list may not be possible if the server configuration has changed or more than a few minutes have passed. The resourceVersion field returned when using this continue value will be identical to the value in the first response, unless you have received this token from an error message.
             */
            continue: string
            /**
             * remainingItemCount is the number of subsequent items in the list which are not included in this list response. If the list request contained label or field selectors, then the number of remaining items is unknown and the field will be left unset and omitted during serialization. If the list is complete (either because it is not chunking or because this is the last chunk), then there are no more remaining items and this field will be left unset and omitted during serialization. Servers older than v1.15 do not set this field. The intended use of the remainingItemCount is *estimating* the size of a collection. Clients should not rely on the remainingItemCount to be set or to be exact.
             */
            remainingItemCount: number
            /**
             * String that identifies the server's internal version of this object that can be used by clients to determine when objects have changed. Value must be treated as opaque by clients and passed unmodified back to the server. Populated by the system. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion: string
            /**
             * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
             */
            selfLink: string
        }

        /**
         * ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to.
         */
        export interface ManagedFieldsEntry {
            /**
             * APIVersion defines the version of this resource that this field set applies to. The format is "group/version" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.
             */
            apiVersion: string
            /**
             * FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: "FieldsV1"
             */
            fieldsType: string
            /**
             * FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
             */
            fieldsV1: any
            /**
             * Manager is an identifier of the workflow managing these fields.
             */
            manager: string
            /**
             * Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.
             */
            operation: string
            /**
             * Subresource is the name of the subresource used to update that object, or empty string if the object was updated through the main resource. The value of this field is used to distinguish between managers, even if they share the same name. For example, a status update will be distinct from a regular update using the same manager name. Note that the APIVersion field is not related to the Subresource field and it always corresponds to the version of the main resource.
             */
            subresource: string
            /**
             * Time is the timestamp of when the ManagedFields entry was added. The timestamp will also be updated if a field is added, the manager changes any of the owned fields value or removes a field. The timestamp does not update when a field is removed from the entry because another manager took it over.
             */
            time: string
        }

        /**
         * ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource that the fieldset applies to.
         */
        export interface ManagedFieldsEntryPatch {
            /**
             * APIVersion defines the version of this resource that this field set applies to. The format is "group/version" just like the top-level APIVersion field. It is necessary to track the version of a field set because it cannot be automatically converted.
             */
            apiVersion: string
            /**
             * FieldsType is the discriminator for the different fields format and version. There is currently only one possible value: "FieldsV1"
             */
            fieldsType: string
            /**
             * FieldsV1 holds the first JSON version format as described in the "FieldsV1" type.
             */
            fieldsV1: any
            /**
             * Manager is an identifier of the workflow managing these fields.
             */
            manager: string
            /**
             * Operation is the type of operation which lead to this ManagedFieldsEntry being created. The only valid values for this field are 'Apply' and 'Update'.
             */
            operation: string
            /**
             * Subresource is the name of the subresource used to update that object, or empty string if the object was updated through the main resource. The value of this field is used to distinguish between managers, even if they share the same name. For example, a status update will be distinct from a regular update using the same manager name. Note that the APIVersion field is not related to the Subresource field and it always corresponds to the version of the main resource.
             */
            subresource: string
            /**
             * Time is the timestamp of when the ManagedFields entry was added. The timestamp will also be updated if a field is added, the manager changes any of the owned fields value or removes a field. The timestamp does not update when a field is removed from the entry because another manager took it over.
             */
            time: string
        }

        /**
         * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
         */
        export interface ObjectMeta {
            /**
             * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
             */
            annotations: { [key: string]: string }
            /**
             * CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.
             *
             * Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            creationTimestamp: string
            /**
             * Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
             */
            deletionGracePeriodSeconds: number
            /**
             * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested.
             *
             * Populated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            deletionTimestamp: string
            /**
             * Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list.
             */
            finalizers: string[]
            /**
             * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
             *
             * If this field is specified and the generated name exists, the server will return a 409.
             *
             * Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
             */
            generateName: string
            /**
             * A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.
             */
            generation: number
            /**
             * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
             */
            labels: { [key: string]: string }
            /**
             * ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like "ci-cd". The set of fields is always in the version that the workflow used when modifying the object.
             */
            managedFields: outputs.meta.v1.ManagedFieldsEntry[]
            /**
             * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
             */
            name: string
            /**
             * Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
             *
             * Must be a DNS_LABEL. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
             */
            namespace: string
            /**
             * List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.
             */
            ownerReferences: outputs.meta.v1.OwnerReference[]
            /**
             * An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.
             *
             * Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion: string
            /**
             * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
             */
            selfLink: string
            /**
             * UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.
             *
             * Populated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
             */
            uid: string
        }

        /**
         * ObjectMeta is metadata that all persisted resources must have, which includes all objects users must create.
         */
        export interface ObjectMetaPatch {
            /**
             * Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations
             */
            annotations: { [key: string]: string }
            /**
             * CreationTimestamp is a timestamp representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations. Clients may not set this value. It is represented in RFC3339 form and is in UTC.
             *
             * Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            creationTimestamp: string
            /**
             * Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
             */
            deletionGracePeriodSeconds: number
            /**
             * DeletionTimestamp is RFC 3339 date and time at which this resource will be deleted. This field is set by the server when a graceful deletion is requested by the user, and is not directly settable by a client. The resource is expected to be deleted (no longer visible from resource lists, and not reachable by name) after the time in this field, once the finalizers list is empty. As long as the finalizers list contains items, deletion is blocked. Once the deletionTimestamp is set, this value may not be unset or be set further into the future, although it may be shortened or the resource may be deleted prior to this time. For example, a user may request that a pod is deleted in 30 seconds. The Kubelet will react by sending a graceful termination signal to the containers in the pod. After that 30 seconds, the Kubelet will send a hard termination signal (SIGKILL) to the container and after cleanup, remove the pod from the API. In the presence of network partitions, this object may still exist after this timestamp, until an administrator or automated process can determine the resource is fully terminated. If not set, graceful deletion of the object has not been requested.
             *
             * Populated by the system when a graceful deletion is requested. Read-only. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
             */
            deletionTimestamp: string
            /**
             * Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed. Finalizers may be processed and removed in any order.  Order is NOT enforced because it introduces significant risk of stuck finalizers. finalizers is a shared field, any actor with permission can reorder it. If the finalizer list is processed in order, then this can lead to a situation in which the component responsible for the first finalizer in the list is waiting for a signal (field value, external system, or other) produced by a component responsible for a finalizer later in the list, resulting in a deadlock. Without enforced ordering finalizers are free to order amongst themselves and are not vulnerable to ordering changes in the list.
             */
            finalizers: string[]
            /**
             * GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
             *
             * If this field is specified and the generated name exists, the server will return a 409.
             *
             * Applied only if Name is not specified. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#idempotency
             */
            generateName: string
            /**
             * A sequence number representing a specific generation of the desired state. Populated by the system. Read-only.
             */
            generation: number
            /**
             * Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels
             */
            labels: { [key: string]: string }
            /**
             * ManagedFields maps workflow-id and version to the set of fields that are managed by that workflow. This is mostly for internal housekeeping, and users typically shouldn't need to set or understand this field. A workflow can be the user's name, a controller's name, or the name of a specific apply path like "ci-cd". The set of fields is always in the version that the workflow used when modifying the object.
             */
            managedFields: outputs.meta.v1.ManagedFieldsEntryPatch[]
            /**
             * Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
             */
            name: string
            /**
             * Namespace defines the space within which each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
             *
             * Must be a DNS_LABEL. Cannot be updated. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces
             */
            namespace: string
            /**
             * List of objects depended by this object. If ALL objects in the list have been deleted, this object will be garbage collected. If this object is managed by a controller, then an entry in this list will point to this controller, with the controller field set to true. There cannot be more than one managing controller.
             */
            ownerReferences: outputs.meta.v1.OwnerReferencePatch[]
            /**
             * An opaque value that represents the internal version of this object that can be used by clients to determine when objects have changed. May be used for optimistic concurrency, change detection, and the watch operation on a resource or set of resources. Clients must treat these values as opaque and passed unmodified back to the server. They may only be valid for a particular resource or set of resources.
             *
             * Populated by the system. Read-only. Value must be treated as opaque by clients and . More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#concurrency-control-and-consistency
             */
            resourceVersion: string
            /**
             * Deprecated: selfLink is a legacy read-only field that is no longer populated by the system.
             */
            selfLink: string
            /**
             * UID is the unique in time and space value for this object. It is typically generated by the server on successful creation of a resource and is not allowed to change on PUT operations.
             *
             * Populated by the system. Read-only. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
             */
            uid: string
        }

        /**
         * OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.
         */
        export interface OwnerReference {
            /**
             * API version of the referent.
             */
            apiVersion: string
            /**
             * If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion for how the garbage collector interacts with this field and enforces the foreground deletion. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
             */
            blockOwnerDeletion: boolean
            /**
             * If true, this reference points to the managing controller.
             */
            controller: boolean
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: string
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
             */
            name: string
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
             */
            uid: string
        }

        /**
         * OwnerReference contains enough information to let you identify an owning object. An owning object must be in the same namespace as the dependent, or be cluster-scoped, so there is no namespace field.
         */
        export interface OwnerReferencePatch {
            /**
             * API version of the referent.
             */
            apiVersion: string
            /**
             * If true, AND if the owner has the "foregroundDeletion" finalizer, then the owner cannot be deleted from the key-value store until this reference is removed. See https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion for how the garbage collector interacts with this field and enforces the foreground deletion. Defaults to false. To set this field, a user needs "delete" permission of the owner, otherwise 422 (Unprocessable Entity) will be returned.
             */
            blockOwnerDeletion: boolean
            /**
             * If true, this reference points to the managing controller.
             */
            controller: boolean
            /**
             * Kind of the referent. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
             */
            kind: string
            /**
             * Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#names
             */
            name: string
            /**
             * UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names#uids
             */
            uid: string
        }
    }
}
