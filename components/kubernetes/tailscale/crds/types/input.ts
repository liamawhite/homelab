// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

import * as utilities from "../utilities";

import {ObjectMeta} from "../meta/v1";

export namespace tailscale {
    export namespace v1alpha1 {
        /**
         * ConnectorSpec describes the desired Tailscale component.
         * More info:
         * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
         */
        export interface ConnectorSpecArgs {
            /**
             * AppConnector defines whether the Connector device should act as a Tailscale app connector. A Connector that is
             * configured as an app connector cannot be a subnet router or an exit node. If this field is unset, the
             * Connector does not act as an app connector.
             * Note that you will need to manually configure the permissions and the domains for the app connector via the
             * Admin panel.
             * Note also that the main tested and supported use case of this config option is to deploy an app connector on
             * Kubernetes to access SaaS applications available on the public internet. Using the app connector to expose
             * cluster workloads or other internal workloads to tailnet might work, but this is not a use case that we have
             * tested or optimised for.
             * If you are using the app connector to access SaaS applications because you need a predictable egress IP that
             * can be whitelisted, it is also your responsibility to ensure that cluster traffic from the connector flows
             * via that predictable IP, for example by enforcing that cluster egress traffic is routed via an egress NAT
             * device with a static IP address.
             * https://tailscale.com/kb/1281/app-connectors
             */
            appConnector?: pulumi.Input<inputs.tailscale.v1alpha1.ConnectorSpecAppConnectorArgs>;
            /**
             * ExitNode defines whether the Connector device should act as a Tailscale exit node. Defaults to false.
             * This field is mutually exclusive with the appConnector field.
             * https://tailscale.com/kb/1103/exit-nodes
             */
            exitNode?: pulumi.Input<boolean>;
            /**
             * Hostname is the tailnet hostname that should be assigned to the
             * Connector node. If unset, hostname defaults to <connector
             * name>-connector. Hostname can contain lower case letters, numbers and
             * dashes, it must not start or end with a dash and must be between 2
             * and 63 characters long.
             */
            hostname?: pulumi.Input<string>;
            /**
             * ProxyClass is the name of the ProxyClass custom resource that
             * contains configuration options that should be applied to the
             * resources created for this Connector. If unset, the operator will
             * create resources with the default configuration.
             */
            proxyClass?: pulumi.Input<string>;
            /**
             * SubnetRouter defines subnet routes that the Connector device should
             * expose to tailnet as a Tailscale subnet router.
             * https://tailscale.com/kb/1019/subnets/
             * If this field is unset, the device does not get configured as a Tailscale subnet router.
             * This field is mutually exclusive with the appConnector field.
             */
            subnetRouter?: pulumi.Input<inputs.tailscale.v1alpha1.ConnectorSpecSubnetRouterArgs>;
            /**
             * Tags that the Tailscale node will be tagged with.
             * Defaults to [tag:k8s].
             * To autoapprove the subnet routes or exit node defined by a Connector,
             * you can configure Tailscale ACLs to give these tags the necessary
             * permissions.
             * See https://tailscale.com/kb/1337/acl-syntax#autoapprovers.
             * If you specify custom tags here, you must also make the operator an owner of these tags.
             * See  https://tailscale.com/kb/1236/kubernetes-operator/#setting-up-the-kubernetes-operator.
             * Tags cannot be changed once a Connector node has been created.
             * Tag values must be in form ^tag:[a-zA-Z][a-zA-Z0-9-]*$.
             */
            tags?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * AppConnector defines whether the Connector device should act as a Tailscale app connector. A Connector that is
         * configured as an app connector cannot be a subnet router or an exit node. If this field is unset, the
         * Connector does not act as an app connector.
         * Note that you will need to manually configure the permissions and the domains for the app connector via the
         * Admin panel.
         * Note also that the main tested and supported use case of this config option is to deploy an app connector on
         * Kubernetes to access SaaS applications available on the public internet. Using the app connector to expose
         * cluster workloads or other internal workloads to tailnet might work, but this is not a use case that we have
         * tested or optimised for.
         * If you are using the app connector to access SaaS applications because you need a predictable egress IP that
         * can be whitelisted, it is also your responsibility to ensure that cluster traffic from the connector flows
         * via that predictable IP, for example by enforcing that cluster egress traffic is routed via an egress NAT
         * device with a static IP address.
         * https://tailscale.com/kb/1281/app-connectors
         */
        export interface ConnectorSpecAppConnectorArgs {
            /**
             * Routes are optional preconfigured routes for the domains routed via the app connector.
             * If not set, routes for the domains will be discovered dynamically.
             * If set, the app connector will immediately be able to route traffic using the preconfigured routes, but may
             * also dynamically discover other routes.
             * https://tailscale.com/kb/1332/apps-best-practices#preconfiguration
             */
            routes?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * SubnetRouter defines subnet routes that the Connector device should
         * expose to tailnet as a Tailscale subnet router.
         * https://tailscale.com/kb/1019/subnets/
         * If this field is unset, the device does not get configured as a Tailscale subnet router.
         * This field is mutually exclusive with the appConnector field.
         */
        export interface ConnectorSpecSubnetRouterArgs {
            /**
             * AdvertiseRoutes refer to CIDRs that the subnet router should make
             * available. Route values must be strings that represent a valid IPv4
             * or IPv6 CIDR range. Values can be Tailscale 4via6 subnet routes.
             * https://tailscale.com/kb/1201/4via6-subnets/
             */
            advertiseRoutes: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * ConnectorStatus describes the status of the Connector. This is set
         * and managed by the Tailscale operator.
         */
        export interface ConnectorStatusArgs {
            /**
             * List of status conditions to indicate the status of the Connector.
             * Known condition types are `ConnectorReady`.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ConnectorStatusConditionsArgs>[]>;
            /**
             * Hostname is the fully qualified domain name of the Connector node.
             * If MagicDNS is enabled in your tailnet, it is the MagicDNS name of the
             * node.
             */
            hostname?: pulumi.Input<string>;
            /**
             * IsAppConnector is set to true if the Connector acts as an app connector.
             */
            isAppConnector?: pulumi.Input<boolean>;
            /**
             * IsExitNode is set to true if the Connector acts as an exit node.
             */
            isExitNode?: pulumi.Input<boolean>;
            /**
             * SubnetRoutes are the routes currently exposed to tailnet via this
             * Connector instance.
             */
            subnetRoutes?: pulumi.Input<string>;
            /**
             * TailnetIPs is the set of tailnet IP addresses (both IPv4 and IPv6)
             * assigned to the Connector node.
             */
            tailnetIPs?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         */
        export interface ConnectorStatusConditionsArgs {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: pulumi.Input<string>;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: pulumi.Input<string>;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             */
            type: pulumi.Input<string>;
        }

        /**
         * Spec describes the desired DNS configuration.
         * More info:
         * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
         */
        export interface DNSConfigSpecArgs {
            /**
             * Configuration for a nameserver that can resolve ts.net DNS names
             * associated with in-cluster proxies for Tailscale egress Services and
             * Tailscale Ingresses. The operator will always deploy this nameserver
             * when a DNSConfig is applied.
             */
            nameserver: pulumi.Input<inputs.tailscale.v1alpha1.DNSConfigSpecNameserverArgs>;
        }

        /**
         * Configuration for a nameserver that can resolve ts.net DNS names
         * associated with in-cluster proxies for Tailscale egress Services and
         * Tailscale Ingresses. The operator will always deploy this nameserver
         * when a DNSConfig is applied.
         */
        export interface DNSConfigSpecNameserverArgs {
            /**
             * Nameserver image. Defaults to tailscale/k8s-nameserver:unstable.
             */
            image?: pulumi.Input<inputs.tailscale.v1alpha1.DNSConfigSpecNameserverImageArgs>;
        }

        /**
         * Nameserver image. Defaults to tailscale/k8s-nameserver:unstable.
         */
        export interface DNSConfigSpecNameserverImageArgs {
            /**
             * Repo defaults to tailscale/k8s-nameserver.
             */
            repo?: pulumi.Input<string>;
            /**
             * Tag defaults to unstable.
             */
            tag?: pulumi.Input<string>;
        }

        /**
         * Status describes the status of the DNSConfig. This is set
         * and managed by the Tailscale operator.
         */
        export interface DNSConfigStatusArgs {
            conditions?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.DNSConfigStatusConditionsArgs>[]>;
            /**
             * Nameserver describes the status of nameserver cluster resources.
             */
            nameserver?: pulumi.Input<inputs.tailscale.v1alpha1.DNSConfigStatusNameserverArgs>;
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         */
        export interface DNSConfigStatusConditionsArgs {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: pulumi.Input<string>;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: pulumi.Input<string>;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             */
            type: pulumi.Input<string>;
        }

        /**
         * Nameserver describes the status of nameserver cluster resources.
         */
        export interface DNSConfigStatusNameserverArgs {
            /**
             * IP is the ClusterIP of the Service fronting the deployed ts.net nameserver.
             * Currently you must manually update your cluster DNS config to add
             * this address as a stub nameserver for ts.net for cluster workloads to be
             * able to resolve MagicDNS names associated with egress or Ingress
             * proxies.
             * The IP address will change if you delete and recreate the DNSConfig.
             */
            ip?: pulumi.Input<string>;
        }

        /**
         * Specification of the desired state of the ProxyClass resource.
         * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
         */
        export interface ProxyClassSpecArgs {
            /**
             * Configuration for proxy metrics. Metrics are currently not supported
             * for egress proxies and for Ingress proxies that have been configured
             * with tailscale.com/experimental-forward-cluster-traffic-via-ingress
             * annotation. Note that the metrics are currently considered unstable
             * and will likely change in breaking ways in the future - we only
             * recommend that you use those for debugging purposes.
             */
            metrics?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecMetricsArgs>;
            /**
             * Configuration parameters for the proxy's StatefulSet. Tailscale
             * Kubernetes operator deploys a StatefulSet for each of the user
             * configured proxies (Tailscale Ingress, Tailscale Service, Connector).
             */
            statefulSet?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetArgs>;
            /**
             * TailscaleConfig contains options to configure the tailscale-specific
             * parameters of proxies.
             */
            tailscale?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecTailscaleArgs>;
        }

        /**
         * Configuration for proxy metrics. Metrics are currently not supported
         * for egress proxies and for Ingress proxies that have been configured
         * with tailscale.com/experimental-forward-cluster-traffic-via-ingress
         * annotation. Note that the metrics are currently considered unstable
         * and will likely change in breaking ways in the future - we only
         * recommend that you use those for debugging purposes.
         */
        export interface ProxyClassSpecMetricsArgs {
            /**
             * Setting enable to true will make the proxy serve Tailscale metrics
             * at <pod-ip>:9002/metrics.
             * A metrics Service named <proxy-statefulset>-metrics will also be created in the operator's namespace and will
             * serve the metrics at <service-ip>:9002/metrics.
             *
             * In 1.78.x and 1.80.x, this field also serves as the default value for
             * .spec.statefulSet.pod.tailscaleContainer.debug.enable. From 1.82.0, both
             * fields will independently default to false.
             *
             * Defaults to false.
             */
            enable: pulumi.Input<boolean>;
            /**
             * Enable to create a Prometheus ServiceMonitor for scraping the proxy's Tailscale metrics.
             * The ServiceMonitor will select the metrics Service that gets created when metrics are enabled.
             * The ingested metrics for each Service monitor will have labels to identify the proxy:
             * ts_proxy_type: ingress_service|ingress_resource|connector|proxygroup
             * ts_proxy_parent_name: name of the parent resource (i.e name of the Connector, Tailscale Ingress, Tailscale Service or ProxyGroup)
             * ts_proxy_parent_namespace: namespace of the parent resource (if the parent resource is not cluster scoped)
             * job: ts_<proxy type>_[<parent namespace>]_<parent_name>
             */
            serviceMonitor?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecMetricsServiceMonitorArgs>;
        }

        /**
         * Enable to create a Prometheus ServiceMonitor for scraping the proxy's Tailscale metrics.
         * The ServiceMonitor will select the metrics Service that gets created when metrics are enabled.
         * The ingested metrics for each Service monitor will have labels to identify the proxy:
         * ts_proxy_type: ingress_service|ingress_resource|connector|proxygroup
         * ts_proxy_parent_name: name of the parent resource (i.e name of the Connector, Tailscale Ingress, Tailscale Service or ProxyGroup)
         * ts_proxy_parent_namespace: namespace of the parent resource (if the parent resource is not cluster scoped)
         * job: ts_<proxy type>_[<parent namespace>]_<parent_name>
         */
        export interface ProxyClassSpecMetricsServiceMonitorArgs {
            /**
             * If Enable is set to true, a Prometheus ServiceMonitor will be created. Enable can only be set to true if metrics are enabled.
             */
            enable: pulumi.Input<boolean>;
        }

        /**
         * Configuration parameters for the proxy's StatefulSet. Tailscale
         * Kubernetes operator deploys a StatefulSet for each of the user
         * configured proxies (Tailscale Ingress, Tailscale Service, Connector).
         */
        export interface ProxyClassSpecStatefulSetArgs {
            /**
             * Annotations that will be added to the StatefulSet created for the proxy.
             * Any Annotations specified here will be merged with the default annotations
             * applied to the StatefulSet by the Tailscale Kubernetes operator as
             * well as any other annotations that might have been applied by other
             * actors.
             * Annotations must be valid Kubernetes annotations.
             * https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/#syntax-and-character-set
             */
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Labels that will be added to the StatefulSet created for the proxy.
             * Any labels specified here will be merged with the default labels
             * applied to the StatefulSet by the Tailscale Kubernetes operator as
             * well as any other labels that might have been applied by other
             * actors.
             * Label keys and values must be valid Kubernetes label keys and values.
             * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Configuration for the proxy Pod.
             */
            pod?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodArgs>;
        }

        /**
         * Configuration for the proxy Pod.
         */
        export interface ProxyClassSpecStatefulSetPodArgs {
            /**
             * Proxy Pod's affinity rules.
             * By default, the Tailscale Kubernetes operator does not apply any affinity rules.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#affinity
             */
            affinity?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityArgs>;
            /**
             * Annotations that will be added to the proxy Pod.
             * Any annotations specified here will be merged with the default
             * annotations applied to the Pod by the Tailscale Kubernetes operator.
             * Annotations must be valid Kubernetes annotations.
             * https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/#syntax-and-character-set
             */
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Proxy Pod's image pull Secrets.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec
             */
            imagePullSecrets?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodImagePullSecretsArgs>[]>;
            /**
             * Labels that will be added to the proxy Pod.
             * Any labels specified here will be merged with the default labels
             * applied to the Pod by the Tailscale Kubernetes operator.
             * Label keys and values must be valid Kubernetes label keys and values.
             * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Proxy Pod's node name.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#scheduling
             */
            nodeName?: pulumi.Input<string>;
            /**
             * Proxy Pod's node selector.
             * By default Tailscale Kubernetes operator does not apply any node
             * selector.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#scheduling
             */
            nodeSelector?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Proxy Pod's security context.
             * By default Tailscale Kubernetes operator does not apply any Pod
             * security context.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context-2
             */
            securityContext?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodSecurityContextArgs>;
            /**
             * Configuration for the proxy container running tailscale.
             */
            tailscaleContainer?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleContainerArgs>;
            /**
             * Configuration for the proxy init container that enables forwarding.
             */
            tailscaleInitContainer?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleInitContainerArgs>;
            /**
             * Proxy Pod's tolerations.
             * By default Tailscale Kubernetes operator does not apply any
             * tolerations.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#scheduling
             */
            tolerations?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTolerationsArgs>[]>;
            /**
             * Proxy Pod's topology spread constraints.
             * By default Tailscale Kubernetes operator does not apply any topology spread constraints.
             * https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/
             */
            topologySpreadConstraints?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTopologySpreadConstraintsArgs>[]>;
        }

        /**
         * Proxy Pod's affinity rules.
         * By default, the Tailscale Kubernetes operator does not apply any affinity rules.
         * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#affinity
         */
        export interface ProxyClassSpecStatefulSetPodAffinityArgs {
            /**
             * Describes node affinity scheduling rules for the pod.
             */
            nodeAffinity?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityNodeAffinityArgs>;
            /**
             * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
             */
            podAffinity?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAffinityArgs>;
            /**
             * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
             */
            podAntiAffinity?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityArgs>;
        }

        /**
         * Describes node affinity scheduling rules for the pod.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityNodeAffinityArgs {
            /**
             * The scheduler will prefer to schedule pods to nodes that satisfy
             * the affinity expressions specified by this field, but it may choose
             * a node that violates one or more of the expressions. The node that is
             * most preferred is the one with the greatest sum of weights, i.e.
             * for each node that meets all of the scheduling requirements (resource
             * request, requiredDuringScheduling affinity expressions, etc.),
             * compute a sum by iterating through the elements of this field and adding
             * "weight" to the sum if the node matches the corresponding matchExpressions; the
             * node(s) with the highest sum are the most preferred.
             */
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs>[]>;
            /**
             * If the affinity requirements specified by this field are not met at
             * scheduling time, the pod will not be scheduled onto the node.
             * If the affinity requirements specified by this field cease to be met
             * at some point during pod execution (e.g. due to an update), the system
             * may or may not try to eventually evict the pod from its node.
             */
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs>;
        }

        /**
         * An empty preferred scheduling term matches all objects with implicit weight 0
         * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
         */
        export interface ProxyClassSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs {
            /**
             * A node selector term, associated with the corresponding weight.
             */
            preference: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs>;
            /**
             * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
             */
            weight: pulumi.Input<number>;
        }

        /**
         * A node selector term, associated with the corresponding weight.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs {
            /**
             * A list of node selector requirements by node's labels.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs>[]>;
            /**
             * A list of node selector requirements by node's fields.
             */
            matchFields?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs>[]>;
        }

        /**
         * A node selector requirement is a selector that contains values, a key, and an operator
         * that relates the key and values.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs {
            /**
             * The label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * Represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
             */
            operator: pulumi.Input<string>;
            /**
             * An array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. If the operator is Gt or Lt, the values
             * array must have a single element, which will be interpreted as an integer.
             * This array is replaced during a strategic merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A node selector requirement is a selector that contains values, a key, and an operator
         * that relates the key and values.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs {
            /**
             * The label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * Represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
             */
            operator: pulumi.Input<string>;
            /**
             * An array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. If the operator is Gt or Lt, the values
             * array must have a single element, which will be interpreted as an integer.
             * This array is replaced during a strategic merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * If the affinity requirements specified by this field are not met at
         * scheduling time, the pod will not be scheduled onto the node.
         * If the affinity requirements specified by this field cease to be met
         * at some point during pod execution (e.g. due to an update), the system
         * may or may not try to eventually evict the pod from its node.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs {
            /**
             * Required. A list of node selector terms. The terms are ORed.
             */
            nodeSelectorTerms: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs>[]>;
        }

        /**
         * A null or empty node selector term matches no objects. The requirements of
         * them are ANDed.
         * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs {
            /**
             * A list of node selector requirements by node's labels.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs>[]>;
            /**
             * A list of node selector requirements by node's fields.
             */
            matchFields?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs>[]>;
        }

        /**
         * A node selector requirement is a selector that contains values, a key, and an operator
         * that relates the key and values.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs {
            /**
             * The label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * Represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
             */
            operator: pulumi.Input<string>;
            /**
             * An array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. If the operator is Gt or Lt, the values
             * array must have a single element, which will be interpreted as an integer.
             * This array is replaced during a strategic merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A node selector requirement is a selector that contains values, a key, and an operator
         * that relates the key and values.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs {
            /**
             * The label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * Represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
             */
            operator: pulumi.Input<string>;
            /**
             * An array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. If the operator is Gt or Lt, the values
             * array must have a single element, which will be interpreted as an integer.
             * This array is replaced during a strategic merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAffinityArgs {
            /**
             * The scheduler will prefer to schedule pods to nodes that satisfy
             * the affinity expressions specified by this field, but it may choose
             * a node that violates one or more of the expressions. The node that is
             * most preferred is the one with the greatest sum of weights, i.e.
             * for each node that meets all of the scheduling requirements (resource
             * request, requiredDuringScheduling affinity expressions, etc.),
             * compute a sum by iterating through the elements of this field and adding
             * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
             * node(s) with the highest sum are the most preferred.
             */
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs>[]>;
            /**
             * If the affinity requirements specified by this field are not met at
             * scheduling time, the pod will not be scheduled onto the node.
             * If the affinity requirements specified by this field cease to be met
             * at some point during pod execution (e.g. due to a pod label update), the
             * system may or may not try to eventually evict the pod from its node.
             * When there are multiple elements, the lists of nodes corresponding to each
             * podAffinityTerm are intersected, i.e. all terms must be satisfied.
             */
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs>[]>;
        }

        /**
         * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs {
            /**
             * Required. A pod affinity term, associated with the corresponding weight.
             */
            podAffinityTerm: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs>;
            /**
             * weight associated with matching the corresponding podAffinityTerm,
             * in the range 1-100.
             */
            weight: pulumi.Input<number>;
        }

        /**
         * Required. A pod affinity term, associated with the corresponding weight.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs {
            /**
             * A label query over a set of resources, in this case pods.
             * If it's null, this PodAffinityTerm matches with no Pods.
             */
            labelSelector?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs>;
            /**
             * MatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
             * Also, matchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            matchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * MismatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
             * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            mismatchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * A label query over the set of namespaces that the term applies to.
             * The term is applied to the union of the namespaces selected by this field
             * and the ones listed in the namespaces field.
             * null selector and null or empty namespaces list means "this pod's namespace".
             * An empty selector ({}) matches all namespaces.
             */
            namespaceSelector?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs>;
            /**
             * namespaces specifies a static list of namespace names that the term applies to.
             * The term is applied to the union of the namespaces listed in this field
             * and the ones selected by namespaceSelector.
             * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
             */
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
             * the labelSelector in the specified namespaces, where co-located is defined as running on a node
             * whose value of the label with key topologyKey matches that of any node on which any of the
             * selected pods is running.
             * Empty topologyKey is not allowed.
             */
            topologyKey: pulumi.Input<string>;
        }

        /**
         * A label query over a set of resources, in this case pods.
         * If it's null, this PodAffinityTerm matches with no Pods.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label query over the set of namespaces that the term applies to.
         * The term is applied to the union of the namespaces selected by this field
         * and the ones listed in the namespaces field.
         * null selector and null or empty namespaces list means "this pod's namespace".
         * An empty selector ({}) matches all namespaces.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Defines a set of pods (namely those matching the labelSelector
         * relative to the given namespace(s)) that this pod should be
         * co-located (affinity) or not co-located (anti-affinity) with,
         * where co-located is defined as running on a node whose value of
         * the label with key <topologyKey> matches that of any node on which
         * a pod of the set of pods is running
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs {
            /**
             * A label query over a set of resources, in this case pods.
             * If it's null, this PodAffinityTerm matches with no Pods.
             */
            labelSelector?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs>;
            /**
             * MatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
             * Also, matchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            matchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * MismatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
             * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            mismatchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * A label query over the set of namespaces that the term applies to.
             * The term is applied to the union of the namespaces selected by this field
             * and the ones listed in the namespaces field.
             * null selector and null or empty namespaces list means "this pod's namespace".
             * An empty selector ({}) matches all namespaces.
             */
            namespaceSelector?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs>;
            /**
             * namespaces specifies a static list of namespace names that the term applies to.
             * The term is applied to the union of the namespaces listed in this field
             * and the ones selected by namespaceSelector.
             * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
             */
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
             * the labelSelector in the specified namespaces, where co-located is defined as running on a node
             * whose value of the label with key topologyKey matches that of any node on which any of the
             * selected pods is running.
             * Empty topologyKey is not allowed.
             */
            topologyKey: pulumi.Input<string>;
        }

        /**
         * A label query over a set of resources, in this case pods.
         * If it's null, this PodAffinityTerm matches with no Pods.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label query over the set of namespaces that the term applies to.
         * The term is applied to the union of the namespaces selected by this field
         * and the ones listed in the namespaces field.
         * null selector and null or empty namespaces list means "this pod's namespace".
         * An empty selector ({}) matches all namespaces.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityArgs {
            /**
             * The scheduler will prefer to schedule pods to nodes that satisfy
             * the anti-affinity expressions specified by this field, but it may choose
             * a node that violates one or more of the expressions. The node that is
             * most preferred is the one with the greatest sum of weights, i.e.
             * for each node that meets all of the scheduling requirements (resource
             * request, requiredDuringScheduling anti-affinity expressions, etc.),
             * compute a sum by iterating through the elements of this field and adding
             * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
             * node(s) with the highest sum are the most preferred.
             */
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs>[]>;
            /**
             * If the anti-affinity requirements specified by this field are not met at
             * scheduling time, the pod will not be scheduled onto the node.
             * If the anti-affinity requirements specified by this field cease to be met
             * at some point during pod execution (e.g. due to a pod label update), the
             * system may or may not try to eventually evict the pod from its node.
             * When there are multiple elements, the lists of nodes corresponding to each
             * podAffinityTerm are intersected, i.e. all terms must be satisfied.
             */
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs>[]>;
        }

        /**
         * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs {
            /**
             * Required. A pod affinity term, associated with the corresponding weight.
             */
            podAffinityTerm: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs>;
            /**
             * weight associated with matching the corresponding podAffinityTerm,
             * in the range 1-100.
             */
            weight: pulumi.Input<number>;
        }

        /**
         * Required. A pod affinity term, associated with the corresponding weight.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs {
            /**
             * A label query over a set of resources, in this case pods.
             * If it's null, this PodAffinityTerm matches with no Pods.
             */
            labelSelector?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs>;
            /**
             * MatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
             * Also, matchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            matchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * MismatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
             * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            mismatchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * A label query over the set of namespaces that the term applies to.
             * The term is applied to the union of the namespaces selected by this field
             * and the ones listed in the namespaces field.
             * null selector and null or empty namespaces list means "this pod's namespace".
             * An empty selector ({}) matches all namespaces.
             */
            namespaceSelector?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs>;
            /**
             * namespaces specifies a static list of namespace names that the term applies to.
             * The term is applied to the union of the namespaces listed in this field
             * and the ones selected by namespaceSelector.
             * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
             */
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
             * the labelSelector in the specified namespaces, where co-located is defined as running on a node
             * whose value of the label with key topologyKey matches that of any node on which any of the
             * selected pods is running.
             * Empty topologyKey is not allowed.
             */
            topologyKey: pulumi.Input<string>;
        }

        /**
         * A label query over a set of resources, in this case pods.
         * If it's null, this PodAffinityTerm matches with no Pods.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label query over the set of namespaces that the term applies to.
         * The term is applied to the union of the namespaces selected by this field
         * and the ones listed in the namespaces field.
         * null selector and null or empty namespaces list means "this pod's namespace".
         * An empty selector ({}) matches all namespaces.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Defines a set of pods (namely those matching the labelSelector
         * relative to the given namespace(s)) that this pod should be
         * co-located (affinity) or not co-located (anti-affinity) with,
         * where co-located is defined as running on a node whose value of
         * the label with key <topologyKey> matches that of any node on which
         * a pod of the set of pods is running
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs {
            /**
             * A label query over a set of resources, in this case pods.
             * If it's null, this PodAffinityTerm matches with no Pods.
             */
            labelSelector?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs>;
            /**
             * MatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
             * Also, matchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            matchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * MismatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
             * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            mismatchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * A label query over the set of namespaces that the term applies to.
             * The term is applied to the union of the namespaces selected by this field
             * and the ones listed in the namespaces field.
             * null selector and null or empty namespaces list means "this pod's namespace".
             * An empty selector ({}) matches all namespaces.
             */
            namespaceSelector?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs>;
            /**
             * namespaces specifies a static list of namespace names that the term applies to.
             * The term is applied to the union of the namespaces listed in this field
             * and the ones selected by namespaceSelector.
             * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
             */
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
             * the labelSelector in the specified namespaces, where co-located is defined as running on a node
             * whose value of the label with key topologyKey matches that of any node on which any of the
             * selected pods is running.
             * Empty topologyKey is not allowed.
             */
            topologyKey: pulumi.Input<string>;
        }

        /**
         * A label query over a set of resources, in this case pods.
         * If it's null, this PodAffinityTerm matches with no Pods.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label query over the set of namespaces that the term applies to.
         * The term is applied to the union of the namespaces selected by this field
         * and the ones listed in the namespaces field.
         * null selector and null or empty namespaces list means "this pod's namespace".
         * An empty selector ({}) matches all namespaces.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * LocalObjectReference contains enough information to let you locate the
         * referenced object inside the same namespace.
         */
        export interface ProxyClassSpecStatefulSetPodImagePullSecretsArgs {
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
        }
        /**
         * proxyClassSpecStatefulSetPodImagePullSecretsArgsProvideDefaults sets the appropriate defaults for ProxyClassSpecStatefulSetPodImagePullSecretsArgs
         */
        export function proxyClassSpecStatefulSetPodImagePullSecretsArgsProvideDefaults(val: ProxyClassSpecStatefulSetPodImagePullSecretsArgs): ProxyClassSpecStatefulSetPodImagePullSecretsArgs {
            return {
                ...val,
                name: (val.name) ?? "",
            };
        }

        /**
         * Proxy Pod's security context.
         * By default Tailscale Kubernetes operator does not apply any Pod
         * security context.
         * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context-2
         */
        export interface ProxyClassSpecStatefulSetPodSecurityContextArgs {
            /**
             * appArmorProfile is the AppArmor options to use by the containers in this pod.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            appArmorProfile?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodSecurityContextAppArmorProfileArgs>;
            /**
             * A special supplemental group that applies to all containers in a pod.
             * Some volume types allow the Kubelet to change the ownership of that volume
             * to be owned by the pod:
             *
             * 1. The owning GID will be the FSGroup
             * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
             * 3. The permission bits are OR'd with rw-rw----
             *
             * If unset, the Kubelet will not modify the ownership and permissions of any volume.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            fsGroup?: pulumi.Input<number>;
            /**
             * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
             * before being exposed inside Pod. This field will only apply to
             * volume types which support fsGroup based ownership(and permissions).
             * It will have no effect on ephemeral volume types such as: secret, configmaps
             * and emptydir.
             * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            fsGroupChangePolicy?: pulumi.Input<string>;
            /**
             * The GID to run the entrypoint of the container process.
             * Uses runtime default if unset.
             * May also be set in SecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence
             * for that container.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsGroup?: pulumi.Input<number>;
            /**
             * Indicates that the container must run as a non-root user.
             * If true, the Kubelet will validate the image at runtime to ensure that it
             * does not run as UID 0 (root) and fail to start the container if it does.
             * If unset or false, no such validation will be performed.
             * May also be set in SecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsNonRoot?: pulumi.Input<boolean>;
            /**
             * The UID to run the entrypoint of the container process.
             * Defaults to user specified in image metadata if unspecified.
             * May also be set in SecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence
             * for that container.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsUser?: pulumi.Input<number>;
            /**
             * The SELinux context to be applied to all containers.
             * If unspecified, the container runtime will allocate a random SELinux context for each
             * container.  May also be set in SecurityContext.  If set in
             * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
             * takes precedence for that container.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            seLinuxOptions?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodSecurityContextSeLinuxOptionsArgs>;
            /**
             * The seccomp options to use by the containers in this pod.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            seccompProfile?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodSecurityContextSeccompProfileArgs>;
            /**
             * A list of groups applied to the first process run in each container, in addition
             * to the container's primary GID, the fsGroup (if specified), and group memberships
             * defined in the container image for the uid of the container process. If unspecified,
             * no additional groups are added to any container. Note that group memberships
             * defined in the container image for the uid of the container process are still effective,
             * even if they are not included in this list.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            supplementalGroups?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
             * sysctls (by the container runtime) might fail to launch.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            sysctls?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodSecurityContextSysctlsArgs>[]>;
            /**
             * The Windows specific settings applied to all containers.
             * If unspecified, the options within a container's SecurityContext will be used.
             * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is linux.
             */
            windowsOptions?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodSecurityContextWindowsOptionsArgs>;
        }

        /**
         * appArmorProfile is the AppArmor options to use by the containers in this pod.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface ProxyClassSpecStatefulSetPodSecurityContextAppArmorProfileArgs {
            /**
             * localhostProfile indicates a profile loaded on the node that should be used.
             * The profile must be preconfigured on the node to work.
             * Must match the loaded name of the profile.
             * Must be set if and only if type is "Localhost".
             */
            localhostProfile?: pulumi.Input<string>;
            /**
             * type indicates which kind of AppArmor profile will be applied.
             * Valid options are:
             *   Localhost - a profile pre-loaded on the node.
             *   RuntimeDefault - the container runtime's default profile.
             *   Unconfined - no AppArmor enforcement.
             */
            type: pulumi.Input<string>;
        }

        /**
         * The SELinux context to be applied to all containers.
         * If unspecified, the container runtime will allocate a random SELinux context for each
         * container.  May also be set in SecurityContext.  If set in
         * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
         * takes precedence for that container.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface ProxyClassSpecStatefulSetPodSecurityContextSeLinuxOptionsArgs {
            /**
             * Level is SELinux level label that applies to the container.
             */
            level?: pulumi.Input<string>;
            /**
             * Role is a SELinux role label that applies to the container.
             */
            role?: pulumi.Input<string>;
            /**
             * Type is a SELinux type label that applies to the container.
             */
            type?: pulumi.Input<string>;
            /**
             * User is a SELinux user label that applies to the container.
             */
            user?: pulumi.Input<string>;
        }

        /**
         * The seccomp options to use by the containers in this pod.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface ProxyClassSpecStatefulSetPodSecurityContextSeccompProfileArgs {
            /**
             * localhostProfile indicates a profile defined in a file on the node should be used.
             * The profile must be preconfigured on the node to work.
             * Must be a descending path, relative to the kubelet's configured seccomp profile location.
             * Must be set if type is "Localhost". Must NOT be set for any other type.
             */
            localhostProfile?: pulumi.Input<string>;
            /**
             * type indicates which kind of seccomp profile will be applied.
             * Valid options are:
             *
             * Localhost - a profile defined in a file on the node should be used.
             * RuntimeDefault - the container runtime default profile should be used.
             * Unconfined - no profile should be applied.
             */
            type: pulumi.Input<string>;
        }

        /**
         * Sysctl defines a kernel parameter to be set
         */
        export interface ProxyClassSpecStatefulSetPodSecurityContextSysctlsArgs {
            /**
             * Name of a property to set
             */
            name: pulumi.Input<string>;
            /**
             * Value of a property to set
             */
            value: pulumi.Input<string>;
        }

        /**
         * The Windows specific settings applied to all containers.
         * If unspecified, the options within a container's SecurityContext will be used.
         * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
         * Note that this field cannot be set when spec.os.name is linux.
         */
        export interface ProxyClassSpecStatefulSetPodSecurityContextWindowsOptionsArgs {
            /**
             * GMSACredentialSpec is where the GMSA admission webhook
             * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
             * GMSA credential spec named by the GMSACredentialSpecName field.
             */
            gmsaCredentialSpec?: pulumi.Input<string>;
            /**
             * GMSACredentialSpecName is the name of the GMSA credential spec to use.
             */
            gmsaCredentialSpecName?: pulumi.Input<string>;
            /**
             * HostProcess determines if a container should be run as a 'Host Process' container.
             * All of a Pod's containers must have the same effective HostProcess value
             * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
             * In addition, if HostProcess is true then HostNetwork must also be set to true.
             */
            hostProcess?: pulumi.Input<boolean>;
            /**
             * The UserName in Windows to run the entrypoint of the container process.
             * Defaults to the user specified in image metadata if unspecified.
             * May also be set in PodSecurityContext. If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsUserName?: pulumi.Input<string>;
        }

        /**
         * Configuration for the proxy container running tailscale.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleContainerArgs {
            /**
             * Configuration for enabling extra debug information in the container.
             * Not recommended for production use.
             */
            debug?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleContainerDebugArgs>;
            /**
             * List of environment variables to set in the container.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#environment-variables
             * Note that environment variables provided here will take precedence
             * over Tailscale-specific environment variables set by the operator,
             * however running proxies with custom values for Tailscale environment
             * variables (i.e TS_USERSPACE) is not recommended and might break in
             * the future.
             */
            env?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleContainerEnvArgs>[]>;
            /**
             * Container image name. By default images are pulled from
             * docker.io/tailscale/tailscale, but the official images are also
             * available at ghcr.io/tailscale/tailscale. Specifying image name here
             * will override any proxy image values specified via the Kubernetes
             * operator's Helm chart values or PROXY_IMAGE env var in the operator
             * Deployment.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#image
             */
            image?: pulumi.Input<string>;
            /**
             * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#image
             */
            imagePullPolicy?: pulumi.Input<string>;
            /**
             * Container resource requirements.
             * By default Tailscale Kubernetes operator does not apply any resource
             * requirements. The amount of resources required wil depend on the
             * amount of resources the operator needs to parse, usage patterns and
             * cluster size.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#resources
             */
            resources?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleContainerResourcesArgs>;
            /**
             * Container security context.
             * Security context specified here will override the security context set by the operator.
             * By default the operator sets the Tailscale container and the Tailscale init container to privileged
             * for proxies created for Tailscale ingress and egress Service, Connector and ProxyGroup.
             * You can reduce the permissions of the Tailscale container to cap NET_ADMIN by
             * installing device plugin in your cluster and configuring the proxies tun device to be created
             * by the device plugin, see  https://github.com/tailscale/tailscale/issues/10814#issuecomment-2479977752
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context
             */
            securityContext?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleContainerSecurityContextArgs>;
        }

        /**
         * Configuration for enabling extra debug information in the container.
         * Not recommended for production use.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleContainerDebugArgs {
            /**
             * Enable tailscaled's HTTP pprof endpoints at <pod-ip>:9001/debug/pprof/
             * and internal debug metrics endpoint at <pod-ip>:9001/debug/metrics, where
             * 9001 is a container port named "debug". The endpoints and their responses
             * may change in backwards incompatible ways in the future, and should not
             * be considered stable.
             *
             * In 1.78.x and 1.80.x, this setting will default to the value of
             * .spec.metrics.enable, and requests to the "metrics" port matching the
             * mux pattern /debug/ will be forwarded to the "debug" port. In 1.82.x,
             * this setting will default to false, and no requests will be proxied.
             */
            enable?: pulumi.Input<boolean>;
        }

        export interface ProxyClassSpecStatefulSetPodTailscaleContainerEnvArgs {
            /**
             * Name of the environment variable. Must be a C_IDENTIFIER.
             */
            name: pulumi.Input<string>;
            /**
             * Variable references $(VAR_NAME) are expanded using the previously defined
             *  environment variables in the container and any service environment
             * variables. If a variable cannot be resolved, the reference in the input
             * string will be unchanged. Double $$ are reduced to a single $, which
             * allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
             * produce the string literal "$(VAR_NAME)". Escaped references will never
             * be expanded, regardless of whether the variable exists or not. Defaults
             * to "".
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Container resource requirements.
         * By default Tailscale Kubernetes operator does not apply any resource
         * requirements. The amount of resources required wil depend on the
         * amount of resources the operator needs to parse, usage patterns and
         * cluster size.
         * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#resources
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleContainerResourcesArgs {
            /**
             * Claims lists the names of resources, defined in spec.resourceClaims,
             * that are used by this container.
             *
             * This is an alpha field and requires enabling the
             * DynamicResourceAllocation feature gate.
             *
             * This field is immutable. It can only be set for containers.
             */
            claims?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleContainerResourcesClaimsArgs>[]>;
            /**
             * Limits describes the maximum amount of compute resources allowed.
             * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
             */
            limits?: pulumi.Input<{[key: string]: pulumi.Input<number | string>}>;
            /**
             * Requests describes the minimum amount of compute resources required.
             * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
             * otherwise to an implementation-defined value. Requests cannot exceed Limits.
             * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
             */
            requests?: pulumi.Input<{[key: string]: pulumi.Input<number | string>}>;
        }

        /**
         * ResourceClaim references one entry in PodSpec.ResourceClaims.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleContainerResourcesClaimsArgs {
            /**
             * Name must match the name of one entry in pod.spec.resourceClaims of
             * the Pod where this field is used. It makes that resource available
             * inside a container.
             */
            name: pulumi.Input<string>;
        }

        /**
         * Container security context.
         * Security context specified here will override the security context set by the operator.
         * By default the operator sets the Tailscale container and the Tailscale init container to privileged
         * for proxies created for Tailscale ingress and egress Service, Connector and ProxyGroup.
         * You can reduce the permissions of the Tailscale container to cap NET_ADMIN by
         * installing device plugin in your cluster and configuring the proxies tun device to be created
         * by the device plugin, see  https://github.com/tailscale/tailscale/issues/10814#issuecomment-2479977752
         * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleContainerSecurityContextArgs {
            /**
             * AllowPrivilegeEscalation controls whether a process can gain more
             * privileges than its parent process. This bool directly controls if
             * the no_new_privs flag will be set on the container process.
             * AllowPrivilegeEscalation is true always when the container is:
             * 1) run as Privileged
             * 2) has CAP_SYS_ADMIN
             * Note that this field cannot be set when spec.os.name is windows.
             */
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            /**
             * appArmorProfile is the AppArmor options to use by this container. If set, this profile
             * overrides the pod's appArmorProfile.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            appArmorProfile?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleContainerSecurityContextAppArmorProfileArgs>;
            /**
             * The capabilities to add/drop when running containers.
             * Defaults to the default set of capabilities granted by the container runtime.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            capabilities?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleContainerSecurityContextCapabilitiesArgs>;
            /**
             * Run container in privileged mode.
             * Processes in privileged containers are essentially equivalent to root on the host.
             * Defaults to false.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            privileged?: pulumi.Input<boolean>;
            /**
             * procMount denotes the type of proc mount to use for the containers.
             * The default is DefaultProcMount which uses the container runtime defaults for
             * readonly paths and masked paths.
             * This requires the ProcMountType feature flag to be enabled.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            procMount?: pulumi.Input<string>;
            /**
             * Whether this container has a read-only root filesystem.
             * Default is false.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            /**
             * The GID to run the entrypoint of the container process.
             * Uses runtime default if unset.
             * May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsGroup?: pulumi.Input<number>;
            /**
             * Indicates that the container must run as a non-root user.
             * If true, the Kubelet will validate the image at runtime to ensure that it
             * does not run as UID 0 (root) and fail to start the container if it does.
             * If unset or false, no such validation will be performed.
             * May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsNonRoot?: pulumi.Input<boolean>;
            /**
             * The UID to run the entrypoint of the container process.
             * Defaults to user specified in image metadata if unspecified.
             * May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsUser?: pulumi.Input<number>;
            /**
             * The SELinux context to be applied to the container.
             * If unspecified, the container runtime will allocate a random SELinux context for each
             * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            seLinuxOptions?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleContainerSecurityContextSeLinuxOptionsArgs>;
            /**
             * The seccomp options to use by this container. If seccomp options are
             * provided at both the pod & container level, the container options
             * override the pod options.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            seccompProfile?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleContainerSecurityContextSeccompProfileArgs>;
            /**
             * The Windows specific settings applied to all containers.
             * If unspecified, the options from the PodSecurityContext will be used.
             * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is linux.
             */
            windowsOptions?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleContainerSecurityContextWindowsOptionsArgs>;
        }

        /**
         * appArmorProfile is the AppArmor options to use by this container. If set, this profile
         * overrides the pod's appArmorProfile.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleContainerSecurityContextAppArmorProfileArgs {
            /**
             * localhostProfile indicates a profile loaded on the node that should be used.
             * The profile must be preconfigured on the node to work.
             * Must match the loaded name of the profile.
             * Must be set if and only if type is "Localhost".
             */
            localhostProfile?: pulumi.Input<string>;
            /**
             * type indicates which kind of AppArmor profile will be applied.
             * Valid options are:
             *   Localhost - a profile pre-loaded on the node.
             *   RuntimeDefault - the container runtime's default profile.
             *   Unconfined - no AppArmor enforcement.
             */
            type: pulumi.Input<string>;
        }

        /**
         * The capabilities to add/drop when running containers.
         * Defaults to the default set of capabilities granted by the container runtime.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleContainerSecurityContextCapabilitiesArgs {
            /**
             * Added capabilities
             */
            add?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Removed capabilities
             */
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * The SELinux context to be applied to the container.
         * If unspecified, the container runtime will allocate a random SELinux context for each
         * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
         * PodSecurityContext, the value specified in SecurityContext takes precedence.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleContainerSecurityContextSeLinuxOptionsArgs {
            /**
             * Level is SELinux level label that applies to the container.
             */
            level?: pulumi.Input<string>;
            /**
             * Role is a SELinux role label that applies to the container.
             */
            role?: pulumi.Input<string>;
            /**
             * Type is a SELinux type label that applies to the container.
             */
            type?: pulumi.Input<string>;
            /**
             * User is a SELinux user label that applies to the container.
             */
            user?: pulumi.Input<string>;
        }

        /**
         * The seccomp options to use by this container. If seccomp options are
         * provided at both the pod & container level, the container options
         * override the pod options.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleContainerSecurityContextSeccompProfileArgs {
            /**
             * localhostProfile indicates a profile defined in a file on the node should be used.
             * The profile must be preconfigured on the node to work.
             * Must be a descending path, relative to the kubelet's configured seccomp profile location.
             * Must be set if type is "Localhost". Must NOT be set for any other type.
             */
            localhostProfile?: pulumi.Input<string>;
            /**
             * type indicates which kind of seccomp profile will be applied.
             * Valid options are:
             *
             * Localhost - a profile defined in a file on the node should be used.
             * RuntimeDefault - the container runtime default profile should be used.
             * Unconfined - no profile should be applied.
             */
            type: pulumi.Input<string>;
        }

        /**
         * The Windows specific settings applied to all containers.
         * If unspecified, the options from the PodSecurityContext will be used.
         * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
         * Note that this field cannot be set when spec.os.name is linux.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleContainerSecurityContextWindowsOptionsArgs {
            /**
             * GMSACredentialSpec is where the GMSA admission webhook
             * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
             * GMSA credential spec named by the GMSACredentialSpecName field.
             */
            gmsaCredentialSpec?: pulumi.Input<string>;
            /**
             * GMSACredentialSpecName is the name of the GMSA credential spec to use.
             */
            gmsaCredentialSpecName?: pulumi.Input<string>;
            /**
             * HostProcess determines if a container should be run as a 'Host Process' container.
             * All of a Pod's containers must have the same effective HostProcess value
             * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
             * In addition, if HostProcess is true then HostNetwork must also be set to true.
             */
            hostProcess?: pulumi.Input<boolean>;
            /**
             * The UserName in Windows to run the entrypoint of the container process.
             * Defaults to the user specified in image metadata if unspecified.
             * May also be set in PodSecurityContext. If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsUserName?: pulumi.Input<string>;
        }

        /**
         * Configuration for the proxy init container that enables forwarding.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleInitContainerArgs {
            /**
             * Configuration for enabling extra debug information in the container.
             * Not recommended for production use.
             */
            debug?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleInitContainerDebugArgs>;
            /**
             * List of environment variables to set in the container.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#environment-variables
             * Note that environment variables provided here will take precedence
             * over Tailscale-specific environment variables set by the operator,
             * however running proxies with custom values for Tailscale environment
             * variables (i.e TS_USERSPACE) is not recommended and might break in
             * the future.
             */
            env?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleInitContainerEnvArgs>[]>;
            /**
             * Container image name. By default images are pulled from
             * docker.io/tailscale/tailscale, but the official images are also
             * available at ghcr.io/tailscale/tailscale. Specifying image name here
             * will override any proxy image values specified via the Kubernetes
             * operator's Helm chart values or PROXY_IMAGE env var in the operator
             * Deployment.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#image
             */
            image?: pulumi.Input<string>;
            /**
             * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#image
             */
            imagePullPolicy?: pulumi.Input<string>;
            /**
             * Container resource requirements.
             * By default Tailscale Kubernetes operator does not apply any resource
             * requirements. The amount of resources required wil depend on the
             * amount of resources the operator needs to parse, usage patterns and
             * cluster size.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#resources
             */
            resources?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleInitContainerResourcesArgs>;
            /**
             * Container security context.
             * Security context specified here will override the security context set by the operator.
             * By default the operator sets the Tailscale container and the Tailscale init container to privileged
             * for proxies created for Tailscale ingress and egress Service, Connector and ProxyGroup.
             * You can reduce the permissions of the Tailscale container to cap NET_ADMIN by
             * installing device plugin in your cluster and configuring the proxies tun device to be created
             * by the device plugin, see  https://github.com/tailscale/tailscale/issues/10814#issuecomment-2479977752
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context
             */
            securityContext?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleInitContainerSecurityContextArgs>;
        }

        /**
         * Configuration for enabling extra debug information in the container.
         * Not recommended for production use.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleInitContainerDebugArgs {
            /**
             * Enable tailscaled's HTTP pprof endpoints at <pod-ip>:9001/debug/pprof/
             * and internal debug metrics endpoint at <pod-ip>:9001/debug/metrics, where
             * 9001 is a container port named "debug". The endpoints and their responses
             * may change in backwards incompatible ways in the future, and should not
             * be considered stable.
             *
             * In 1.78.x and 1.80.x, this setting will default to the value of
             * .spec.metrics.enable, and requests to the "metrics" port matching the
             * mux pattern /debug/ will be forwarded to the "debug" port. In 1.82.x,
             * this setting will default to false, and no requests will be proxied.
             */
            enable?: pulumi.Input<boolean>;
        }

        export interface ProxyClassSpecStatefulSetPodTailscaleInitContainerEnvArgs {
            /**
             * Name of the environment variable. Must be a C_IDENTIFIER.
             */
            name: pulumi.Input<string>;
            /**
             * Variable references $(VAR_NAME) are expanded using the previously defined
             *  environment variables in the container and any service environment
             * variables. If a variable cannot be resolved, the reference in the input
             * string will be unchanged. Double $$ are reduced to a single $, which
             * allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
             * produce the string literal "$(VAR_NAME)". Escaped references will never
             * be expanded, regardless of whether the variable exists or not. Defaults
             * to "".
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Container resource requirements.
         * By default Tailscale Kubernetes operator does not apply any resource
         * requirements. The amount of resources required wil depend on the
         * amount of resources the operator needs to parse, usage patterns and
         * cluster size.
         * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#resources
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleInitContainerResourcesArgs {
            /**
             * Claims lists the names of resources, defined in spec.resourceClaims,
             * that are used by this container.
             *
             * This is an alpha field and requires enabling the
             * DynamicResourceAllocation feature gate.
             *
             * This field is immutable. It can only be set for containers.
             */
            claims?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleInitContainerResourcesClaimsArgs>[]>;
            /**
             * Limits describes the maximum amount of compute resources allowed.
             * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
             */
            limits?: pulumi.Input<{[key: string]: pulumi.Input<number | string>}>;
            /**
             * Requests describes the minimum amount of compute resources required.
             * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
             * otherwise to an implementation-defined value. Requests cannot exceed Limits.
             * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
             */
            requests?: pulumi.Input<{[key: string]: pulumi.Input<number | string>}>;
        }

        /**
         * ResourceClaim references one entry in PodSpec.ResourceClaims.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleInitContainerResourcesClaimsArgs {
            /**
             * Name must match the name of one entry in pod.spec.resourceClaims of
             * the Pod where this field is used. It makes that resource available
             * inside a container.
             */
            name: pulumi.Input<string>;
        }

        /**
         * Container security context.
         * Security context specified here will override the security context set by the operator.
         * By default the operator sets the Tailscale container and the Tailscale init container to privileged
         * for proxies created for Tailscale ingress and egress Service, Connector and ProxyGroup.
         * You can reduce the permissions of the Tailscale container to cap NET_ADMIN by
         * installing device plugin in your cluster and configuring the proxies tun device to be created
         * by the device plugin, see  https://github.com/tailscale/tailscale/issues/10814#issuecomment-2479977752
         * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleInitContainerSecurityContextArgs {
            /**
             * AllowPrivilegeEscalation controls whether a process can gain more
             * privileges than its parent process. This bool directly controls if
             * the no_new_privs flag will be set on the container process.
             * AllowPrivilegeEscalation is true always when the container is:
             * 1) run as Privileged
             * 2) has CAP_SYS_ADMIN
             * Note that this field cannot be set when spec.os.name is windows.
             */
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            /**
             * appArmorProfile is the AppArmor options to use by this container. If set, this profile
             * overrides the pod's appArmorProfile.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            appArmorProfile?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleInitContainerSecurityContextAppArmorProfileArgs>;
            /**
             * The capabilities to add/drop when running containers.
             * Defaults to the default set of capabilities granted by the container runtime.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            capabilities?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleInitContainerSecurityContextCapabilitiesArgs>;
            /**
             * Run container in privileged mode.
             * Processes in privileged containers are essentially equivalent to root on the host.
             * Defaults to false.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            privileged?: pulumi.Input<boolean>;
            /**
             * procMount denotes the type of proc mount to use for the containers.
             * The default is DefaultProcMount which uses the container runtime defaults for
             * readonly paths and masked paths.
             * This requires the ProcMountType feature flag to be enabled.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            procMount?: pulumi.Input<string>;
            /**
             * Whether this container has a read-only root filesystem.
             * Default is false.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            /**
             * The GID to run the entrypoint of the container process.
             * Uses runtime default if unset.
             * May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsGroup?: pulumi.Input<number>;
            /**
             * Indicates that the container must run as a non-root user.
             * If true, the Kubelet will validate the image at runtime to ensure that it
             * does not run as UID 0 (root) and fail to start the container if it does.
             * If unset or false, no such validation will be performed.
             * May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsNonRoot?: pulumi.Input<boolean>;
            /**
             * The UID to run the entrypoint of the container process.
             * Defaults to user specified in image metadata if unspecified.
             * May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsUser?: pulumi.Input<number>;
            /**
             * The SELinux context to be applied to the container.
             * If unspecified, the container runtime will allocate a random SELinux context for each
             * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            seLinuxOptions?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleInitContainerSecurityContextSeLinuxOptionsArgs>;
            /**
             * The seccomp options to use by this container. If seccomp options are
             * provided at both the pod & container level, the container options
             * override the pod options.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            seccompProfile?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleInitContainerSecurityContextSeccompProfileArgs>;
            /**
             * The Windows specific settings applied to all containers.
             * If unspecified, the options from the PodSecurityContext will be used.
             * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is linux.
             */
            windowsOptions?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleInitContainerSecurityContextWindowsOptionsArgs>;
        }

        /**
         * appArmorProfile is the AppArmor options to use by this container. If set, this profile
         * overrides the pod's appArmorProfile.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleInitContainerSecurityContextAppArmorProfileArgs {
            /**
             * localhostProfile indicates a profile loaded on the node that should be used.
             * The profile must be preconfigured on the node to work.
             * Must match the loaded name of the profile.
             * Must be set if and only if type is "Localhost".
             */
            localhostProfile?: pulumi.Input<string>;
            /**
             * type indicates which kind of AppArmor profile will be applied.
             * Valid options are:
             *   Localhost - a profile pre-loaded on the node.
             *   RuntimeDefault - the container runtime's default profile.
             *   Unconfined - no AppArmor enforcement.
             */
            type: pulumi.Input<string>;
        }

        /**
         * The capabilities to add/drop when running containers.
         * Defaults to the default set of capabilities granted by the container runtime.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleInitContainerSecurityContextCapabilitiesArgs {
            /**
             * Added capabilities
             */
            add?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Removed capabilities
             */
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * The SELinux context to be applied to the container.
         * If unspecified, the container runtime will allocate a random SELinux context for each
         * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
         * PodSecurityContext, the value specified in SecurityContext takes precedence.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleInitContainerSecurityContextSeLinuxOptionsArgs {
            /**
             * Level is SELinux level label that applies to the container.
             */
            level?: pulumi.Input<string>;
            /**
             * Role is a SELinux role label that applies to the container.
             */
            role?: pulumi.Input<string>;
            /**
             * Type is a SELinux type label that applies to the container.
             */
            type?: pulumi.Input<string>;
            /**
             * User is a SELinux user label that applies to the container.
             */
            user?: pulumi.Input<string>;
        }

        /**
         * The seccomp options to use by this container. If seccomp options are
         * provided at both the pod & container level, the container options
         * override the pod options.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleInitContainerSecurityContextSeccompProfileArgs {
            /**
             * localhostProfile indicates a profile defined in a file on the node should be used.
             * The profile must be preconfigured on the node to work.
             * Must be a descending path, relative to the kubelet's configured seccomp profile location.
             * Must be set if type is "Localhost". Must NOT be set for any other type.
             */
            localhostProfile?: pulumi.Input<string>;
            /**
             * type indicates which kind of seccomp profile will be applied.
             * Valid options are:
             *
             * Localhost - a profile defined in a file on the node should be used.
             * RuntimeDefault - the container runtime default profile should be used.
             * Unconfined - no profile should be applied.
             */
            type: pulumi.Input<string>;
        }

        /**
         * The Windows specific settings applied to all containers.
         * If unspecified, the options from the PodSecurityContext will be used.
         * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
         * Note that this field cannot be set when spec.os.name is linux.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleInitContainerSecurityContextWindowsOptionsArgs {
            /**
             * GMSACredentialSpec is where the GMSA admission webhook
             * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
             * GMSA credential spec named by the GMSACredentialSpecName field.
             */
            gmsaCredentialSpec?: pulumi.Input<string>;
            /**
             * GMSACredentialSpecName is the name of the GMSA credential spec to use.
             */
            gmsaCredentialSpecName?: pulumi.Input<string>;
            /**
             * HostProcess determines if a container should be run as a 'Host Process' container.
             * All of a Pod's containers must have the same effective HostProcess value
             * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
             * In addition, if HostProcess is true then HostNetwork must also be set to true.
             */
            hostProcess?: pulumi.Input<boolean>;
            /**
             * The UserName in Windows to run the entrypoint of the container process.
             * Defaults to the user specified in image metadata if unspecified.
             * May also be set in PodSecurityContext. If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsUserName?: pulumi.Input<string>;
        }

        /**
         * The pod this Toleration is attached to tolerates any taint that matches
         * the triple <key,value,effect> using the matching operator <operator>.
         */
        export interface ProxyClassSpecStatefulSetPodTolerationsArgs {
            /**
             * Effect indicates the taint effect to match. Empty means match all taint effects.
             * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
             */
            effect?: pulumi.Input<string>;
            /**
             * Key is the taint key that the toleration applies to. Empty means match all taint keys.
             * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
             */
            key?: pulumi.Input<string>;
            /**
             * Operator represents a key's relationship to the value.
             * Valid operators are Exists and Equal. Defaults to Equal.
             * Exists is equivalent to wildcard for value, so that a pod can
             * tolerate all taints of a particular category.
             */
            operator?: pulumi.Input<string>;
            /**
             * TolerationSeconds represents the period of time the toleration (which must be
             * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
             * it is not set, which means tolerate the taint forever (do not evict). Zero and
             * negative values will be treated as 0 (evict immediately) by the system.
             */
            tolerationSeconds?: pulumi.Input<number>;
            /**
             * Value is the taint value the toleration matches to.
             * If the operator is Exists, the value should be empty, otherwise just a regular string.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
         */
        export interface ProxyClassSpecStatefulSetPodTopologySpreadConstraintsArgs {
            /**
             * LabelSelector is used to find matching pods.
             * Pods that match this label selector are counted to determine the number of pods
             * in their corresponding topology domain.
             */
            labelSelector?: pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTopologySpreadConstraintsLabelSelectorArgs>;
            /**
             * MatchLabelKeys is a set of pod label keys to select the pods over which
             * spreading will be calculated. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are ANDed with labelSelector
             * to select the group of existing pods over which spreading will be calculated
             * for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
             * MatchLabelKeys cannot be set when LabelSelector isn't set.
             * Keys that don't exist in the incoming pod labels will
             * be ignored. A null or empty list means only match against labelSelector.
             *
             * This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
             */
            matchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * MaxSkew describes the degree to which pods may be unevenly distributed.
             * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
             * between the number of matching pods in the target topology and the global minimum.
             * The global minimum is the minimum number of matching pods in an eligible domain
             * or zero if the number of eligible domains is less than MinDomains.
             * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
             * labelSelector spread as 2/2/1:
             * In this case, the global minimum is 1.
             * | zone1 | zone2 | zone3 |
             * |  P P  |  P P  |   P   |
             * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
             * scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
             * violate MaxSkew(1).
             * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
             * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
             * to topologies that satisfy it.
             * It's a required field. Default value is 1 and 0 is not allowed.
             */
            maxSkew: pulumi.Input<number>;
            /**
             * MinDomains indicates a minimum number of eligible domains.
             * When the number of eligible domains with matching topology keys is less than minDomains,
             * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
             * And when the number of eligible domains with matching topology keys equals or greater than minDomains,
             * this value has no effect on scheduling.
             * As a result, when the number of eligible domains is less than minDomains,
             * scheduler won't schedule more than maxSkew Pods to those domains.
             * If value is nil, the constraint behaves as if MinDomains is equal to 1.
             * Valid values are integers greater than 0.
             * When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
             *
             * For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
             * labelSelector spread as 2/2/2:
             * | zone1 | zone2 | zone3 |
             * |  P P  |  P P  |  P P  |
             * The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
             * In this situation, new pod with the same labelSelector cannot be scheduled,
             * because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
             * it will violate MaxSkew.
             */
            minDomains?: pulumi.Input<number>;
            /**
             * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
             * when calculating pod topology spread skew. Options are:
             * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
             * - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
             *
             * If this value is nil, the behavior is equivalent to the Honor policy.
             * This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
             */
            nodeAffinityPolicy?: pulumi.Input<string>;
            /**
             * NodeTaintsPolicy indicates how we will treat node taints when calculating
             * pod topology spread skew. Options are:
             * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
             * has a toleration, are included.
             * - Ignore: node taints are ignored. All nodes are included.
             *
             * If this value is nil, the behavior is equivalent to the Ignore policy.
             * This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
             */
            nodeTaintsPolicy?: pulumi.Input<string>;
            /**
             * TopologyKey is the key of node labels. Nodes that have a label with this key
             * and identical values are considered to be in the same topology.
             * We consider each <key, value> as a "bucket", and try to put balanced number
             * of pods into each bucket.
             * We define a domain as a particular instance of a topology.
             * Also, we define an eligible domain as a domain whose nodes meet the requirements of
             * nodeAffinityPolicy and nodeTaintsPolicy.
             * e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
             * And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
             * It's a required field.
             */
            topologyKey: pulumi.Input<string>;
            /**
             * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
             * the spread constraint.
             * - DoNotSchedule (default) tells the scheduler not to schedule it.
             * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
             *   but giving higher precedence to topologies that would help reduce the
             *   skew.
             * A constraint is considered "Unsatisfiable" for an incoming pod
             * if and only if every possible node assignment for that pod would violate
             * "MaxSkew" on some topology.
             * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
             * labelSelector spread as 3/1/1:
             * | zone1 | zone2 | zone3 |
             * | P P P |   P   |   P   |
             * If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
             * to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
             * MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
             * won't make it *more* imbalanced.
             * It's a required field.
             */
            whenUnsatisfiable: pulumi.Input<string>;
        }

        /**
         * LabelSelector is used to find matching pods.
         * Pods that match this label selector are counted to determine the number of pods
         * in their corresponding topology domain.
         */
        export interface ProxyClassSpecStatefulSetPodTopologySpreadConstraintsLabelSelectorArgs {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTopologySpreadConstraintsLabelSelectorMatchExpressionsArgs>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface ProxyClassSpecStatefulSetPodTopologySpreadConstraintsLabelSelectorMatchExpressionsArgs {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * TailscaleConfig contains options to configure the tailscale-specific
         * parameters of proxies.
         */
        export interface ProxyClassSpecTailscaleArgs {
            /**
             * AcceptRoutes can be set to true to make the proxy instance accept
             * routes advertized by other nodes on the tailnet, such as subnet
             * routes.
             * This is equivalent of passing --accept-routes flag to a tailscale Linux client.
             * https://tailscale.com/kb/1019/subnets#use-your-subnet-routes-from-other-devices
             * Defaults to false.
             */
            acceptRoutes?: pulumi.Input<boolean>;
        }

        /**
         * Status of the ProxyClass. This is set and managed automatically.
         * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
         */
        export interface ProxyClassStatusArgs {
            /**
             * List of status conditions to indicate the status of the ProxyClass.
             * Known condition types are `ProxyClassReady`.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyClassStatusConditionsArgs>[]>;
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         */
        export interface ProxyClassStatusConditionsArgs {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: pulumi.Input<string>;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: pulumi.Input<string>;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             */
            type: pulumi.Input<string>;
        }

        /**
         * Spec describes the desired ProxyGroup instances.
         */
        export interface ProxyGroupSpecArgs {
            /**
             * HostnamePrefix is the hostname prefix to use for tailnet devices created
             * by the ProxyGroup. Each device will have the integer number from its
             * StatefulSet pod appended to this prefix to form the full hostname.
             * HostnamePrefix can contain lower case letters, numbers and dashes, it
             * must not start with a dash and must be between 1 and 62 characters long.
             */
            hostnamePrefix?: pulumi.Input<string>;
            /**
             * ProxyClass is the name of the ProxyClass custom resource that contains
             * configuration options that should be applied to the resources created
             * for this ProxyGroup. If unset, and there is no default ProxyClass
             * configured, the operator will create resources with the default
             * configuration.
             */
            proxyClass?: pulumi.Input<string>;
            /**
             * Replicas specifies how many replicas to create the StatefulSet with.
             * Defaults to 2.
             */
            replicas?: pulumi.Input<number>;
            /**
             * Tags that the Tailscale devices will be tagged with. Defaults to [tag:k8s].
             * If you specify custom tags here, make sure you also make the operator
             * an owner of these tags.
             * See  https://tailscale.com/kb/1236/kubernetes-operator/#setting-up-the-kubernetes-operator.
             * Tags cannot be changed once a ProxyGroup device has been created.
             * Tag values must be in form ^tag:[a-zA-Z][a-zA-Z0-9-]*$.
             */
            tags?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Type of the ProxyGroup proxies. Currently the only supported type is egress.
             */
            type: pulumi.Input<string>;
        }

        /**
         * ProxyGroupStatus describes the status of the ProxyGroup resources. This is
         * set and managed by the Tailscale operator.
         */
        export interface ProxyGroupStatusArgs {
            /**
             * List of status conditions to indicate the status of the ProxyGroup
             * resources. Known condition types are `ProxyGroupReady`.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyGroupStatusConditionsArgs>[]>;
            /**
             * List of tailnet devices associated with the ProxyGroup StatefulSet.
             */
            devices?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.ProxyGroupStatusDevicesArgs>[]>;
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         */
        export interface ProxyGroupStatusConditionsArgs {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: pulumi.Input<string>;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: pulumi.Input<string>;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             */
            type: pulumi.Input<string>;
        }

        export interface ProxyGroupStatusDevicesArgs {
            /**
             * Hostname is the fully qualified domain name of the device.
             * If MagicDNS is enabled in your tailnet, it is the MagicDNS name of the
             * node.
             */
            hostname: pulumi.Input<string>;
            /**
             * TailnetIPs is the set of tailnet IP addresses (both IPv4 and IPv6)
             * assigned to the device.
             */
            tailnetIPs?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Spec describes the desired recorder instance.
         */
        export interface RecorderSpecArgs {
            /**
             * Set to true to enable the Recorder UI. The UI lists and plays recorded sessions.
             * The UI will be served at <MagicDNS name of the recorder>:443. Defaults to false.
             * Corresponds to --ui tsrecorder flag https://tailscale.com/kb/1246/tailscale-ssh-session-recording#deploy-a-recorder-node.
             * Required if S3 storage is not set up, to ensure that recordings are accessible.
             */
            enableUI?: pulumi.Input<boolean>;
            /**
             * Configuration parameters for the Recorder's StatefulSet. The operator
             * deploys a StatefulSet for each Recorder resource.
             */
            statefulSet?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetArgs>;
            /**
             * Configure where to store session recordings. By default, recordings will
             * be stored in a local ephemeral volume, and will not be persisted past the
             * lifetime of a specific pod.
             */
            storage?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStorageArgs>;
            /**
             * Tags that the Tailscale device will be tagged with. Defaults to [tag:k8s].
             * If you specify custom tags here, make sure you also make the operator
             * an owner of these tags.
             * See  https://tailscale.com/kb/1236/kubernetes-operator/#setting-up-the-kubernetes-operator.
             * Tags cannot be changed once a Recorder node has been created.
             * Tag values must be in form ^tag:[a-zA-Z][a-zA-Z0-9-]*$.
             */
            tags?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Configuration parameters for the Recorder's StatefulSet. The operator
         * deploys a StatefulSet for each Recorder resource.
         */
        export interface RecorderSpecStatefulSetArgs {
            /**
             * Annotations that will be added to the StatefulSet created for the Recorder.
             * Any Annotations specified here will be merged with the default annotations
             * applied to the StatefulSet by the operator.
             * https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/#syntax-and-character-set
             */
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Labels that will be added to the StatefulSet created for the Recorder.
             * Any labels specified here will be merged with the default labels applied
             * to the StatefulSet by the operator.
             * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Configuration for pods created by the Recorder's StatefulSet.
             */
            pod?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodArgs>;
        }

        /**
         * Configuration for pods created by the Recorder's StatefulSet.
         */
        export interface RecorderSpecStatefulSetPodArgs {
            /**
             * Affinity rules for Recorder Pods. By default, the operator does not
             * apply any affinity rules.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#affinity
             */
            affinity?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityArgs>;
            /**
             * Annotations that will be added to Recorder Pods.Any annotations
             * specified here will be merged with the default annotations applied to
             * the Pod by the operator.
             * https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/#syntax-and-character-set
             */
            annotations?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Configuration for the Recorder container running tailscale.
             */
            container?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodContainerArgs>;
            /**
             * Image pull Secrets for Recorder Pods.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec
             */
            imagePullSecrets?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodImagePullSecretsArgs>[]>;
            /**
             * Labels that will be added to Recorder Pods. Any labels specified here
             * will be merged with the default labels applied to the Pod by the operator.
             * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set
             */
            labels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Node selector rules for Recorder Pods. By default, the operator does
             * not apply any node selector rules.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#scheduling
             */
            nodeSelector?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
            /**
             * Security context for Recorder Pods. By default, the operator does not
             * apply any Pod security context.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context-2
             */
            securityContext?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodSecurityContextArgs>;
            /**
             * Tolerations for Recorder Pods. By default, the operator does not apply
             * any tolerations.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#scheduling
             */
            tolerations?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodTolerationsArgs>[]>;
        }

        /**
         * Affinity rules for Recorder Pods. By default, the operator does not
         * apply any affinity rules.
         * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#affinity
         */
        export interface RecorderSpecStatefulSetPodAffinityArgs {
            /**
             * Describes node affinity scheduling rules for the pod.
             */
            nodeAffinity?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityNodeAffinityArgs>;
            /**
             * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
             */
            podAffinity?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAffinityArgs>;
            /**
             * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
             */
            podAntiAffinity?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAntiAffinityArgs>;
        }

        /**
         * Describes node affinity scheduling rules for the pod.
         */
        export interface RecorderSpecStatefulSetPodAffinityNodeAffinityArgs {
            /**
             * The scheduler will prefer to schedule pods to nodes that satisfy
             * the affinity expressions specified by this field, but it may choose
             * a node that violates one or more of the expressions. The node that is
             * most preferred is the one with the greatest sum of weights, i.e.
             * for each node that meets all of the scheduling requirements (resource
             * request, requiredDuringScheduling affinity expressions, etc.),
             * compute a sum by iterating through the elements of this field and adding
             * "weight" to the sum if the node matches the corresponding matchExpressions; the
             * node(s) with the highest sum are the most preferred.
             */
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs>[]>;
            /**
             * If the affinity requirements specified by this field are not met at
             * scheduling time, the pod will not be scheduled onto the node.
             * If the affinity requirements specified by this field cease to be met
             * at some point during pod execution (e.g. due to an update), the system
             * may or may not try to eventually evict the pod from its node.
             */
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs>;
        }

        /**
         * An empty preferred scheduling term matches all objects with implicit weight 0
         * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
         */
        export interface RecorderSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs {
            /**
             * A node selector term, associated with the corresponding weight.
             */
            preference: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs>;
            /**
             * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
             */
            weight: pulumi.Input<number>;
        }

        /**
         * A node selector term, associated with the corresponding weight.
         */
        export interface RecorderSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceArgs {
            /**
             * A list of node selector requirements by node's labels.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs>[]>;
            /**
             * A list of node selector requirements by node's fields.
             */
            matchFields?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs>[]>;
        }

        /**
         * A node selector requirement is a selector that contains values, a key, and an operator
         * that relates the key and values.
         */
        export interface RecorderSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressionsArgs {
            /**
             * The label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * Represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
             */
            operator: pulumi.Input<string>;
            /**
             * An array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. If the operator is Gt or Lt, the values
             * array must have a single element, which will be interpreted as an integer.
             * This array is replaced during a strategic merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A node selector requirement is a selector that contains values, a key, and an operator
         * that relates the key and values.
         */
        export interface RecorderSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFieldsArgs {
            /**
             * The label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * Represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
             */
            operator: pulumi.Input<string>;
            /**
             * An array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. If the operator is Gt or Lt, the values
             * array must have a single element, which will be interpreted as an integer.
             * This array is replaced during a strategic merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * If the affinity requirements specified by this field are not met at
         * scheduling time, the pod will not be scheduled onto the node.
         * If the affinity requirements specified by this field cease to be met
         * at some point during pod execution (e.g. due to an update), the system
         * may or may not try to eventually evict the pod from its node.
         */
        export interface RecorderSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs {
            /**
             * Required. A list of node selector terms. The terms are ORed.
             */
            nodeSelectorTerms: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs>[]>;
        }

        /**
         * A null or empty node selector term matches no objects. The requirements of
         * them are ANDed.
         * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
         */
        export interface RecorderSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsArgs {
            /**
             * A list of node selector requirements by node's labels.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs>[]>;
            /**
             * A list of node selector requirements by node's fields.
             */
            matchFields?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs>[]>;
        }

        /**
         * A node selector requirement is a selector that contains values, a key, and an operator
         * that relates the key and values.
         */
        export interface RecorderSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressionsArgs {
            /**
             * The label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * Represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
             */
            operator: pulumi.Input<string>;
            /**
             * An array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. If the operator is Gt or Lt, the values
             * array must have a single element, which will be interpreted as an integer.
             * This array is replaced during a strategic merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A node selector requirement is a selector that contains values, a key, and an operator
         * that relates the key and values.
         */
        export interface RecorderSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFieldsArgs {
            /**
             * The label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * Represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
             */
            operator: pulumi.Input<string>;
            /**
             * An array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. If the operator is Gt or Lt, the values
             * array must have a single element, which will be interpreted as an integer.
             * This array is replaced during a strategic merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAffinityArgs {
            /**
             * The scheduler will prefer to schedule pods to nodes that satisfy
             * the affinity expressions specified by this field, but it may choose
             * a node that violates one or more of the expressions. The node that is
             * most preferred is the one with the greatest sum of weights, i.e.
             * for each node that meets all of the scheduling requirements (resource
             * request, requiredDuringScheduling affinity expressions, etc.),
             * compute a sum by iterating through the elements of this field and adding
             * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
             * node(s) with the highest sum are the most preferred.
             */
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs>[]>;
            /**
             * If the affinity requirements specified by this field are not met at
             * scheduling time, the pod will not be scheduled onto the node.
             * If the affinity requirements specified by this field cease to be met
             * at some point during pod execution (e.g. due to a pod label update), the
             * system may or may not try to eventually evict the pod from its node.
             * When there are multiple elements, the lists of nodes corresponding to each
             * podAffinityTerm are intersected, i.e. all terms must be satisfied.
             */
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs>[]>;
        }

        /**
         * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs {
            /**
             * Required. A pod affinity term, associated with the corresponding weight.
             */
            podAffinityTerm: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs>;
            /**
             * weight associated with matching the corresponding podAffinityTerm,
             * in the range 1-100.
             */
            weight: pulumi.Input<number>;
        }

        /**
         * Required. A pod affinity term, associated with the corresponding weight.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs {
            /**
             * A label query over a set of resources, in this case pods.
             * If it's null, this PodAffinityTerm matches with no Pods.
             */
            labelSelector?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs>;
            /**
             * MatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
             * Also, matchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            matchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * MismatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
             * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            mismatchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * A label query over the set of namespaces that the term applies to.
             * The term is applied to the union of the namespaces selected by this field
             * and the ones listed in the namespaces field.
             * null selector and null or empty namespaces list means "this pod's namespace".
             * An empty selector ({}) matches all namespaces.
             */
            namespaceSelector?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs>;
            /**
             * namespaces specifies a static list of namespace names that the term applies to.
             * The term is applied to the union of the namespaces listed in this field
             * and the ones selected by namespaceSelector.
             * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
             */
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
             * the labelSelector in the specified namespaces, where co-located is defined as running on a node
             * whose value of the label with key topologyKey matches that of any node on which any of the
             * selected pods is running.
             * Empty topologyKey is not allowed.
             */
            topologyKey: pulumi.Input<string>;
        }

        /**
         * A label query over a set of resources, in this case pods.
         * If it's null, this PodAffinityTerm matches with no Pods.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label query over the set of namespaces that the term applies to.
         * The term is applied to the union of the namespaces selected by this field
         * and the ones listed in the namespaces field.
         * null selector and null or empty namespaces list means "this pod's namespace".
         * An empty selector ({}) matches all namespaces.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Defines a set of pods (namely those matching the labelSelector
         * relative to the given namespace(s)) that this pod should be
         * co-located (affinity) or not co-located (anti-affinity) with,
         * where co-located is defined as running on a node whose value of
         * the label with key <topologyKey> matches that of any node on which
         * a pod of the set of pods is running
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs {
            /**
             * A label query over a set of resources, in this case pods.
             * If it's null, this PodAffinityTerm matches with no Pods.
             */
            labelSelector?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs>;
            /**
             * MatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
             * Also, matchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            matchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * MismatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
             * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            mismatchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * A label query over the set of namespaces that the term applies to.
             * The term is applied to the union of the namespaces selected by this field
             * and the ones listed in the namespaces field.
             * null selector and null or empty namespaces list means "this pod's namespace".
             * An empty selector ({}) matches all namespaces.
             */
            namespaceSelector?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs>;
            /**
             * namespaces specifies a static list of namespace names that the term applies to.
             * The term is applied to the union of the namespaces listed in this field
             * and the ones selected by namespaceSelector.
             * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
             */
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
             * the labelSelector in the specified namespaces, where co-located is defined as running on a node
             * whose value of the label with key topologyKey matches that of any node on which any of the
             * selected pods is running.
             * Empty topologyKey is not allowed.
             */
            topologyKey: pulumi.Input<string>;
        }

        /**
         * A label query over a set of resources, in this case pods.
         * If it's null, this PodAffinityTerm matches with no Pods.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label query over the set of namespaces that the term applies to.
         * The term is applied to the union of the namespaces selected by this field
         * and the ones listed in the namespaces field.
         * null selector and null or empty namespaces list means "this pod's namespace".
         * An empty selector ({}) matches all namespaces.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAntiAffinityArgs {
            /**
             * The scheduler will prefer to schedule pods to nodes that satisfy
             * the anti-affinity expressions specified by this field, but it may choose
             * a node that violates one or more of the expressions. The node that is
             * most preferred is the one with the greatest sum of weights, i.e.
             * for each node that meets all of the scheduling requirements (resource
             * request, requiredDuringScheduling anti-affinity expressions, etc.),
             * compute a sum by iterating through the elements of this field and adding
             * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
             * node(s) with the highest sum are the most preferred.
             */
            preferredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs>[]>;
            /**
             * If the anti-affinity requirements specified by this field are not met at
             * scheduling time, the pod will not be scheduled onto the node.
             * If the anti-affinity requirements specified by this field cease to be met
             * at some point during pod execution (e.g. due to a pod label update), the
             * system may or may not try to eventually evict the pod from its node.
             * When there are multiple elements, the lists of nodes corresponding to each
             * podAffinityTerm are intersected, i.e. all terms must be satisfied.
             */
            requiredDuringSchedulingIgnoredDuringExecution?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs>[]>;
        }

        /**
         * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionArgs {
            /**
             * Required. A pod affinity term, associated with the corresponding weight.
             */
            podAffinityTerm: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs>;
            /**
             * weight associated with matching the corresponding podAffinityTerm,
             * in the range 1-100.
             */
            weight: pulumi.Input<number>;
        }

        /**
         * Required. A pod affinity term, associated with the corresponding weight.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermArgs {
            /**
             * A label query over a set of resources, in this case pods.
             * If it's null, this PodAffinityTerm matches with no Pods.
             */
            labelSelector?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs>;
            /**
             * MatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
             * Also, matchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            matchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * MismatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
             * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            mismatchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * A label query over the set of namespaces that the term applies to.
             * The term is applied to the union of the namespaces selected by this field
             * and the ones listed in the namespaces field.
             * null selector and null or empty namespaces list means "this pod's namespace".
             * An empty selector ({}) matches all namespaces.
             */
            namespaceSelector?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs>;
            /**
             * namespaces specifies a static list of namespace names that the term applies to.
             * The term is applied to the union of the namespaces listed in this field
             * and the ones selected by namespaceSelector.
             * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
             */
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
             * the labelSelector in the specified namespaces, where co-located is defined as running on a node
             * whose value of the label with key topologyKey matches that of any node on which any of the
             * selected pods is running.
             * Empty topologyKey is not allowed.
             */
            topologyKey: pulumi.Input<string>;
        }

        /**
         * A label query over a set of resources, in this case pods.
         * If it's null, this PodAffinityTerm matches with no Pods.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorArgs {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressionsArgs {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label query over the set of namespaces that the term applies to.
         * The term is applied to the union of the namespaces selected by this field
         * and the ones listed in the namespaces field.
         * null selector and null or empty namespaces list means "this pod's namespace".
         * An empty selector ({}) matches all namespaces.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorArgs {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressionsArgs {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Defines a set of pods (namely those matching the labelSelector
         * relative to the given namespace(s)) that this pod should be
         * co-located (affinity) or not co-located (anti-affinity) with,
         * where co-located is defined as running on a node whose value of
         * the label with key <topologyKey> matches that of any node on which
         * a pod of the set of pods is running
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionArgs {
            /**
             * A label query over a set of resources, in this case pods.
             * If it's null, this PodAffinityTerm matches with no Pods.
             */
            labelSelector?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs>;
            /**
             * MatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
             * Also, matchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            matchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * MismatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
             * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            mismatchLabelKeys?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * A label query over the set of namespaces that the term applies to.
             * The term is applied to the union of the namespaces selected by this field
             * and the ones listed in the namespaces field.
             * null selector and null or empty namespaces list means "this pod's namespace".
             * An empty selector ({}) matches all namespaces.
             */
            namespaceSelector?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs>;
            /**
             * namespaces specifies a static list of namespace names that the term applies to.
             * The term is applied to the union of the namespaces listed in this field
             * and the ones selected by namespaceSelector.
             * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
             */
            namespaces?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
             * the labelSelector in the specified namespaces, where co-located is defined as running on a node
             * whose value of the label with key topologyKey matches that of any node on which any of the
             * selected pods is running.
             * Empty topologyKey is not allowed.
             */
            topologyKey: pulumi.Input<string>;
        }

        /**
         * A label query over a set of resources, in this case pods.
         * If it's null, this PodAffinityTerm matches with no Pods.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorArgs {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressionsArgs {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * A label query over the set of namespaces that the term applies to.
         * The term is applied to the union of the namespaces selected by this field
         * and the ones listed in the namespaces field.
         * null selector and null or empty namespaces list means "this pod's namespace".
         * An empty selector ({}) matches all namespaces.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorArgs {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs>[]>;
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: pulumi.Input<{[key: string]: pulumi.Input<string>}>;
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressionsArgs {
            /**
             * key is the label key that the selector applies to.
             */
            key: pulumi.Input<string>;
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: pulumi.Input<string>;
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * Configuration for the Recorder container running tailscale.
         */
        export interface RecorderSpecStatefulSetPodContainerArgs {
            /**
             * List of environment variables to set in the container.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#environment-variables
             * Note that environment variables provided here will take precedence
             * over Tailscale-specific environment variables set by the operator,
             * however running proxies with custom values for Tailscale environment
             * variables (i.e TS_USERSPACE) is not recommended and might break in
             * the future.
             */
            env?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodContainerEnvArgs>[]>;
            /**
             * Container image name including tag. Defaults to docker.io/tailscale/tsrecorder
             * with the same tag as the operator, but the official images are also
             * available at ghcr.io/tailscale/tsrecorder.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#image
             */
            image?: pulumi.Input<string>;
            /**
             * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#image
             */
            imagePullPolicy?: pulumi.Input<string>;
            /**
             * Container resource requirements.
             * By default, the operator does not apply any resource requirements. The
             * amount of resources required wil depend on the volume of recordings sent.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#resources
             */
            resources?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodContainerResourcesArgs>;
            /**
             * Container security context. By default, the operator does not apply any
             * container security context.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context
             */
            securityContext?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodContainerSecurityContextArgs>;
        }

        export interface RecorderSpecStatefulSetPodContainerEnvArgs {
            /**
             * Name of the environment variable. Must be a C_IDENTIFIER.
             */
            name: pulumi.Input<string>;
            /**
             * Variable references $(VAR_NAME) are expanded using the previously defined
             *  environment variables in the container and any service environment
             * variables. If a variable cannot be resolved, the reference in the input
             * string will be unchanged. Double $$ are reduced to a single $, which
             * allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
             * produce the string literal "$(VAR_NAME)". Escaped references will never
             * be expanded, regardless of whether the variable exists or not. Defaults
             * to "".
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Container resource requirements.
         * By default, the operator does not apply any resource requirements. The
         * amount of resources required wil depend on the volume of recordings sent.
         * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#resources
         */
        export interface RecorderSpecStatefulSetPodContainerResourcesArgs {
            /**
             * Claims lists the names of resources, defined in spec.resourceClaims,
             * that are used by this container.
             *
             * This is an alpha field and requires enabling the
             * DynamicResourceAllocation feature gate.
             *
             * This field is immutable. It can only be set for containers.
             */
            claims?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodContainerResourcesClaimsArgs>[]>;
            /**
             * Limits describes the maximum amount of compute resources allowed.
             * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
             */
            limits?: pulumi.Input<{[key: string]: pulumi.Input<number | string>}>;
            /**
             * Requests describes the minimum amount of compute resources required.
             * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
             * otherwise to an implementation-defined value. Requests cannot exceed Limits.
             * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
             */
            requests?: pulumi.Input<{[key: string]: pulumi.Input<number | string>}>;
        }

        /**
         * ResourceClaim references one entry in PodSpec.ResourceClaims.
         */
        export interface RecorderSpecStatefulSetPodContainerResourcesClaimsArgs {
            /**
             * Name must match the name of one entry in pod.spec.resourceClaims of
             * the Pod where this field is used. It makes that resource available
             * inside a container.
             */
            name: pulumi.Input<string>;
        }

        /**
         * Container security context. By default, the operator does not apply any
         * container security context.
         * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context
         */
        export interface RecorderSpecStatefulSetPodContainerSecurityContextArgs {
            /**
             * AllowPrivilegeEscalation controls whether a process can gain more
             * privileges than its parent process. This bool directly controls if
             * the no_new_privs flag will be set on the container process.
             * AllowPrivilegeEscalation is true always when the container is:
             * 1) run as Privileged
             * 2) has CAP_SYS_ADMIN
             * Note that this field cannot be set when spec.os.name is windows.
             */
            allowPrivilegeEscalation?: pulumi.Input<boolean>;
            /**
             * appArmorProfile is the AppArmor options to use by this container. If set, this profile
             * overrides the pod's appArmorProfile.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            appArmorProfile?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodContainerSecurityContextAppArmorProfileArgs>;
            /**
             * The capabilities to add/drop when running containers.
             * Defaults to the default set of capabilities granted by the container runtime.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            capabilities?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodContainerSecurityContextCapabilitiesArgs>;
            /**
             * Run container in privileged mode.
             * Processes in privileged containers are essentially equivalent to root on the host.
             * Defaults to false.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            privileged?: pulumi.Input<boolean>;
            /**
             * procMount denotes the type of proc mount to use for the containers.
             * The default is DefaultProcMount which uses the container runtime defaults for
             * readonly paths and masked paths.
             * This requires the ProcMountType feature flag to be enabled.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            procMount?: pulumi.Input<string>;
            /**
             * Whether this container has a read-only root filesystem.
             * Default is false.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            readOnlyRootFilesystem?: pulumi.Input<boolean>;
            /**
             * The GID to run the entrypoint of the container process.
             * Uses runtime default if unset.
             * May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsGroup?: pulumi.Input<number>;
            /**
             * Indicates that the container must run as a non-root user.
             * If true, the Kubelet will validate the image at runtime to ensure that it
             * does not run as UID 0 (root) and fail to start the container if it does.
             * If unset or false, no such validation will be performed.
             * May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsNonRoot?: pulumi.Input<boolean>;
            /**
             * The UID to run the entrypoint of the container process.
             * Defaults to user specified in image metadata if unspecified.
             * May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsUser?: pulumi.Input<number>;
            /**
             * The SELinux context to be applied to the container.
             * If unspecified, the container runtime will allocate a random SELinux context for each
             * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            seLinuxOptions?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodContainerSecurityContextSeLinuxOptionsArgs>;
            /**
             * The seccomp options to use by this container. If seccomp options are
             * provided at both the pod & container level, the container options
             * override the pod options.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            seccompProfile?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodContainerSecurityContextSeccompProfileArgs>;
            /**
             * The Windows specific settings applied to all containers.
             * If unspecified, the options from the PodSecurityContext will be used.
             * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is linux.
             */
            windowsOptions?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodContainerSecurityContextWindowsOptionsArgs>;
        }

        /**
         * appArmorProfile is the AppArmor options to use by this container. If set, this profile
         * overrides the pod's appArmorProfile.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface RecorderSpecStatefulSetPodContainerSecurityContextAppArmorProfileArgs {
            /**
             * localhostProfile indicates a profile loaded on the node that should be used.
             * The profile must be preconfigured on the node to work.
             * Must match the loaded name of the profile.
             * Must be set if and only if type is "Localhost".
             */
            localhostProfile?: pulumi.Input<string>;
            /**
             * type indicates which kind of AppArmor profile will be applied.
             * Valid options are:
             *   Localhost - a profile pre-loaded on the node.
             *   RuntimeDefault - the container runtime's default profile.
             *   Unconfined - no AppArmor enforcement.
             */
            type: pulumi.Input<string>;
        }

        /**
         * The capabilities to add/drop when running containers.
         * Defaults to the default set of capabilities granted by the container runtime.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface RecorderSpecStatefulSetPodContainerSecurityContextCapabilitiesArgs {
            /**
             * Added capabilities
             */
            add?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * Removed capabilities
             */
            drop?: pulumi.Input<pulumi.Input<string>[]>;
        }

        /**
         * The SELinux context to be applied to the container.
         * If unspecified, the container runtime will allocate a random SELinux context for each
         * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
         * PodSecurityContext, the value specified in SecurityContext takes precedence.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface RecorderSpecStatefulSetPodContainerSecurityContextSeLinuxOptionsArgs {
            /**
             * Level is SELinux level label that applies to the container.
             */
            level?: pulumi.Input<string>;
            /**
             * Role is a SELinux role label that applies to the container.
             */
            role?: pulumi.Input<string>;
            /**
             * Type is a SELinux type label that applies to the container.
             */
            type?: pulumi.Input<string>;
            /**
             * User is a SELinux user label that applies to the container.
             */
            user?: pulumi.Input<string>;
        }

        /**
         * The seccomp options to use by this container. If seccomp options are
         * provided at both the pod & container level, the container options
         * override the pod options.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface RecorderSpecStatefulSetPodContainerSecurityContextSeccompProfileArgs {
            /**
             * localhostProfile indicates a profile defined in a file on the node should be used.
             * The profile must be preconfigured on the node to work.
             * Must be a descending path, relative to the kubelet's configured seccomp profile location.
             * Must be set if type is "Localhost". Must NOT be set for any other type.
             */
            localhostProfile?: pulumi.Input<string>;
            /**
             * type indicates which kind of seccomp profile will be applied.
             * Valid options are:
             *
             * Localhost - a profile defined in a file on the node should be used.
             * RuntimeDefault - the container runtime default profile should be used.
             * Unconfined - no profile should be applied.
             */
            type: pulumi.Input<string>;
        }

        /**
         * The Windows specific settings applied to all containers.
         * If unspecified, the options from the PodSecurityContext will be used.
         * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
         * Note that this field cannot be set when spec.os.name is linux.
         */
        export interface RecorderSpecStatefulSetPodContainerSecurityContextWindowsOptionsArgs {
            /**
             * GMSACredentialSpec is where the GMSA admission webhook
             * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
             * GMSA credential spec named by the GMSACredentialSpecName field.
             */
            gmsaCredentialSpec?: pulumi.Input<string>;
            /**
             * GMSACredentialSpecName is the name of the GMSA credential spec to use.
             */
            gmsaCredentialSpecName?: pulumi.Input<string>;
            /**
             * HostProcess determines if a container should be run as a 'Host Process' container.
             * All of a Pod's containers must have the same effective HostProcess value
             * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
             * In addition, if HostProcess is true then HostNetwork must also be set to true.
             */
            hostProcess?: pulumi.Input<boolean>;
            /**
             * The UserName in Windows to run the entrypoint of the container process.
             * Defaults to the user specified in image metadata if unspecified.
             * May also be set in PodSecurityContext. If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsUserName?: pulumi.Input<string>;
        }

        /**
         * LocalObjectReference contains enough information to let you locate the
         * referenced object inside the same namespace.
         */
        export interface RecorderSpecStatefulSetPodImagePullSecretsArgs {
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: pulumi.Input<string>;
        }
        /**
         * recorderSpecStatefulSetPodImagePullSecretsArgsProvideDefaults sets the appropriate defaults for RecorderSpecStatefulSetPodImagePullSecretsArgs
         */
        export function recorderSpecStatefulSetPodImagePullSecretsArgsProvideDefaults(val: RecorderSpecStatefulSetPodImagePullSecretsArgs): RecorderSpecStatefulSetPodImagePullSecretsArgs {
            return {
                ...val,
                name: (val.name) ?? "",
            };
        }

        /**
         * Security context for Recorder Pods. By default, the operator does not
         * apply any Pod security context.
         * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context-2
         */
        export interface RecorderSpecStatefulSetPodSecurityContextArgs {
            /**
             * appArmorProfile is the AppArmor options to use by the containers in this pod.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            appArmorProfile?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodSecurityContextAppArmorProfileArgs>;
            /**
             * A special supplemental group that applies to all containers in a pod.
             * Some volume types allow the Kubelet to change the ownership of that volume
             * to be owned by the pod:
             *
             * 1. The owning GID will be the FSGroup
             * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
             * 3. The permission bits are OR'd with rw-rw----
             *
             * If unset, the Kubelet will not modify the ownership and permissions of any volume.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            fsGroup?: pulumi.Input<number>;
            /**
             * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
             * before being exposed inside Pod. This field will only apply to
             * volume types which support fsGroup based ownership(and permissions).
             * It will have no effect on ephemeral volume types such as: secret, configmaps
             * and emptydir.
             * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            fsGroupChangePolicy?: pulumi.Input<string>;
            /**
             * The GID to run the entrypoint of the container process.
             * Uses runtime default if unset.
             * May also be set in SecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence
             * for that container.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsGroup?: pulumi.Input<number>;
            /**
             * Indicates that the container must run as a non-root user.
             * If true, the Kubelet will validate the image at runtime to ensure that it
             * does not run as UID 0 (root) and fail to start the container if it does.
             * If unset or false, no such validation will be performed.
             * May also be set in SecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsNonRoot?: pulumi.Input<boolean>;
            /**
             * The UID to run the entrypoint of the container process.
             * Defaults to user specified in image metadata if unspecified.
             * May also be set in SecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence
             * for that container.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsUser?: pulumi.Input<number>;
            /**
             * The SELinux context to be applied to all containers.
             * If unspecified, the container runtime will allocate a random SELinux context for each
             * container.  May also be set in SecurityContext.  If set in
             * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
             * takes precedence for that container.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            seLinuxOptions?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodSecurityContextSeLinuxOptionsArgs>;
            /**
             * The seccomp options to use by the containers in this pod.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            seccompProfile?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodSecurityContextSeccompProfileArgs>;
            /**
             * A list of groups applied to the first process run in each container, in addition
             * to the container's primary GID, the fsGroup (if specified), and group memberships
             * defined in the container image for the uid of the container process. If unspecified,
             * no additional groups are added to any container. Note that group memberships
             * defined in the container image for the uid of the container process are still effective,
             * even if they are not included in this list.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            supplementalGroups?: pulumi.Input<pulumi.Input<number>[]>;
            /**
             * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
             * sysctls (by the container runtime) might fail to launch.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            sysctls?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodSecurityContextSysctlsArgs>[]>;
            /**
             * The Windows specific settings applied to all containers.
             * If unspecified, the options within a container's SecurityContext will be used.
             * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is linux.
             */
            windowsOptions?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodSecurityContextWindowsOptionsArgs>;
        }

        /**
         * appArmorProfile is the AppArmor options to use by the containers in this pod.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface RecorderSpecStatefulSetPodSecurityContextAppArmorProfileArgs {
            /**
             * localhostProfile indicates a profile loaded on the node that should be used.
             * The profile must be preconfigured on the node to work.
             * Must match the loaded name of the profile.
             * Must be set if and only if type is "Localhost".
             */
            localhostProfile?: pulumi.Input<string>;
            /**
             * type indicates which kind of AppArmor profile will be applied.
             * Valid options are:
             *   Localhost - a profile pre-loaded on the node.
             *   RuntimeDefault - the container runtime's default profile.
             *   Unconfined - no AppArmor enforcement.
             */
            type: pulumi.Input<string>;
        }

        /**
         * The SELinux context to be applied to all containers.
         * If unspecified, the container runtime will allocate a random SELinux context for each
         * container.  May also be set in SecurityContext.  If set in
         * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
         * takes precedence for that container.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface RecorderSpecStatefulSetPodSecurityContextSeLinuxOptionsArgs {
            /**
             * Level is SELinux level label that applies to the container.
             */
            level?: pulumi.Input<string>;
            /**
             * Role is a SELinux role label that applies to the container.
             */
            role?: pulumi.Input<string>;
            /**
             * Type is a SELinux type label that applies to the container.
             */
            type?: pulumi.Input<string>;
            /**
             * User is a SELinux user label that applies to the container.
             */
            user?: pulumi.Input<string>;
        }

        /**
         * The seccomp options to use by the containers in this pod.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface RecorderSpecStatefulSetPodSecurityContextSeccompProfileArgs {
            /**
             * localhostProfile indicates a profile defined in a file on the node should be used.
             * The profile must be preconfigured on the node to work.
             * Must be a descending path, relative to the kubelet's configured seccomp profile location.
             * Must be set if type is "Localhost". Must NOT be set for any other type.
             */
            localhostProfile?: pulumi.Input<string>;
            /**
             * type indicates which kind of seccomp profile will be applied.
             * Valid options are:
             *
             * Localhost - a profile defined in a file on the node should be used.
             * RuntimeDefault - the container runtime default profile should be used.
             * Unconfined - no profile should be applied.
             */
            type: pulumi.Input<string>;
        }

        /**
         * Sysctl defines a kernel parameter to be set
         */
        export interface RecorderSpecStatefulSetPodSecurityContextSysctlsArgs {
            /**
             * Name of a property to set
             */
            name: pulumi.Input<string>;
            /**
             * Value of a property to set
             */
            value: pulumi.Input<string>;
        }

        /**
         * The Windows specific settings applied to all containers.
         * If unspecified, the options within a container's SecurityContext will be used.
         * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
         * Note that this field cannot be set when spec.os.name is linux.
         */
        export interface RecorderSpecStatefulSetPodSecurityContextWindowsOptionsArgs {
            /**
             * GMSACredentialSpec is where the GMSA admission webhook
             * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
             * GMSA credential spec named by the GMSACredentialSpecName field.
             */
            gmsaCredentialSpec?: pulumi.Input<string>;
            /**
             * GMSACredentialSpecName is the name of the GMSA credential spec to use.
             */
            gmsaCredentialSpecName?: pulumi.Input<string>;
            /**
             * HostProcess determines if a container should be run as a 'Host Process' container.
             * All of a Pod's containers must have the same effective HostProcess value
             * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
             * In addition, if HostProcess is true then HostNetwork must also be set to true.
             */
            hostProcess?: pulumi.Input<boolean>;
            /**
             * The UserName in Windows to run the entrypoint of the container process.
             * Defaults to the user specified in image metadata if unspecified.
             * May also be set in PodSecurityContext. If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsUserName?: pulumi.Input<string>;
        }

        /**
         * The pod this Toleration is attached to tolerates any taint that matches
         * the triple <key,value,effect> using the matching operator <operator>.
         */
        export interface RecorderSpecStatefulSetPodTolerationsArgs {
            /**
             * Effect indicates the taint effect to match. Empty means match all taint effects.
             * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
             */
            effect?: pulumi.Input<string>;
            /**
             * Key is the taint key that the toleration applies to. Empty means match all taint keys.
             * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
             */
            key?: pulumi.Input<string>;
            /**
             * Operator represents a key's relationship to the value.
             * Valid operators are Exists and Equal. Defaults to Equal.
             * Exists is equivalent to wildcard for value, so that a pod can
             * tolerate all taints of a particular category.
             */
            operator?: pulumi.Input<string>;
            /**
             * TolerationSeconds represents the period of time the toleration (which must be
             * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
             * it is not set, which means tolerate the taint forever (do not evict). Zero and
             * negative values will be treated as 0 (evict immediately) by the system.
             */
            tolerationSeconds?: pulumi.Input<number>;
            /**
             * Value is the taint value the toleration matches to.
             * If the operator is Exists, the value should be empty, otherwise just a regular string.
             */
            value?: pulumi.Input<string>;
        }

        /**
         * Configure where to store session recordings. By default, recordings will
         * be stored in a local ephemeral volume, and will not be persisted past the
         * lifetime of a specific pod.
         */
        export interface RecorderSpecStorageArgs {
            /**
             * Configure an S3-compatible API for storage. Required if the UI is not
             * enabled, to ensure that recordings are accessible.
             */
            s3?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStorageS3Args>;
        }

        /**
         * Configure an S3-compatible API for storage. Required if the UI is not
         * enabled, to ensure that recordings are accessible.
         */
        export interface RecorderSpecStorageS3Args {
            /**
             * Bucket name to write to. The bucket is expected to be used solely for
             * recordings, as there is no stable prefix for written object names.
             */
            bucket?: pulumi.Input<string>;
            /**
             * Configure environment variable credentials for managing objects in the
             * configured bucket. If not set, tsrecorder will try to acquire credentials
             * first from the file system and then the STS API.
             */
            credentials?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStorageS3CredentialsArgs>;
            /**
             * S3-compatible endpoint, e.g. s3.us-east-1.amazonaws.com.
             */
            endpoint?: pulumi.Input<string>;
        }

        /**
         * Configure environment variable credentials for managing objects in the
         * configured bucket. If not set, tsrecorder will try to acquire credentials
         * first from the file system and then the STS API.
         */
        export interface RecorderSpecStorageS3CredentialsArgs {
            /**
             * Use a Kubernetes Secret from the operator's namespace as the source of
             * credentials.
             */
            secret?: pulumi.Input<inputs.tailscale.v1alpha1.RecorderSpecStorageS3CredentialsSecretArgs>;
        }

        /**
         * Use a Kubernetes Secret from the operator's namespace as the source of
         * credentials.
         */
        export interface RecorderSpecStorageS3CredentialsSecretArgs {
            /**
             * The name of a Kubernetes Secret in the operator's namespace that contains
             * credentials for writing to the configured bucket. Each key-value pair
             * from the secret's data will be mounted as an environment variable. It
             * should include keys for AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY if
             * using a static access key.
             */
            name?: pulumi.Input<string>;
        }

        /**
         * RecorderStatus describes the status of the recorder. This is set
         * and managed by the Tailscale operator.
         */
        export interface RecorderStatusArgs {
            /**
             * List of status conditions to indicate the status of the Recorder.
             * Known condition types are `RecorderReady`.
             */
            conditions?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.RecorderStatusConditionsArgs>[]>;
            /**
             * List of tailnet devices associated with the Recorder StatefulSet.
             */
            devices?: pulumi.Input<pulumi.Input<inputs.tailscale.v1alpha1.RecorderStatusDevicesArgs>[]>;
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         */
        export interface RecorderStatusConditionsArgs {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: pulumi.Input<string>;
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: pulumi.Input<string>;
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: pulumi.Input<number>;
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: pulumi.Input<string>;
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: pulumi.Input<string>;
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             */
            type: pulumi.Input<string>;
        }

        export interface RecorderStatusDevicesArgs {
            /**
             * Hostname is the fully qualified domain name of the device.
             * If MagicDNS is enabled in your tailnet, it is the MagicDNS name of the
             * node.
             */
            hostname: pulumi.Input<string>;
            /**
             * TailnetIPs is the set of tailnet IP addresses (both IPv4 and IPv6)
             * assigned to the device.
             */
            tailnetIPs?: pulumi.Input<pulumi.Input<string>[]>;
            /**
             * URL where the UI is available if enabled for replaying recordings. This
             * will be an HTTPS MagicDNS URL. You must be connected to the same tailnet
             * as the recorder to access it.
             */
            url?: pulumi.Input<string>;
        }
    }
}
