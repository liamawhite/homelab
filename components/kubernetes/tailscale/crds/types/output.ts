// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from '@pulumi/pulumi'
import * as inputs from '../types/input'
import * as outputs from '../types/output'

import * as utilities from '../utilities'

import { ObjectMeta } from '../meta/v1'

export namespace tailscale {
    export namespace v1alpha1 {
        /**
         * ConnectorSpec describes the desired Tailscale component.
         * More info:
         * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
         */
        export interface ConnectorSpec {
            /**
             * AppConnector defines whether the Connector device should act as a Tailscale app connector. A Connector that is
             * configured as an app connector cannot be a subnet router or an exit node. If this field is unset, the
             * Connector does not act as an app connector.
             * Note that you will need to manually configure the permissions and the domains for the app connector via the
             * Admin panel.
             * Note also that the main tested and supported use case of this config option is to deploy an app connector on
             * Kubernetes to access SaaS applications available on the public internet. Using the app connector to expose
             * cluster workloads or other internal workloads to tailnet might work, but this is not a use case that we have
             * tested or optimised for.
             * If you are using the app connector to access SaaS applications because you need a predictable egress IP that
             * can be whitelisted, it is also your responsibility to ensure that cluster traffic from the connector flows
             * via that predictable IP, for example by enforcing that cluster egress traffic is routed via an egress NAT
             * device with a static IP address.
             * https://tailscale.com/kb/1281/app-connectors
             */
            appConnector?: outputs.tailscale.v1alpha1.ConnectorSpecAppConnector
            /**
             * ExitNode defines whether the Connector device should act as a Tailscale exit node. Defaults to false.
             * This field is mutually exclusive with the appConnector field.
             * https://tailscale.com/kb/1103/exit-nodes
             */
            exitNode?: boolean
            /**
             * Hostname is the tailnet hostname that should be assigned to the
             * Connector node. If unset, hostname defaults to <connector
             * name>-connector. Hostname can contain lower case letters, numbers and
             * dashes, it must not start or end with a dash and must be between 2
             * and 63 characters long.
             */
            hostname?: string
            /**
             * ProxyClass is the name of the ProxyClass custom resource that
             * contains configuration options that should be applied to the
             * resources created for this Connector. If unset, the operator will
             * create resources with the default configuration.
             */
            proxyClass?: string
            /**
             * SubnetRouter defines subnet routes that the Connector device should
             * expose to tailnet as a Tailscale subnet router.
             * https://tailscale.com/kb/1019/subnets/
             * If this field is unset, the device does not get configured as a Tailscale subnet router.
             * This field is mutually exclusive with the appConnector field.
             */
            subnetRouter?: outputs.tailscale.v1alpha1.ConnectorSpecSubnetRouter
            /**
             * Tags that the Tailscale node will be tagged with.
             * Defaults to [tag:k8s].
             * To autoapprove the subnet routes or exit node defined by a Connector,
             * you can configure Tailscale ACLs to give these tags the necessary
             * permissions.
             * See https://tailscale.com/kb/1337/acl-syntax#autoapprovers.
             * If you specify custom tags here, you must also make the operator an owner of these tags.
             * See  https://tailscale.com/kb/1236/kubernetes-operator/#setting-up-the-kubernetes-operator.
             * Tags cannot be changed once a Connector node has been created.
             * Tag values must be in form ^tag:[a-zA-Z][a-zA-Z0-9-]*$.
             */
            tags?: string[]
        }

        /**
         * AppConnector defines whether the Connector device should act as a Tailscale app connector. A Connector that is
         * configured as an app connector cannot be a subnet router or an exit node. If this field is unset, the
         * Connector does not act as an app connector.
         * Note that you will need to manually configure the permissions and the domains for the app connector via the
         * Admin panel.
         * Note also that the main tested and supported use case of this config option is to deploy an app connector on
         * Kubernetes to access SaaS applications available on the public internet. Using the app connector to expose
         * cluster workloads or other internal workloads to tailnet might work, but this is not a use case that we have
         * tested or optimised for.
         * If you are using the app connector to access SaaS applications because you need a predictable egress IP that
         * can be whitelisted, it is also your responsibility to ensure that cluster traffic from the connector flows
         * via that predictable IP, for example by enforcing that cluster egress traffic is routed via an egress NAT
         * device with a static IP address.
         * https://tailscale.com/kb/1281/app-connectors
         */
        export interface ConnectorSpecAppConnector {
            /**
             * Routes are optional preconfigured routes for the domains routed via the app connector.
             * If not set, routes for the domains will be discovered dynamically.
             * If set, the app connector will immediately be able to route traffic using the preconfigured routes, but may
             * also dynamically discover other routes.
             * https://tailscale.com/kb/1332/apps-best-practices#preconfiguration
             */
            routes?: string[]
        }

        /**
         * SubnetRouter defines subnet routes that the Connector device should
         * expose to tailnet as a Tailscale subnet router.
         * https://tailscale.com/kb/1019/subnets/
         * If this field is unset, the device does not get configured as a Tailscale subnet router.
         * This field is mutually exclusive with the appConnector field.
         */
        export interface ConnectorSpecSubnetRouter {
            /**
             * AdvertiseRoutes refer to CIDRs that the subnet router should make
             * available. Route values must be strings that represent a valid IPv4
             * or IPv6 CIDR range. Values can be Tailscale 4via6 subnet routes.
             * https://tailscale.com/kb/1201/4via6-subnets/
             */
            advertiseRoutes: string[]
        }

        /**
         * ConnectorStatus describes the status of the Connector. This is set
         * and managed by the Tailscale operator.
         */
        export interface ConnectorStatus {
            /**
             * List of status conditions to indicate the status of the Connector.
             * Known condition types are `ConnectorReady`.
             */
            conditions?: outputs.tailscale.v1alpha1.ConnectorStatusConditions[]
            /**
             * Hostname is the fully qualified domain name of the Connector node.
             * If MagicDNS is enabled in your tailnet, it is the MagicDNS name of the
             * node.
             */
            hostname?: string
            /**
             * IsAppConnector is set to true if the Connector acts as an app connector.
             */
            isAppConnector?: boolean
            /**
             * IsExitNode is set to true if the Connector acts as an exit node.
             */
            isExitNode?: boolean
            /**
             * SubnetRoutes are the routes currently exposed to tailnet via this
             * Connector instance.
             */
            subnetRoutes?: string
            /**
             * TailnetIPs is the set of tailnet IP addresses (both IPv4 and IPv6)
             * assigned to the Connector node.
             */
            tailnetIPs?: string[]
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         */
        export interface ConnectorStatusConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: string
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: number
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: string
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: string
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             */
            type: string
        }

        /**
         * Spec describes the desired DNS configuration.
         * More info:
         * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
         */
        export interface DNSConfigSpec {
            /**
             * Configuration for a nameserver that can resolve ts.net DNS names
             * associated with in-cluster proxies for Tailscale egress Services and
             * Tailscale Ingresses. The operator will always deploy this nameserver
             * when a DNSConfig is applied.
             */
            nameserver: outputs.tailscale.v1alpha1.DNSConfigSpecNameserver
        }

        /**
         * Configuration for a nameserver that can resolve ts.net DNS names
         * associated with in-cluster proxies for Tailscale egress Services and
         * Tailscale Ingresses. The operator will always deploy this nameserver
         * when a DNSConfig is applied.
         */
        export interface DNSConfigSpecNameserver {
            /**
             * Nameserver image. Defaults to tailscale/k8s-nameserver:unstable.
             */
            image?: outputs.tailscale.v1alpha1.DNSConfigSpecNameserverImage
        }

        /**
         * Nameserver image. Defaults to tailscale/k8s-nameserver:unstable.
         */
        export interface DNSConfigSpecNameserverImage {
            /**
             * Repo defaults to tailscale/k8s-nameserver.
             */
            repo?: string
            /**
             * Tag defaults to unstable.
             */
            tag?: string
        }

        /**
         * Status describes the status of the DNSConfig. This is set
         * and managed by the Tailscale operator.
         */
        export interface DNSConfigStatus {
            conditions?: outputs.tailscale.v1alpha1.DNSConfigStatusConditions[]
            /**
             * Nameserver describes the status of nameserver cluster resources.
             */
            nameserver?: outputs.tailscale.v1alpha1.DNSConfigStatusNameserver
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         */
        export interface DNSConfigStatusConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: string
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: number
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: string
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: string
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             */
            type: string
        }

        /**
         * Nameserver describes the status of nameserver cluster resources.
         */
        export interface DNSConfigStatusNameserver {
            /**
             * IP is the ClusterIP of the Service fronting the deployed ts.net nameserver.
             * Currently you must manually update your cluster DNS config to add
             * this address as a stub nameserver for ts.net for cluster workloads to be
             * able to resolve MagicDNS names associated with egress or Ingress
             * proxies.
             * The IP address will change if you delete and recreate the DNSConfig.
             */
            ip?: string
        }

        /**
         * Specification of the desired state of the ProxyClass resource.
         * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
         */
        export interface ProxyClassSpec {
            /**
             * Configuration for proxy metrics. Metrics are currently not supported
             * for egress proxies and for Ingress proxies that have been configured
             * with tailscale.com/experimental-forward-cluster-traffic-via-ingress
             * annotation. Note that the metrics are currently considered unstable
             * and will likely change in breaking ways in the future - we only
             * recommend that you use those for debugging purposes.
             */
            metrics?: outputs.tailscale.v1alpha1.ProxyClassSpecMetrics
            /**
             * Configuration parameters for the proxy's StatefulSet. Tailscale
             * Kubernetes operator deploys a StatefulSet for each of the user
             * configured proxies (Tailscale Ingress, Tailscale Service, Connector).
             */
            statefulSet?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSet
            /**
             * TailscaleConfig contains options to configure the tailscale-specific
             * parameters of proxies.
             */
            tailscale?: outputs.tailscale.v1alpha1.ProxyClassSpecTailscale
        }

        /**
         * Configuration for proxy metrics. Metrics are currently not supported
         * for egress proxies and for Ingress proxies that have been configured
         * with tailscale.com/experimental-forward-cluster-traffic-via-ingress
         * annotation. Note that the metrics are currently considered unstable
         * and will likely change in breaking ways in the future - we only
         * recommend that you use those for debugging purposes.
         */
        export interface ProxyClassSpecMetrics {
            /**
             * Setting enable to true will make the proxy serve Tailscale metrics
             * at <pod-ip>:9002/metrics.
             * A metrics Service named <proxy-statefulset>-metrics will also be created in the operator's namespace and will
             * serve the metrics at <service-ip>:9002/metrics.
             *
             * In 1.78.x and 1.80.x, this field also serves as the default value for
             * .spec.statefulSet.pod.tailscaleContainer.debug.enable. From 1.82.0, both
             * fields will independently default to false.
             *
             * Defaults to false.
             */
            enable: boolean
            /**
             * Enable to create a Prometheus ServiceMonitor for scraping the proxy's Tailscale metrics.
             * The ServiceMonitor will select the metrics Service that gets created when metrics are enabled.
             * The ingested metrics for each Service monitor will have labels to identify the proxy:
             * ts_proxy_type: ingress_service|ingress_resource|connector|proxygroup
             * ts_proxy_parent_name: name of the parent resource (i.e name of the Connector, Tailscale Ingress, Tailscale Service or ProxyGroup)
             * ts_proxy_parent_namespace: namespace of the parent resource (if the parent resource is not cluster scoped)
             * job: ts_<proxy type>_[<parent namespace>]_<parent_name>
             */
            serviceMonitor?: outputs.tailscale.v1alpha1.ProxyClassSpecMetricsServiceMonitor
        }

        /**
         * Enable to create a Prometheus ServiceMonitor for scraping the proxy's Tailscale metrics.
         * The ServiceMonitor will select the metrics Service that gets created when metrics are enabled.
         * The ingested metrics for each Service monitor will have labels to identify the proxy:
         * ts_proxy_type: ingress_service|ingress_resource|connector|proxygroup
         * ts_proxy_parent_name: name of the parent resource (i.e name of the Connector, Tailscale Ingress, Tailscale Service or ProxyGroup)
         * ts_proxy_parent_namespace: namespace of the parent resource (if the parent resource is not cluster scoped)
         * job: ts_<proxy type>_[<parent namespace>]_<parent_name>
         */
        export interface ProxyClassSpecMetricsServiceMonitor {
            /**
             * If Enable is set to true, a Prometheus ServiceMonitor will be created. Enable can only be set to true if metrics are enabled.
             */
            enable: boolean
        }

        /**
         * Configuration parameters for the proxy's StatefulSet. Tailscale
         * Kubernetes operator deploys a StatefulSet for each of the user
         * configured proxies (Tailscale Ingress, Tailscale Service, Connector).
         */
        export interface ProxyClassSpecStatefulSet {
            /**
             * Annotations that will be added to the StatefulSet created for the proxy.
             * Any Annotations specified here will be merged with the default annotations
             * applied to the StatefulSet by the Tailscale Kubernetes operator as
             * well as any other annotations that might have been applied by other
             * actors.
             * Annotations must be valid Kubernetes annotations.
             * https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/#syntax-and-character-set
             */
            annotations?: { [key: string]: string }
            /**
             * Labels that will be added to the StatefulSet created for the proxy.
             * Any labels specified here will be merged with the default labels
             * applied to the StatefulSet by the Tailscale Kubernetes operator as
             * well as any other labels that might have been applied by other
             * actors.
             * Label keys and values must be valid Kubernetes label keys and values.
             * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set
             */
            labels?: { [key: string]: string }
            /**
             * Configuration for the proxy Pod.
             */
            pod?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPod
        }

        /**
         * Configuration for the proxy Pod.
         */
        export interface ProxyClassSpecStatefulSetPod {
            /**
             * Proxy Pod's affinity rules.
             * By default, the Tailscale Kubernetes operator does not apply any affinity rules.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#affinity
             */
            affinity?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinity
            /**
             * Annotations that will be added to the proxy Pod.
             * Any annotations specified here will be merged with the default
             * annotations applied to the Pod by the Tailscale Kubernetes operator.
             * Annotations must be valid Kubernetes annotations.
             * https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/#syntax-and-character-set
             */
            annotations?: { [key: string]: string }
            /**
             * Proxy Pod's image pull Secrets.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec
             */
            imagePullSecrets?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodImagePullSecrets[]
            /**
             * Labels that will be added to the proxy Pod.
             * Any labels specified here will be merged with the default labels
             * applied to the Pod by the Tailscale Kubernetes operator.
             * Label keys and values must be valid Kubernetes label keys and values.
             * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set
             */
            labels?: { [key: string]: string }
            /**
             * Proxy Pod's node name.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#scheduling
             */
            nodeName?: string
            /**
             * Proxy Pod's node selector.
             * By default Tailscale Kubernetes operator does not apply any node
             * selector.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#scheduling
             */
            nodeSelector?: { [key: string]: string }
            /**
             * Proxy Pod's security context.
             * By default Tailscale Kubernetes operator does not apply any Pod
             * security context.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context-2
             */
            securityContext?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodSecurityContext
            /**
             * Configuration for the proxy container running tailscale.
             */
            tailscaleContainer?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleContainer
            /**
             * Configuration for the proxy init container that enables forwarding.
             */
            tailscaleInitContainer?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleInitContainer
            /**
             * Proxy Pod's tolerations.
             * By default Tailscale Kubernetes operator does not apply any
             * tolerations.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#scheduling
             */
            tolerations?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTolerations[]
            /**
             * Proxy Pod's topology spread constraints.
             * By default Tailscale Kubernetes operator does not apply any topology spread constraints.
             * https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/
             */
            topologySpreadConstraints?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTopologySpreadConstraints[]
        }

        /**
         * Proxy Pod's affinity rules.
         * By default, the Tailscale Kubernetes operator does not apply any affinity rules.
         * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#affinity
         */
        export interface ProxyClassSpecStatefulSetPodAffinity {
            /**
             * Describes node affinity scheduling rules for the pod.
             */
            nodeAffinity?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityNodeAffinity
            /**
             * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
             */
            podAffinity?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAffinity
            /**
             * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
             */
            podAntiAffinity?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAntiAffinity
        }

        /**
         * Describes node affinity scheduling rules for the pod.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityNodeAffinity {
            /**
             * The scheduler will prefer to schedule pods to nodes that satisfy
             * the affinity expressions specified by this field, but it may choose
             * a node that violates one or more of the expressions. The node that is
             * most preferred is the one with the greatest sum of weights, i.e.
             * for each node that meets all of the scheduling requirements (resource
             * request, requiredDuringScheduling affinity expressions, etc.),
             * compute a sum by iterating through the elements of this field and adding
             * "weight" to the sum if the node matches the corresponding matchExpressions; the
             * node(s) with the highest sum are the most preferred.
             */
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[]
            /**
             * If the affinity requirements specified by this field are not met at
             * scheduling time, the pod will not be scheduled onto the node.
             * If the affinity requirements specified by this field cease to be met
             * at some point during pod execution (e.g. due to an update), the system
             * may or may not try to eventually evict the pod from its node.
             */
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
        }

        /**
         * An empty preferred scheduling term matches all objects with implicit weight 0
         * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
         */
        export interface ProxyClassSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            /**
             * A node selector term, associated with the corresponding weight.
             */
            preference: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
            /**
             * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
             */
            weight: number
        }

        /**
         * A node selector term, associated with the corresponding weight.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            /**
             * A list of node selector requirements by node's labels.
             */
            matchExpressions?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[]
            /**
             * A list of node selector requirements by node's fields.
             */
            matchFields?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[]
        }

        /**
         * A node selector requirement is a selector that contains values, a key, and an operator
         * that relates the key and values.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            /**
             * The label key that the selector applies to.
             */
            key: string
            /**
             * Represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
             */
            operator: string
            /**
             * An array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. If the operator is Gt or Lt, the values
             * array must have a single element, which will be interpreted as an integer.
             * This array is replaced during a strategic merge patch.
             */
            values?: string[]
        }

        /**
         * A node selector requirement is a selector that contains values, a key, and an operator
         * that relates the key and values.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            /**
             * The label key that the selector applies to.
             */
            key: string
            /**
             * Represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
             */
            operator: string
            /**
             * An array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. If the operator is Gt or Lt, the values
             * array must have a single element, which will be interpreted as an integer.
             * This array is replaced during a strategic merge patch.
             */
            values?: string[]
        }

        /**
         * If the affinity requirements specified by this field are not met at
         * scheduling time, the pod will not be scheduled onto the node.
         * If the affinity requirements specified by this field cease to be met
         * at some point during pod execution (e.g. due to an update), the system
         * may or may not try to eventually evict the pod from its node.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            /**
             * Required. A list of node selector terms. The terms are ORed.
             */
            nodeSelectorTerms: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[]
        }

        /**
         * A null or empty node selector term matches no objects. The requirements of
         * them are ANDed.
         * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            /**
             * A list of node selector requirements by node's labels.
             */
            matchExpressions?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[]
            /**
             * A list of node selector requirements by node's fields.
             */
            matchFields?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[]
        }

        /**
         * A node selector requirement is a selector that contains values, a key, and an operator
         * that relates the key and values.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            /**
             * The label key that the selector applies to.
             */
            key: string
            /**
             * Represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
             */
            operator: string
            /**
             * An array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. If the operator is Gt or Lt, the values
             * array must have a single element, which will be interpreted as an integer.
             * This array is replaced during a strategic merge patch.
             */
            values?: string[]
        }

        /**
         * A node selector requirement is a selector that contains values, a key, and an operator
         * that relates the key and values.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            /**
             * The label key that the selector applies to.
             */
            key: string
            /**
             * Represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
             */
            operator: string
            /**
             * An array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. If the operator is Gt or Lt, the values
             * array must have a single element, which will be interpreted as an integer.
             * This array is replaced during a strategic merge patch.
             */
            values?: string[]
        }

        /**
         * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAffinity {
            /**
             * The scheduler will prefer to schedule pods to nodes that satisfy
             * the affinity expressions specified by this field, but it may choose
             * a node that violates one or more of the expressions. The node that is
             * most preferred is the one with the greatest sum of weights, i.e.
             * for each node that meets all of the scheduling requirements (resource
             * request, requiredDuringScheduling affinity expressions, etc.),
             * compute a sum by iterating through the elements of this field and adding
             * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
             * node(s) with the highest sum are the most preferred.
             */
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[]
            /**
             * If the affinity requirements specified by this field are not met at
             * scheduling time, the pod will not be scheduled onto the node.
             * If the affinity requirements specified by this field cease to be met
             * at some point during pod execution (e.g. due to a pod label update), the
             * system may or may not try to eventually evict the pod from its node.
             * When there are multiple elements, the lists of nodes corresponding to each
             * podAffinityTerm are intersected, i.e. all terms must be satisfied.
             */
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[]
        }

        /**
         * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            /**
             * Required. A pod affinity term, associated with the corresponding weight.
             */
            podAffinityTerm: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
            /**
             * weight associated with matching the corresponding podAffinityTerm,
             * in the range 1-100.
             */
            weight: number
        }

        /**
         * Required. A pod affinity term, associated with the corresponding weight.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            /**
             * A label query over a set of resources, in this case pods.
             * If it's null, this PodAffinityTerm matches with no Pods.
             */
            labelSelector?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
            /**
             * MatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
             * Also, matchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            matchLabelKeys?: string[]
            /**
             * MismatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
             * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            mismatchLabelKeys?: string[]
            /**
             * A label query over the set of namespaces that the term applies to.
             * The term is applied to the union of the namespaces selected by this field
             * and the ones listed in the namespaces field.
             * null selector and null or empty namespaces list means "this pod's namespace".
             * An empty selector ({}) matches all namespaces.
             */
            namespaceSelector?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
            /**
             * namespaces specifies a static list of namespace names that the term applies to.
             * The term is applied to the union of the namespaces listed in this field
             * and the ones selected by namespaceSelector.
             * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
             */
            namespaces?: string[]
            /**
             * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
             * the labelSelector in the specified namespaces, where co-located is defined as running on a node
             * whose value of the label with key topologyKey matches that of any node on which any of the
             * selected pods is running.
             * Empty topologyKey is not allowed.
             */
            topologyKey: string
        }

        /**
         * A label query over a set of resources, in this case pods.
         * If it's null, this PodAffinityTerm matches with no Pods.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[]
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: { [key: string]: string }
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: string[]
        }

        /**
         * A label query over the set of namespaces that the term applies to.
         * The term is applied to the union of the namespaces selected by this field
         * and the ones listed in the namespaces field.
         * null selector and null or empty namespaces list means "this pod's namespace".
         * An empty selector ({}) matches all namespaces.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[]
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: { [key: string]: string }
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: string[]
        }

        /**
         * Defines a set of pods (namely those matching the labelSelector
         * relative to the given namespace(s)) that this pod should be
         * co-located (affinity) or not co-located (anti-affinity) with,
         * where co-located is defined as running on a node whose value of
         * the label with key <topologyKey> matches that of any node on which
         * a pod of the set of pods is running
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            /**
             * A label query over a set of resources, in this case pods.
             * If it's null, this PodAffinityTerm matches with no Pods.
             */
            labelSelector?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
            /**
             * MatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
             * Also, matchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            matchLabelKeys?: string[]
            /**
             * MismatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
             * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            mismatchLabelKeys?: string[]
            /**
             * A label query over the set of namespaces that the term applies to.
             * The term is applied to the union of the namespaces selected by this field
             * and the ones listed in the namespaces field.
             * null selector and null or empty namespaces list means "this pod's namespace".
             * An empty selector ({}) matches all namespaces.
             */
            namespaceSelector?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
            /**
             * namespaces specifies a static list of namespace names that the term applies to.
             * The term is applied to the union of the namespaces listed in this field
             * and the ones selected by namespaceSelector.
             * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
             */
            namespaces?: string[]
            /**
             * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
             * the labelSelector in the specified namespaces, where co-located is defined as running on a node
             * whose value of the label with key topologyKey matches that of any node on which any of the
             * selected pods is running.
             * Empty topologyKey is not allowed.
             */
            topologyKey: string
        }

        /**
         * A label query over a set of resources, in this case pods.
         * If it's null, this PodAffinityTerm matches with no Pods.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[]
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: { [key: string]: string }
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: string[]
        }

        /**
         * A label query over the set of namespaces that the term applies to.
         * The term is applied to the union of the namespaces selected by this field
         * and the ones listed in the namespaces field.
         * null selector and null or empty namespaces list means "this pod's namespace".
         * An empty selector ({}) matches all namespaces.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[]
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: { [key: string]: string }
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: string[]
        }

        /**
         * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAntiAffinity {
            /**
             * The scheduler will prefer to schedule pods to nodes that satisfy
             * the anti-affinity expressions specified by this field, but it may choose
             * a node that violates one or more of the expressions. The node that is
             * most preferred is the one with the greatest sum of weights, i.e.
             * for each node that meets all of the scheduling requirements (resource
             * request, requiredDuringScheduling anti-affinity expressions, etc.),
             * compute a sum by iterating through the elements of this field and adding
             * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
             * node(s) with the highest sum are the most preferred.
             */
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[]
            /**
             * If the anti-affinity requirements specified by this field are not met at
             * scheduling time, the pod will not be scheduled onto the node.
             * If the anti-affinity requirements specified by this field cease to be met
             * at some point during pod execution (e.g. due to a pod label update), the
             * system may or may not try to eventually evict the pod from its node.
             * When there are multiple elements, the lists of nodes corresponding to each
             * podAffinityTerm are intersected, i.e. all terms must be satisfied.
             */
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[]
        }

        /**
         * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            /**
             * Required. A pod affinity term, associated with the corresponding weight.
             */
            podAffinityTerm: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
            /**
             * weight associated with matching the corresponding podAffinityTerm,
             * in the range 1-100.
             */
            weight: number
        }

        /**
         * Required. A pod affinity term, associated with the corresponding weight.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            /**
             * A label query over a set of resources, in this case pods.
             * If it's null, this PodAffinityTerm matches with no Pods.
             */
            labelSelector?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
            /**
             * MatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
             * Also, matchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            matchLabelKeys?: string[]
            /**
             * MismatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
             * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            mismatchLabelKeys?: string[]
            /**
             * A label query over the set of namespaces that the term applies to.
             * The term is applied to the union of the namespaces selected by this field
             * and the ones listed in the namespaces field.
             * null selector and null or empty namespaces list means "this pod's namespace".
             * An empty selector ({}) matches all namespaces.
             */
            namespaceSelector?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
            /**
             * namespaces specifies a static list of namespace names that the term applies to.
             * The term is applied to the union of the namespaces listed in this field
             * and the ones selected by namespaceSelector.
             * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
             */
            namespaces?: string[]
            /**
             * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
             * the labelSelector in the specified namespaces, where co-located is defined as running on a node
             * whose value of the label with key topologyKey matches that of any node on which any of the
             * selected pods is running.
             * Empty topologyKey is not allowed.
             */
            topologyKey: string
        }

        /**
         * A label query over a set of resources, in this case pods.
         * If it's null, this PodAffinityTerm matches with no Pods.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[]
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: { [key: string]: string }
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: string[]
        }

        /**
         * A label query over the set of namespaces that the term applies to.
         * The term is applied to the union of the namespaces selected by this field
         * and the ones listed in the namespaces field.
         * null selector and null or empty namespaces list means "this pod's namespace".
         * An empty selector ({}) matches all namespaces.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[]
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: { [key: string]: string }
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: string[]
        }

        /**
         * Defines a set of pods (namely those matching the labelSelector
         * relative to the given namespace(s)) that this pod should be
         * co-located (affinity) or not co-located (anti-affinity) with,
         * where co-located is defined as running on a node whose value of
         * the label with key <topologyKey> matches that of any node on which
         * a pod of the set of pods is running
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            /**
             * A label query over a set of resources, in this case pods.
             * If it's null, this PodAffinityTerm matches with no Pods.
             */
            labelSelector?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
            /**
             * MatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
             * Also, matchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            matchLabelKeys?: string[]
            /**
             * MismatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
             * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            mismatchLabelKeys?: string[]
            /**
             * A label query over the set of namespaces that the term applies to.
             * The term is applied to the union of the namespaces selected by this field
             * and the ones listed in the namespaces field.
             * null selector and null or empty namespaces list means "this pod's namespace".
             * An empty selector ({}) matches all namespaces.
             */
            namespaceSelector?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
            /**
             * namespaces specifies a static list of namespace names that the term applies to.
             * The term is applied to the union of the namespaces listed in this field
             * and the ones selected by namespaceSelector.
             * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
             */
            namespaces?: string[]
            /**
             * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
             * the labelSelector in the specified namespaces, where co-located is defined as running on a node
             * whose value of the label with key topologyKey matches that of any node on which any of the
             * selected pods is running.
             * Empty topologyKey is not allowed.
             */
            topologyKey: string
        }

        /**
         * A label query over a set of resources, in this case pods.
         * If it's null, this PodAffinityTerm matches with no Pods.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[]
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: { [key: string]: string }
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: string[]
        }

        /**
         * A label query over the set of namespaces that the term applies to.
         * The term is applied to the union of the namespaces selected by this field
         * and the ones listed in the namespaces field.
         * null selector and null or empty namespaces list means "this pod's namespace".
         * An empty selector ({}) matches all namespaces.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[]
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: { [key: string]: string }
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface ProxyClassSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: string[]
        }

        /**
         * LocalObjectReference contains enough information to let you locate the
         * referenced object inside the same namespace.
         */
        export interface ProxyClassSpecStatefulSetPodImagePullSecrets {
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string
        }
        /**
         * proxyClassSpecStatefulSetPodImagePullSecretsProvideDefaults sets the appropriate defaults for ProxyClassSpecStatefulSetPodImagePullSecrets
         */
        export function proxyClassSpecStatefulSetPodImagePullSecretsProvideDefaults(
            val: ProxyClassSpecStatefulSetPodImagePullSecrets,
        ): ProxyClassSpecStatefulSetPodImagePullSecrets {
            return {
                ...val,
                name: val.name ?? '',
            }
        }

        /**
         * Proxy Pod's security context.
         * By default Tailscale Kubernetes operator does not apply any Pod
         * security context.
         * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context-2
         */
        export interface ProxyClassSpecStatefulSetPodSecurityContext {
            /**
             * appArmorProfile is the AppArmor options to use by the containers in this pod.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            appArmorProfile?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodSecurityContextAppArmorProfile
            /**
             * A special supplemental group that applies to all containers in a pod.
             * Some volume types allow the Kubelet to change the ownership of that volume
             * to be owned by the pod:
             *
             * 1. The owning GID will be the FSGroup
             * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
             * 3. The permission bits are OR'd with rw-rw----
             *
             * If unset, the Kubelet will not modify the ownership and permissions of any volume.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            fsGroup?: number
            /**
             * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
             * before being exposed inside Pod. This field will only apply to
             * volume types which support fsGroup based ownership(and permissions).
             * It will have no effect on ephemeral volume types such as: secret, configmaps
             * and emptydir.
             * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            fsGroupChangePolicy?: string
            /**
             * The GID to run the entrypoint of the container process.
             * Uses runtime default if unset.
             * May also be set in SecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence
             * for that container.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsGroup?: number
            /**
             * Indicates that the container must run as a non-root user.
             * If true, the Kubelet will validate the image at runtime to ensure that it
             * does not run as UID 0 (root) and fail to start the container if it does.
             * If unset or false, no such validation will be performed.
             * May also be set in SecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsNonRoot?: boolean
            /**
             * The UID to run the entrypoint of the container process.
             * Defaults to user specified in image metadata if unspecified.
             * May also be set in SecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence
             * for that container.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsUser?: number
            /**
             * The SELinux context to be applied to all containers.
             * If unspecified, the container runtime will allocate a random SELinux context for each
             * container.  May also be set in SecurityContext.  If set in
             * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
             * takes precedence for that container.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            seLinuxOptions?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodSecurityContextSeLinuxOptions
            /**
             * The seccomp options to use by the containers in this pod.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            seccompProfile?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodSecurityContextSeccompProfile
            /**
             * A list of groups applied to the first process run in each container, in addition
             * to the container's primary GID, the fsGroup (if specified), and group memberships
             * defined in the container image for the uid of the container process. If unspecified,
             * no additional groups are added to any container. Note that group memberships
             * defined in the container image for the uid of the container process are still effective,
             * even if they are not included in this list.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            supplementalGroups?: number[]
            /**
             * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
             * sysctls (by the container runtime) might fail to launch.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            sysctls?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodSecurityContextSysctls[]
            /**
             * The Windows specific settings applied to all containers.
             * If unspecified, the options within a container's SecurityContext will be used.
             * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is linux.
             */
            windowsOptions?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodSecurityContextWindowsOptions
        }

        /**
         * appArmorProfile is the AppArmor options to use by the containers in this pod.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface ProxyClassSpecStatefulSetPodSecurityContextAppArmorProfile {
            /**
             * localhostProfile indicates a profile loaded on the node that should be used.
             * The profile must be preconfigured on the node to work.
             * Must match the loaded name of the profile.
             * Must be set if and only if type is "Localhost".
             */
            localhostProfile?: string
            /**
             * type indicates which kind of AppArmor profile will be applied.
             * Valid options are:
             *   Localhost - a profile pre-loaded on the node.
             *   RuntimeDefault - the container runtime's default profile.
             *   Unconfined - no AppArmor enforcement.
             */
            type: string
        }

        /**
         * The SELinux context to be applied to all containers.
         * If unspecified, the container runtime will allocate a random SELinux context for each
         * container.  May also be set in SecurityContext.  If set in
         * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
         * takes precedence for that container.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface ProxyClassSpecStatefulSetPodSecurityContextSeLinuxOptions {
            /**
             * Level is SELinux level label that applies to the container.
             */
            level?: string
            /**
             * Role is a SELinux role label that applies to the container.
             */
            role?: string
            /**
             * Type is a SELinux type label that applies to the container.
             */
            type?: string
            /**
             * User is a SELinux user label that applies to the container.
             */
            user?: string
        }

        /**
         * The seccomp options to use by the containers in this pod.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface ProxyClassSpecStatefulSetPodSecurityContextSeccompProfile {
            /**
             * localhostProfile indicates a profile defined in a file on the node should be used.
             * The profile must be preconfigured on the node to work.
             * Must be a descending path, relative to the kubelet's configured seccomp profile location.
             * Must be set if type is "Localhost". Must NOT be set for any other type.
             */
            localhostProfile?: string
            /**
             * type indicates which kind of seccomp profile will be applied.
             * Valid options are:
             *
             * Localhost - a profile defined in a file on the node should be used.
             * RuntimeDefault - the container runtime default profile should be used.
             * Unconfined - no profile should be applied.
             */
            type: string
        }

        /**
         * Sysctl defines a kernel parameter to be set
         */
        export interface ProxyClassSpecStatefulSetPodSecurityContextSysctls {
            /**
             * Name of a property to set
             */
            name: string
            /**
             * Value of a property to set
             */
            value: string
        }

        /**
         * The Windows specific settings applied to all containers.
         * If unspecified, the options within a container's SecurityContext will be used.
         * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
         * Note that this field cannot be set when spec.os.name is linux.
         */
        export interface ProxyClassSpecStatefulSetPodSecurityContextWindowsOptions {
            /**
             * GMSACredentialSpec is where the GMSA admission webhook
             * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
             * GMSA credential spec named by the GMSACredentialSpecName field.
             */
            gmsaCredentialSpec?: string
            /**
             * GMSACredentialSpecName is the name of the GMSA credential spec to use.
             */
            gmsaCredentialSpecName?: string
            /**
             * HostProcess determines if a container should be run as a 'Host Process' container.
             * All of a Pod's containers must have the same effective HostProcess value
             * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
             * In addition, if HostProcess is true then HostNetwork must also be set to true.
             */
            hostProcess?: boolean
            /**
             * The UserName in Windows to run the entrypoint of the container process.
             * Defaults to the user specified in image metadata if unspecified.
             * May also be set in PodSecurityContext. If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsUserName?: string
        }

        /**
         * Configuration for the proxy container running tailscale.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleContainer {
            /**
             * Configuration for enabling extra debug information in the container.
             * Not recommended for production use.
             */
            debug?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleContainerDebug
            /**
             * List of environment variables to set in the container.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#environment-variables
             * Note that environment variables provided here will take precedence
             * over Tailscale-specific environment variables set by the operator,
             * however running proxies with custom values for Tailscale environment
             * variables (i.e TS_USERSPACE) is not recommended and might break in
             * the future.
             */
            env?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleContainerEnv[]
            /**
             * Container image name. By default images are pulled from
             * docker.io/tailscale/tailscale, but the official images are also
             * available at ghcr.io/tailscale/tailscale. Specifying image name here
             * will override any proxy image values specified via the Kubernetes
             * operator's Helm chart values or PROXY_IMAGE env var in the operator
             * Deployment.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#image
             */
            image?: string
            /**
             * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#image
             */
            imagePullPolicy?: string
            /**
             * Container resource requirements.
             * By default Tailscale Kubernetes operator does not apply any resource
             * requirements. The amount of resources required wil depend on the
             * amount of resources the operator needs to parse, usage patterns and
             * cluster size.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#resources
             */
            resources?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleContainerResources
            /**
             * Container security context.
             * Security context specified here will override the security context set by the operator.
             * By default the operator sets the Tailscale container and the Tailscale init container to privileged
             * for proxies created for Tailscale ingress and egress Service, Connector and ProxyGroup.
             * You can reduce the permissions of the Tailscale container to cap NET_ADMIN by
             * installing device plugin in your cluster and configuring the proxies tun device to be created
             * by the device plugin, see  https://github.com/tailscale/tailscale/issues/10814#issuecomment-2479977752
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context
             */
            securityContext?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleContainerSecurityContext
        }

        /**
         * Configuration for enabling extra debug information in the container.
         * Not recommended for production use.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleContainerDebug {
            /**
             * Enable tailscaled's HTTP pprof endpoints at <pod-ip>:9001/debug/pprof/
             * and internal debug metrics endpoint at <pod-ip>:9001/debug/metrics, where
             * 9001 is a container port named "debug". The endpoints and their responses
             * may change in backwards incompatible ways in the future, and should not
             * be considered stable.
             *
             * In 1.78.x and 1.80.x, this setting will default to the value of
             * .spec.metrics.enable, and requests to the "metrics" port matching the
             * mux pattern /debug/ will be forwarded to the "debug" port. In 1.82.x,
             * this setting will default to false, and no requests will be proxied.
             */
            enable?: boolean
        }

        export interface ProxyClassSpecStatefulSetPodTailscaleContainerEnv {
            /**
             * Name of the environment variable. Must be a C_IDENTIFIER.
             */
            name: string
            /**
             * Variable references $(VAR_NAME) are expanded using the previously defined
             *  environment variables in the container and any service environment
             * variables. If a variable cannot be resolved, the reference in the input
             * string will be unchanged. Double $$ are reduced to a single $, which
             * allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
             * produce the string literal "$(VAR_NAME)". Escaped references will never
             * be expanded, regardless of whether the variable exists or not. Defaults
             * to "".
             */
            value?: string
        }

        /**
         * Container resource requirements.
         * By default Tailscale Kubernetes operator does not apply any resource
         * requirements. The amount of resources required wil depend on the
         * amount of resources the operator needs to parse, usage patterns and
         * cluster size.
         * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#resources
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleContainerResources {
            /**
             * Claims lists the names of resources, defined in spec.resourceClaims,
             * that are used by this container.
             *
             * This is an alpha field and requires enabling the
             * DynamicResourceAllocation feature gate.
             *
             * This field is immutable. It can only be set for containers.
             */
            claims?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleContainerResourcesClaims[]
            /**
             * Limits describes the maximum amount of compute resources allowed.
             * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
             */
            limits?: { [key: string]: number | string }
            /**
             * Requests describes the minimum amount of compute resources required.
             * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
             * otherwise to an implementation-defined value. Requests cannot exceed Limits.
             * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
             */
            requests?: { [key: string]: number | string }
        }

        /**
         * ResourceClaim references one entry in PodSpec.ResourceClaims.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleContainerResourcesClaims {
            /**
             * Name must match the name of one entry in pod.spec.resourceClaims of
             * the Pod where this field is used. It makes that resource available
             * inside a container.
             */
            name: string
        }

        /**
         * Container security context.
         * Security context specified here will override the security context set by the operator.
         * By default the operator sets the Tailscale container and the Tailscale init container to privileged
         * for proxies created for Tailscale ingress and egress Service, Connector and ProxyGroup.
         * You can reduce the permissions of the Tailscale container to cap NET_ADMIN by
         * installing device plugin in your cluster and configuring the proxies tun device to be created
         * by the device plugin, see  https://github.com/tailscale/tailscale/issues/10814#issuecomment-2479977752
         * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleContainerSecurityContext {
            /**
             * AllowPrivilegeEscalation controls whether a process can gain more
             * privileges than its parent process. This bool directly controls if
             * the no_new_privs flag will be set on the container process.
             * AllowPrivilegeEscalation is true always when the container is:
             * 1) run as Privileged
             * 2) has CAP_SYS_ADMIN
             * Note that this field cannot be set when spec.os.name is windows.
             */
            allowPrivilegeEscalation?: boolean
            /**
             * appArmorProfile is the AppArmor options to use by this container. If set, this profile
             * overrides the pod's appArmorProfile.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            appArmorProfile?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleContainerSecurityContextAppArmorProfile
            /**
             * The capabilities to add/drop when running containers.
             * Defaults to the default set of capabilities granted by the container runtime.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            capabilities?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleContainerSecurityContextCapabilities
            /**
             * Run container in privileged mode.
             * Processes in privileged containers are essentially equivalent to root on the host.
             * Defaults to false.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            privileged?: boolean
            /**
             * procMount denotes the type of proc mount to use for the containers.
             * The default is DefaultProcMount which uses the container runtime defaults for
             * readonly paths and masked paths.
             * This requires the ProcMountType feature flag to be enabled.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            procMount?: string
            /**
             * Whether this container has a read-only root filesystem.
             * Default is false.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            readOnlyRootFilesystem?: boolean
            /**
             * The GID to run the entrypoint of the container process.
             * Uses runtime default if unset.
             * May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsGroup?: number
            /**
             * Indicates that the container must run as a non-root user.
             * If true, the Kubelet will validate the image at runtime to ensure that it
             * does not run as UID 0 (root) and fail to start the container if it does.
             * If unset or false, no such validation will be performed.
             * May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsNonRoot?: boolean
            /**
             * The UID to run the entrypoint of the container process.
             * Defaults to user specified in image metadata if unspecified.
             * May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsUser?: number
            /**
             * The SELinux context to be applied to the container.
             * If unspecified, the container runtime will allocate a random SELinux context for each
             * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            seLinuxOptions?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleContainerSecurityContextSeLinuxOptions
            /**
             * The seccomp options to use by this container. If seccomp options are
             * provided at both the pod & container level, the container options
             * override the pod options.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            seccompProfile?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleContainerSecurityContextSeccompProfile
            /**
             * The Windows specific settings applied to all containers.
             * If unspecified, the options from the PodSecurityContext will be used.
             * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is linux.
             */
            windowsOptions?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleContainerSecurityContextWindowsOptions
        }

        /**
         * appArmorProfile is the AppArmor options to use by this container. If set, this profile
         * overrides the pod's appArmorProfile.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleContainerSecurityContextAppArmorProfile {
            /**
             * localhostProfile indicates a profile loaded on the node that should be used.
             * The profile must be preconfigured on the node to work.
             * Must match the loaded name of the profile.
             * Must be set if and only if type is "Localhost".
             */
            localhostProfile?: string
            /**
             * type indicates which kind of AppArmor profile will be applied.
             * Valid options are:
             *   Localhost - a profile pre-loaded on the node.
             *   RuntimeDefault - the container runtime's default profile.
             *   Unconfined - no AppArmor enforcement.
             */
            type: string
        }

        /**
         * The capabilities to add/drop when running containers.
         * Defaults to the default set of capabilities granted by the container runtime.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleContainerSecurityContextCapabilities {
            /**
             * Added capabilities
             */
            add?: string[]
            /**
             * Removed capabilities
             */
            drop?: string[]
        }

        /**
         * The SELinux context to be applied to the container.
         * If unspecified, the container runtime will allocate a random SELinux context for each
         * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
         * PodSecurityContext, the value specified in SecurityContext takes precedence.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleContainerSecurityContextSeLinuxOptions {
            /**
             * Level is SELinux level label that applies to the container.
             */
            level?: string
            /**
             * Role is a SELinux role label that applies to the container.
             */
            role?: string
            /**
             * Type is a SELinux type label that applies to the container.
             */
            type?: string
            /**
             * User is a SELinux user label that applies to the container.
             */
            user?: string
        }

        /**
         * The seccomp options to use by this container. If seccomp options are
         * provided at both the pod & container level, the container options
         * override the pod options.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleContainerSecurityContextSeccompProfile {
            /**
             * localhostProfile indicates a profile defined in a file on the node should be used.
             * The profile must be preconfigured on the node to work.
             * Must be a descending path, relative to the kubelet's configured seccomp profile location.
             * Must be set if type is "Localhost". Must NOT be set for any other type.
             */
            localhostProfile?: string
            /**
             * type indicates which kind of seccomp profile will be applied.
             * Valid options are:
             *
             * Localhost - a profile defined in a file on the node should be used.
             * RuntimeDefault - the container runtime default profile should be used.
             * Unconfined - no profile should be applied.
             */
            type: string
        }

        /**
         * The Windows specific settings applied to all containers.
         * If unspecified, the options from the PodSecurityContext will be used.
         * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
         * Note that this field cannot be set when spec.os.name is linux.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleContainerSecurityContextWindowsOptions {
            /**
             * GMSACredentialSpec is where the GMSA admission webhook
             * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
             * GMSA credential spec named by the GMSACredentialSpecName field.
             */
            gmsaCredentialSpec?: string
            /**
             * GMSACredentialSpecName is the name of the GMSA credential spec to use.
             */
            gmsaCredentialSpecName?: string
            /**
             * HostProcess determines if a container should be run as a 'Host Process' container.
             * All of a Pod's containers must have the same effective HostProcess value
             * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
             * In addition, if HostProcess is true then HostNetwork must also be set to true.
             */
            hostProcess?: boolean
            /**
             * The UserName in Windows to run the entrypoint of the container process.
             * Defaults to the user specified in image metadata if unspecified.
             * May also be set in PodSecurityContext. If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsUserName?: string
        }

        /**
         * Configuration for the proxy init container that enables forwarding.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleInitContainer {
            /**
             * Configuration for enabling extra debug information in the container.
             * Not recommended for production use.
             */
            debug?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleInitContainerDebug
            /**
             * List of environment variables to set in the container.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#environment-variables
             * Note that environment variables provided here will take precedence
             * over Tailscale-specific environment variables set by the operator,
             * however running proxies with custom values for Tailscale environment
             * variables (i.e TS_USERSPACE) is not recommended and might break in
             * the future.
             */
            env?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleInitContainerEnv[]
            /**
             * Container image name. By default images are pulled from
             * docker.io/tailscale/tailscale, but the official images are also
             * available at ghcr.io/tailscale/tailscale. Specifying image name here
             * will override any proxy image values specified via the Kubernetes
             * operator's Helm chart values or PROXY_IMAGE env var in the operator
             * Deployment.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#image
             */
            image?: string
            /**
             * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#image
             */
            imagePullPolicy?: string
            /**
             * Container resource requirements.
             * By default Tailscale Kubernetes operator does not apply any resource
             * requirements. The amount of resources required wil depend on the
             * amount of resources the operator needs to parse, usage patterns and
             * cluster size.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#resources
             */
            resources?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleInitContainerResources
            /**
             * Container security context.
             * Security context specified here will override the security context set by the operator.
             * By default the operator sets the Tailscale container and the Tailscale init container to privileged
             * for proxies created for Tailscale ingress and egress Service, Connector and ProxyGroup.
             * You can reduce the permissions of the Tailscale container to cap NET_ADMIN by
             * installing device plugin in your cluster and configuring the proxies tun device to be created
             * by the device plugin, see  https://github.com/tailscale/tailscale/issues/10814#issuecomment-2479977752
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context
             */
            securityContext?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleInitContainerSecurityContext
        }

        /**
         * Configuration for enabling extra debug information in the container.
         * Not recommended for production use.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleInitContainerDebug {
            /**
             * Enable tailscaled's HTTP pprof endpoints at <pod-ip>:9001/debug/pprof/
             * and internal debug metrics endpoint at <pod-ip>:9001/debug/metrics, where
             * 9001 is a container port named "debug". The endpoints and their responses
             * may change in backwards incompatible ways in the future, and should not
             * be considered stable.
             *
             * In 1.78.x and 1.80.x, this setting will default to the value of
             * .spec.metrics.enable, and requests to the "metrics" port matching the
             * mux pattern /debug/ will be forwarded to the "debug" port. In 1.82.x,
             * this setting will default to false, and no requests will be proxied.
             */
            enable?: boolean
        }

        export interface ProxyClassSpecStatefulSetPodTailscaleInitContainerEnv {
            /**
             * Name of the environment variable. Must be a C_IDENTIFIER.
             */
            name: string
            /**
             * Variable references $(VAR_NAME) are expanded using the previously defined
             *  environment variables in the container and any service environment
             * variables. If a variable cannot be resolved, the reference in the input
             * string will be unchanged. Double $$ are reduced to a single $, which
             * allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
             * produce the string literal "$(VAR_NAME)". Escaped references will never
             * be expanded, regardless of whether the variable exists or not. Defaults
             * to "".
             */
            value?: string
        }

        /**
         * Container resource requirements.
         * By default Tailscale Kubernetes operator does not apply any resource
         * requirements. The amount of resources required wil depend on the
         * amount of resources the operator needs to parse, usage patterns and
         * cluster size.
         * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#resources
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleInitContainerResources {
            /**
             * Claims lists the names of resources, defined in spec.resourceClaims,
             * that are used by this container.
             *
             * This is an alpha field and requires enabling the
             * DynamicResourceAllocation feature gate.
             *
             * This field is immutable. It can only be set for containers.
             */
            claims?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleInitContainerResourcesClaims[]
            /**
             * Limits describes the maximum amount of compute resources allowed.
             * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
             */
            limits?: { [key: string]: number | string }
            /**
             * Requests describes the minimum amount of compute resources required.
             * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
             * otherwise to an implementation-defined value. Requests cannot exceed Limits.
             * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
             */
            requests?: { [key: string]: number | string }
        }

        /**
         * ResourceClaim references one entry in PodSpec.ResourceClaims.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleInitContainerResourcesClaims {
            /**
             * Name must match the name of one entry in pod.spec.resourceClaims of
             * the Pod where this field is used. It makes that resource available
             * inside a container.
             */
            name: string
        }

        /**
         * Container security context.
         * Security context specified here will override the security context set by the operator.
         * By default the operator sets the Tailscale container and the Tailscale init container to privileged
         * for proxies created for Tailscale ingress and egress Service, Connector and ProxyGroup.
         * You can reduce the permissions of the Tailscale container to cap NET_ADMIN by
         * installing device plugin in your cluster and configuring the proxies tun device to be created
         * by the device plugin, see  https://github.com/tailscale/tailscale/issues/10814#issuecomment-2479977752
         * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleInitContainerSecurityContext {
            /**
             * AllowPrivilegeEscalation controls whether a process can gain more
             * privileges than its parent process. This bool directly controls if
             * the no_new_privs flag will be set on the container process.
             * AllowPrivilegeEscalation is true always when the container is:
             * 1) run as Privileged
             * 2) has CAP_SYS_ADMIN
             * Note that this field cannot be set when spec.os.name is windows.
             */
            allowPrivilegeEscalation?: boolean
            /**
             * appArmorProfile is the AppArmor options to use by this container. If set, this profile
             * overrides the pod's appArmorProfile.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            appArmorProfile?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleInitContainerSecurityContextAppArmorProfile
            /**
             * The capabilities to add/drop when running containers.
             * Defaults to the default set of capabilities granted by the container runtime.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            capabilities?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleInitContainerSecurityContextCapabilities
            /**
             * Run container in privileged mode.
             * Processes in privileged containers are essentially equivalent to root on the host.
             * Defaults to false.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            privileged?: boolean
            /**
             * procMount denotes the type of proc mount to use for the containers.
             * The default is DefaultProcMount which uses the container runtime defaults for
             * readonly paths and masked paths.
             * This requires the ProcMountType feature flag to be enabled.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            procMount?: string
            /**
             * Whether this container has a read-only root filesystem.
             * Default is false.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            readOnlyRootFilesystem?: boolean
            /**
             * The GID to run the entrypoint of the container process.
             * Uses runtime default if unset.
             * May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsGroup?: number
            /**
             * Indicates that the container must run as a non-root user.
             * If true, the Kubelet will validate the image at runtime to ensure that it
             * does not run as UID 0 (root) and fail to start the container if it does.
             * If unset or false, no such validation will be performed.
             * May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsNonRoot?: boolean
            /**
             * The UID to run the entrypoint of the container process.
             * Defaults to user specified in image metadata if unspecified.
             * May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsUser?: number
            /**
             * The SELinux context to be applied to the container.
             * If unspecified, the container runtime will allocate a random SELinux context for each
             * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            seLinuxOptions?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleInitContainerSecurityContextSeLinuxOptions
            /**
             * The seccomp options to use by this container. If seccomp options are
             * provided at both the pod & container level, the container options
             * override the pod options.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            seccompProfile?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleInitContainerSecurityContextSeccompProfile
            /**
             * The Windows specific settings applied to all containers.
             * If unspecified, the options from the PodSecurityContext will be used.
             * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is linux.
             */
            windowsOptions?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTailscaleInitContainerSecurityContextWindowsOptions
        }

        /**
         * appArmorProfile is the AppArmor options to use by this container. If set, this profile
         * overrides the pod's appArmorProfile.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleInitContainerSecurityContextAppArmorProfile {
            /**
             * localhostProfile indicates a profile loaded on the node that should be used.
             * The profile must be preconfigured on the node to work.
             * Must match the loaded name of the profile.
             * Must be set if and only if type is "Localhost".
             */
            localhostProfile?: string
            /**
             * type indicates which kind of AppArmor profile will be applied.
             * Valid options are:
             *   Localhost - a profile pre-loaded on the node.
             *   RuntimeDefault - the container runtime's default profile.
             *   Unconfined - no AppArmor enforcement.
             */
            type: string
        }

        /**
         * The capabilities to add/drop when running containers.
         * Defaults to the default set of capabilities granted by the container runtime.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleInitContainerSecurityContextCapabilities {
            /**
             * Added capabilities
             */
            add?: string[]
            /**
             * Removed capabilities
             */
            drop?: string[]
        }

        /**
         * The SELinux context to be applied to the container.
         * If unspecified, the container runtime will allocate a random SELinux context for each
         * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
         * PodSecurityContext, the value specified in SecurityContext takes precedence.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleInitContainerSecurityContextSeLinuxOptions {
            /**
             * Level is SELinux level label that applies to the container.
             */
            level?: string
            /**
             * Role is a SELinux role label that applies to the container.
             */
            role?: string
            /**
             * Type is a SELinux type label that applies to the container.
             */
            type?: string
            /**
             * User is a SELinux user label that applies to the container.
             */
            user?: string
        }

        /**
         * The seccomp options to use by this container. If seccomp options are
         * provided at both the pod & container level, the container options
         * override the pod options.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleInitContainerSecurityContextSeccompProfile {
            /**
             * localhostProfile indicates a profile defined in a file on the node should be used.
             * The profile must be preconfigured on the node to work.
             * Must be a descending path, relative to the kubelet's configured seccomp profile location.
             * Must be set if type is "Localhost". Must NOT be set for any other type.
             */
            localhostProfile?: string
            /**
             * type indicates which kind of seccomp profile will be applied.
             * Valid options are:
             *
             * Localhost - a profile defined in a file on the node should be used.
             * RuntimeDefault - the container runtime default profile should be used.
             * Unconfined - no profile should be applied.
             */
            type: string
        }

        /**
         * The Windows specific settings applied to all containers.
         * If unspecified, the options from the PodSecurityContext will be used.
         * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
         * Note that this field cannot be set when spec.os.name is linux.
         */
        export interface ProxyClassSpecStatefulSetPodTailscaleInitContainerSecurityContextWindowsOptions {
            /**
             * GMSACredentialSpec is where the GMSA admission webhook
             * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
             * GMSA credential spec named by the GMSACredentialSpecName field.
             */
            gmsaCredentialSpec?: string
            /**
             * GMSACredentialSpecName is the name of the GMSA credential spec to use.
             */
            gmsaCredentialSpecName?: string
            /**
             * HostProcess determines if a container should be run as a 'Host Process' container.
             * All of a Pod's containers must have the same effective HostProcess value
             * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
             * In addition, if HostProcess is true then HostNetwork must also be set to true.
             */
            hostProcess?: boolean
            /**
             * The UserName in Windows to run the entrypoint of the container process.
             * Defaults to the user specified in image metadata if unspecified.
             * May also be set in PodSecurityContext. If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsUserName?: string
        }

        /**
         * The pod this Toleration is attached to tolerates any taint that matches
         * the triple <key,value,effect> using the matching operator <operator>.
         */
        export interface ProxyClassSpecStatefulSetPodTolerations {
            /**
             * Effect indicates the taint effect to match. Empty means match all taint effects.
             * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
             */
            effect?: string
            /**
             * Key is the taint key that the toleration applies to. Empty means match all taint keys.
             * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
             */
            key?: string
            /**
             * Operator represents a key's relationship to the value.
             * Valid operators are Exists and Equal. Defaults to Equal.
             * Exists is equivalent to wildcard for value, so that a pod can
             * tolerate all taints of a particular category.
             */
            operator?: string
            /**
             * TolerationSeconds represents the period of time the toleration (which must be
             * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
             * it is not set, which means tolerate the taint forever (do not evict). Zero and
             * negative values will be treated as 0 (evict immediately) by the system.
             */
            tolerationSeconds?: number
            /**
             * Value is the taint value the toleration matches to.
             * If the operator is Exists, the value should be empty, otherwise just a regular string.
             */
            value?: string
        }

        /**
         * TopologySpreadConstraint specifies how to spread matching pods among the given topology.
         */
        export interface ProxyClassSpecStatefulSetPodTopologySpreadConstraints {
            /**
             * LabelSelector is used to find matching pods.
             * Pods that match this label selector are counted to determine the number of pods
             * in their corresponding topology domain.
             */
            labelSelector?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTopologySpreadConstraintsLabelSelector
            /**
             * MatchLabelKeys is a set of pod label keys to select the pods over which
             * spreading will be calculated. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are ANDed with labelSelector
             * to select the group of existing pods over which spreading will be calculated
             * for the incoming pod. The same key is forbidden to exist in both MatchLabelKeys and LabelSelector.
             * MatchLabelKeys cannot be set when LabelSelector isn't set.
             * Keys that don't exist in the incoming pod labels will
             * be ignored. A null or empty list means only match against labelSelector.
             *
             * This is a beta field and requires the MatchLabelKeysInPodTopologySpread feature gate to be enabled (enabled by default).
             */
            matchLabelKeys?: string[]
            /**
             * MaxSkew describes the degree to which pods may be unevenly distributed.
             * When `whenUnsatisfiable=DoNotSchedule`, it is the maximum permitted difference
             * between the number of matching pods in the target topology and the global minimum.
             * The global minimum is the minimum number of matching pods in an eligible domain
             * or zero if the number of eligible domains is less than MinDomains.
             * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
             * labelSelector spread as 2/2/1:
             * In this case, the global minimum is 1.
             * | zone1 | zone2 | zone3 |
             * |  P P  |  P P  |   P   |
             * - if MaxSkew is 1, incoming pod can only be scheduled to zone3 to become 2/2/2;
             * scheduling it onto zone1(zone2) would make the ActualSkew(3-1) on zone1(zone2)
             * violate MaxSkew(1).
             * - if MaxSkew is 2, incoming pod can be scheduled onto any zone.
             * When `whenUnsatisfiable=ScheduleAnyway`, it is used to give higher precedence
             * to topologies that satisfy it.
             * It's a required field. Default value is 1 and 0 is not allowed.
             */
            maxSkew: number
            /**
             * MinDomains indicates a minimum number of eligible domains.
             * When the number of eligible domains with matching topology keys is less than minDomains,
             * Pod Topology Spread treats "global minimum" as 0, and then the calculation of Skew is performed.
             * And when the number of eligible domains with matching topology keys equals or greater than minDomains,
             * this value has no effect on scheduling.
             * As a result, when the number of eligible domains is less than minDomains,
             * scheduler won't schedule more than maxSkew Pods to those domains.
             * If value is nil, the constraint behaves as if MinDomains is equal to 1.
             * Valid values are integers greater than 0.
             * When value is not nil, WhenUnsatisfiable must be DoNotSchedule.
             *
             * For example, in a 3-zone cluster, MaxSkew is set to 2, MinDomains is set to 5 and pods with the same
             * labelSelector spread as 2/2/2:
             * | zone1 | zone2 | zone3 |
             * |  P P  |  P P  |  P P  |
             * The number of domains is less than 5(MinDomains), so "global minimum" is treated as 0.
             * In this situation, new pod with the same labelSelector cannot be scheduled,
             * because computed skew will be 3(3 - 0) if new Pod is scheduled to any of the three zones,
             * it will violate MaxSkew.
             */
            minDomains?: number
            /**
             * NodeAffinityPolicy indicates how we will treat Pod's nodeAffinity/nodeSelector
             * when calculating pod topology spread skew. Options are:
             * - Honor: only nodes matching nodeAffinity/nodeSelector are included in the calculations.
             * - Ignore: nodeAffinity/nodeSelector are ignored. All nodes are included in the calculations.
             *
             * If this value is nil, the behavior is equivalent to the Honor policy.
             * This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
             */
            nodeAffinityPolicy?: string
            /**
             * NodeTaintsPolicy indicates how we will treat node taints when calculating
             * pod topology spread skew. Options are:
             * - Honor: nodes without taints, along with tainted nodes for which the incoming pod
             * has a toleration, are included.
             * - Ignore: node taints are ignored. All nodes are included.
             *
             * If this value is nil, the behavior is equivalent to the Ignore policy.
             * This is a beta-level feature default enabled by the NodeInclusionPolicyInPodTopologySpread feature flag.
             */
            nodeTaintsPolicy?: string
            /**
             * TopologyKey is the key of node labels. Nodes that have a label with this key
             * and identical values are considered to be in the same topology.
             * We consider each <key, value> as a "bucket", and try to put balanced number
             * of pods into each bucket.
             * We define a domain as a particular instance of a topology.
             * Also, we define an eligible domain as a domain whose nodes meet the requirements of
             * nodeAffinityPolicy and nodeTaintsPolicy.
             * e.g. If TopologyKey is "kubernetes.io/hostname", each Node is a domain of that topology.
             * And, if TopologyKey is "topology.kubernetes.io/zone", each zone is a domain of that topology.
             * It's a required field.
             */
            topologyKey: string
            /**
             * WhenUnsatisfiable indicates how to deal with a pod if it doesn't satisfy
             * the spread constraint.
             * - DoNotSchedule (default) tells the scheduler not to schedule it.
             * - ScheduleAnyway tells the scheduler to schedule the pod in any location,
             *   but giving higher precedence to topologies that would help reduce the
             *   skew.
             * A constraint is considered "Unsatisfiable" for an incoming pod
             * if and only if every possible node assignment for that pod would violate
             * "MaxSkew" on some topology.
             * For example, in a 3-zone cluster, MaxSkew is set to 1, and pods with the same
             * labelSelector spread as 3/1/1:
             * | zone1 | zone2 | zone3 |
             * | P P P |   P   |   P   |
             * If WhenUnsatisfiable is set to DoNotSchedule, incoming pod can only be scheduled
             * to zone2(zone3) to become 3/2/1(3/1/2) as ActualSkew(2-1) on zone2(zone3) satisfies
             * MaxSkew(1). In other words, the cluster can still be imbalanced, but scheduler
             * won't make it *more* imbalanced.
             * It's a required field.
             */
            whenUnsatisfiable: string
        }

        /**
         * LabelSelector is used to find matching pods.
         * Pods that match this label selector are counted to determine the number of pods
         * in their corresponding topology domain.
         */
        export interface ProxyClassSpecStatefulSetPodTopologySpreadConstraintsLabelSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.tailscale.v1alpha1.ProxyClassSpecStatefulSetPodTopologySpreadConstraintsLabelSelectorMatchExpressions[]
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: { [key: string]: string }
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface ProxyClassSpecStatefulSetPodTopologySpreadConstraintsLabelSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: string[]
        }

        /**
         * TailscaleConfig contains options to configure the tailscale-specific
         * parameters of proxies.
         */
        export interface ProxyClassSpecTailscale {
            /**
             * AcceptRoutes can be set to true to make the proxy instance accept
             * routes advertized by other nodes on the tailnet, such as subnet
             * routes.
             * This is equivalent of passing --accept-routes flag to a tailscale Linux client.
             * https://tailscale.com/kb/1019/subnets#use-your-subnet-routes-from-other-devices
             * Defaults to false.
             */
            acceptRoutes?: boolean
        }

        /**
         * Status of the ProxyClass. This is set and managed automatically.
         * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
         */
        export interface ProxyClassStatus {
            /**
             * List of status conditions to indicate the status of the ProxyClass.
             * Known condition types are `ProxyClassReady`.
             */
            conditions?: outputs.tailscale.v1alpha1.ProxyClassStatusConditions[]
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         */
        export interface ProxyClassStatusConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: string
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: number
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: string
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: string
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             */
            type: string
        }

        /**
         * Spec describes the desired ProxyGroup instances.
         */
        export interface ProxyGroupSpec {
            /**
             * HostnamePrefix is the hostname prefix to use for tailnet devices created
             * by the ProxyGroup. Each device will have the integer number from its
             * StatefulSet pod appended to this prefix to form the full hostname.
             * HostnamePrefix can contain lower case letters, numbers and dashes, it
             * must not start with a dash and must be between 1 and 62 characters long.
             */
            hostnamePrefix?: string
            /**
             * ProxyClass is the name of the ProxyClass custom resource that contains
             * configuration options that should be applied to the resources created
             * for this ProxyGroup. If unset, and there is no default ProxyClass
             * configured, the operator will create resources with the default
             * configuration.
             */
            proxyClass?: string
            /**
             * Replicas specifies how many replicas to create the StatefulSet with.
             * Defaults to 2.
             */
            replicas?: number
            /**
             * Tags that the Tailscale devices will be tagged with. Defaults to [tag:k8s].
             * If you specify custom tags here, make sure you also make the operator
             * an owner of these tags.
             * See  https://tailscale.com/kb/1236/kubernetes-operator/#setting-up-the-kubernetes-operator.
             * Tags cannot be changed once a ProxyGroup device has been created.
             * Tag values must be in form ^tag:[a-zA-Z][a-zA-Z0-9-]*$.
             */
            tags?: string[]
            /**
             * Type of the ProxyGroup proxies. Currently the only supported type is egress.
             */
            type: string
        }

        /**
         * ProxyGroupStatus describes the status of the ProxyGroup resources. This is
         * set and managed by the Tailscale operator.
         */
        export interface ProxyGroupStatus {
            /**
             * List of status conditions to indicate the status of the ProxyGroup
             * resources. Known condition types are `ProxyGroupReady`.
             */
            conditions?: outputs.tailscale.v1alpha1.ProxyGroupStatusConditions[]
            /**
             * List of tailnet devices associated with the ProxyGroup StatefulSet.
             */
            devices?: outputs.tailscale.v1alpha1.ProxyGroupStatusDevices[]
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         */
        export interface ProxyGroupStatusConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: string
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: number
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: string
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: string
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             */
            type: string
        }

        export interface ProxyGroupStatusDevices {
            /**
             * Hostname is the fully qualified domain name of the device.
             * If MagicDNS is enabled in your tailnet, it is the MagicDNS name of the
             * node.
             */
            hostname: string
            /**
             * TailnetIPs is the set of tailnet IP addresses (both IPv4 and IPv6)
             * assigned to the device.
             */
            tailnetIPs?: string[]
        }

        /**
         * Spec describes the desired recorder instance.
         */
        export interface RecorderSpec {
            /**
             * Set to true to enable the Recorder UI. The UI lists and plays recorded sessions.
             * The UI will be served at <MagicDNS name of the recorder>:443. Defaults to false.
             * Corresponds to --ui tsrecorder flag https://tailscale.com/kb/1246/tailscale-ssh-session-recording#deploy-a-recorder-node.
             * Required if S3 storage is not set up, to ensure that recordings are accessible.
             */
            enableUI?: boolean
            /**
             * Configuration parameters for the Recorder's StatefulSet. The operator
             * deploys a StatefulSet for each Recorder resource.
             */
            statefulSet?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSet
            /**
             * Configure where to store session recordings. By default, recordings will
             * be stored in a local ephemeral volume, and will not be persisted past the
             * lifetime of a specific pod.
             */
            storage?: outputs.tailscale.v1alpha1.RecorderSpecStorage
            /**
             * Tags that the Tailscale device will be tagged with. Defaults to [tag:k8s].
             * If you specify custom tags here, make sure you also make the operator
             * an owner of these tags.
             * See  https://tailscale.com/kb/1236/kubernetes-operator/#setting-up-the-kubernetes-operator.
             * Tags cannot be changed once a Recorder node has been created.
             * Tag values must be in form ^tag:[a-zA-Z][a-zA-Z0-9-]*$.
             */
            tags?: string[]
        }

        /**
         * Configuration parameters for the Recorder's StatefulSet. The operator
         * deploys a StatefulSet for each Recorder resource.
         */
        export interface RecorderSpecStatefulSet {
            /**
             * Annotations that will be added to the StatefulSet created for the Recorder.
             * Any Annotations specified here will be merged with the default annotations
             * applied to the StatefulSet by the operator.
             * https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/#syntax-and-character-set
             */
            annotations?: { [key: string]: string }
            /**
             * Labels that will be added to the StatefulSet created for the Recorder.
             * Any labels specified here will be merged with the default labels applied
             * to the StatefulSet by the operator.
             * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set
             */
            labels?: { [key: string]: string }
            /**
             * Configuration for pods created by the Recorder's StatefulSet.
             */
            pod?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPod
        }

        /**
         * Configuration for pods created by the Recorder's StatefulSet.
         */
        export interface RecorderSpecStatefulSetPod {
            /**
             * Affinity rules for Recorder Pods. By default, the operator does not
             * apply any affinity rules.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#affinity
             */
            affinity?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinity
            /**
             * Annotations that will be added to Recorder Pods.Any annotations
             * specified here will be merged with the default annotations applied to
             * the Pod by the operator.
             * https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/#syntax-and-character-set
             */
            annotations?: { [key: string]: string }
            /**
             * Configuration for the Recorder container running tailscale.
             */
            container?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodContainer
            /**
             * Image pull Secrets for Recorder Pods.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#PodSpec
             */
            imagePullSecrets?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodImagePullSecrets[]
            /**
             * Labels that will be added to Recorder Pods. Any labels specified here
             * will be merged with the default labels applied to the Pod by the operator.
             * https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#syntax-and-character-set
             */
            labels?: { [key: string]: string }
            /**
             * Node selector rules for Recorder Pods. By default, the operator does
             * not apply any node selector rules.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#scheduling
             */
            nodeSelector?: { [key: string]: string }
            /**
             * Security context for Recorder Pods. By default, the operator does not
             * apply any Pod security context.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context-2
             */
            securityContext?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodSecurityContext
            /**
             * Tolerations for Recorder Pods. By default, the operator does not apply
             * any tolerations.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#scheduling
             */
            tolerations?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodTolerations[]
        }

        /**
         * Affinity rules for Recorder Pods. By default, the operator does not
         * apply any affinity rules.
         * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#affinity
         */
        export interface RecorderSpecStatefulSetPodAffinity {
            /**
             * Describes node affinity scheduling rules for the pod.
             */
            nodeAffinity?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityNodeAffinity
            /**
             * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
             */
            podAffinity?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAffinity
            /**
             * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
             */
            podAntiAffinity?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAntiAffinity
        }

        /**
         * Describes node affinity scheduling rules for the pod.
         */
        export interface RecorderSpecStatefulSetPodAffinityNodeAffinity {
            /**
             * The scheduler will prefer to schedule pods to nodes that satisfy
             * the affinity expressions specified by this field, but it may choose
             * a node that violates one or more of the expressions. The node that is
             * most preferred is the one with the greatest sum of weights, i.e.
             * for each node that meets all of the scheduling requirements (resource
             * request, requiredDuringScheduling affinity expressions, etc.),
             * compute a sum by iterating through the elements of this field and adding
             * "weight" to the sum if the node matches the corresponding matchExpressions; the
             * node(s) with the highest sum are the most preferred.
             */
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution[]
            /**
             * If the affinity requirements specified by this field are not met at
             * scheduling time, the pod will not be scheduled onto the node.
             * If the affinity requirements specified by this field cease to be met
             * at some point during pod execution (e.g. due to an update), the system
             * may or may not try to eventually evict the pod from its node.
             */
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution
        }

        /**
         * An empty preferred scheduling term matches all objects with implicit weight 0
         * (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).
         */
        export interface RecorderSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            /**
             * A node selector term, associated with the corresponding weight.
             */
            preference: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference
            /**
             * Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.
             */
            weight: number
        }

        /**
         * A node selector term, associated with the corresponding weight.
         */
        export interface RecorderSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreference {
            /**
             * A list of node selector requirements by node's labels.
             */
            matchExpressions?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions[]
            /**
             * A list of node selector requirements by node's fields.
             */
            matchFields?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields[]
        }

        /**
         * A node selector requirement is a selector that contains values, a key, and an operator
         * that relates the key and values.
         */
        export interface RecorderSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchExpressions {
            /**
             * The label key that the selector applies to.
             */
            key: string
            /**
             * Represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
             */
            operator: string
            /**
             * An array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. If the operator is Gt or Lt, the values
             * array must have a single element, which will be interpreted as an integer.
             * This array is replaced during a strategic merge patch.
             */
            values?: string[]
        }

        /**
         * A node selector requirement is a selector that contains values, a key, and an operator
         * that relates the key and values.
         */
        export interface RecorderSpecStatefulSetPodAffinityNodeAffinityPreferredDuringSchedulingIgnoredDuringExecutionPreferenceMatchFields {
            /**
             * The label key that the selector applies to.
             */
            key: string
            /**
             * Represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
             */
            operator: string
            /**
             * An array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. If the operator is Gt or Lt, the values
             * array must have a single element, which will be interpreted as an integer.
             * This array is replaced during a strategic merge patch.
             */
            values?: string[]
        }

        /**
         * If the affinity requirements specified by this field are not met at
         * scheduling time, the pod will not be scheduled onto the node.
         * If the affinity requirements specified by this field cease to be met
         * at some point during pod execution (e.g. due to an update), the system
         * may or may not try to eventually evict the pod from its node.
         */
        export interface RecorderSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            /**
             * Required. A list of node selector terms. The terms are ORed.
             */
            nodeSelectorTerms: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms[]
        }

        /**
         * A null or empty node selector term matches no objects. The requirements of
         * them are ANDed.
         * The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.
         */
        export interface RecorderSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTerms {
            /**
             * A list of node selector requirements by node's labels.
             */
            matchExpressions?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions[]
            /**
             * A list of node selector requirements by node's fields.
             */
            matchFields?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields[]
        }

        /**
         * A node selector requirement is a selector that contains values, a key, and an operator
         * that relates the key and values.
         */
        export interface RecorderSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchExpressions {
            /**
             * The label key that the selector applies to.
             */
            key: string
            /**
             * Represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
             */
            operator: string
            /**
             * An array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. If the operator is Gt or Lt, the values
             * array must have a single element, which will be interpreted as an integer.
             * This array is replaced during a strategic merge patch.
             */
            values?: string[]
        }

        /**
         * A node selector requirement is a selector that contains values, a key, and an operator
         * that relates the key and values.
         */
        export interface RecorderSpecStatefulSetPodAffinityNodeAffinityRequiredDuringSchedulingIgnoredDuringExecutionNodeSelectorTermsMatchFields {
            /**
             * The label key that the selector applies to.
             */
            key: string
            /**
             * Represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.
             */
            operator: string
            /**
             * An array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. If the operator is Gt or Lt, the values
             * array must have a single element, which will be interpreted as an integer.
             * This array is replaced during a strategic merge patch.
             */
            values?: string[]
        }

        /**
         * Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAffinity {
            /**
             * The scheduler will prefer to schedule pods to nodes that satisfy
             * the affinity expressions specified by this field, but it may choose
             * a node that violates one or more of the expressions. The node that is
             * most preferred is the one with the greatest sum of weights, i.e.
             * for each node that meets all of the scheduling requirements (resource
             * request, requiredDuringScheduling affinity expressions, etc.),
             * compute a sum by iterating through the elements of this field and adding
             * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
             * node(s) with the highest sum are the most preferred.
             */
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution[]
            /**
             * If the affinity requirements specified by this field are not met at
             * scheduling time, the pod will not be scheduled onto the node.
             * If the affinity requirements specified by this field cease to be met
             * at some point during pod execution (e.g. due to a pod label update), the
             * system may or may not try to eventually evict the pod from its node.
             * When there are multiple elements, the lists of nodes corresponding to each
             * podAffinityTerm are intersected, i.e. all terms must be satisfied.
             */
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution[]
        }

        /**
         * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            /**
             * Required. A pod affinity term, associated with the corresponding weight.
             */
            podAffinityTerm: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
            /**
             * weight associated with matching the corresponding podAffinityTerm,
             * in the range 1-100.
             */
            weight: number
        }

        /**
         * Required. A pod affinity term, associated with the corresponding weight.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            /**
             * A label query over a set of resources, in this case pods.
             * If it's null, this PodAffinityTerm matches with no Pods.
             */
            labelSelector?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
            /**
             * MatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
             * Also, matchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            matchLabelKeys?: string[]
            /**
             * MismatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
             * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            mismatchLabelKeys?: string[]
            /**
             * A label query over the set of namespaces that the term applies to.
             * The term is applied to the union of the namespaces selected by this field
             * and the ones listed in the namespaces field.
             * null selector and null or empty namespaces list means "this pod's namespace".
             * An empty selector ({}) matches all namespaces.
             */
            namespaceSelector?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
            /**
             * namespaces specifies a static list of namespace names that the term applies to.
             * The term is applied to the union of the namespaces listed in this field
             * and the ones selected by namespaceSelector.
             * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
             */
            namespaces?: string[]
            /**
             * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
             * the labelSelector in the specified namespaces, where co-located is defined as running on a node
             * whose value of the label with key topologyKey matches that of any node on which any of the
             * selected pods is running.
             * Empty topologyKey is not allowed.
             */
            topologyKey: string
        }

        /**
         * A label query over a set of resources, in this case pods.
         * If it's null, this PodAffinityTerm matches with no Pods.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[]
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: { [key: string]: string }
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: string[]
        }

        /**
         * A label query over the set of namespaces that the term applies to.
         * The term is applied to the union of the namespaces selected by this field
         * and the ones listed in the namespaces field.
         * null selector and null or empty namespaces list means "this pod's namespace".
         * An empty selector ({}) matches all namespaces.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[]
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: { [key: string]: string }
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: string[]
        }

        /**
         * Defines a set of pods (namely those matching the labelSelector
         * relative to the given namespace(s)) that this pod should be
         * co-located (affinity) or not co-located (anti-affinity) with,
         * where co-located is defined as running on a node whose value of
         * the label with key <topologyKey> matches that of any node on which
         * a pod of the set of pods is running
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            /**
             * A label query over a set of resources, in this case pods.
             * If it's null, this PodAffinityTerm matches with no Pods.
             */
            labelSelector?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
            /**
             * MatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
             * Also, matchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            matchLabelKeys?: string[]
            /**
             * MismatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
             * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            mismatchLabelKeys?: string[]
            /**
             * A label query over the set of namespaces that the term applies to.
             * The term is applied to the union of the namespaces selected by this field
             * and the ones listed in the namespaces field.
             * null selector and null or empty namespaces list means "this pod's namespace".
             * An empty selector ({}) matches all namespaces.
             */
            namespaceSelector?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
            /**
             * namespaces specifies a static list of namespace names that the term applies to.
             * The term is applied to the union of the namespaces listed in this field
             * and the ones selected by namespaceSelector.
             * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
             */
            namespaces?: string[]
            /**
             * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
             * the labelSelector in the specified namespaces, where co-located is defined as running on a node
             * whose value of the label with key topologyKey matches that of any node on which any of the
             * selected pods is running.
             * Empty topologyKey is not allowed.
             */
            topologyKey: string
        }

        /**
         * A label query over a set of resources, in this case pods.
         * If it's null, this PodAffinityTerm matches with no Pods.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[]
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: { [key: string]: string }
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: string[]
        }

        /**
         * A label query over the set of namespaces that the term applies to.
         * The term is applied to the union of the namespaces selected by this field
         * and the ones listed in the namespaces field.
         * null selector and null or empty namespaces list means "this pod's namespace".
         * An empty selector ({}) matches all namespaces.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[]
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: { [key: string]: string }
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: string[]
        }

        /**
         * Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAntiAffinity {
            /**
             * The scheduler will prefer to schedule pods to nodes that satisfy
             * the anti-affinity expressions specified by this field, but it may choose
             * a node that violates one or more of the expressions. The node that is
             * most preferred is the one with the greatest sum of weights, i.e.
             * for each node that meets all of the scheduling requirements (resource
             * request, requiredDuringScheduling anti-affinity expressions, etc.),
             * compute a sum by iterating through the elements of this field and adding
             * "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the
             * node(s) with the highest sum are the most preferred.
             */
            preferredDuringSchedulingIgnoredDuringExecution?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution[]
            /**
             * If the anti-affinity requirements specified by this field are not met at
             * scheduling time, the pod will not be scheduled onto the node.
             * If the anti-affinity requirements specified by this field cease to be met
             * at some point during pod execution (e.g. due to a pod label update), the
             * system may or may not try to eventually evict the pod from its node.
             * When there are multiple elements, the lists of nodes corresponding to each
             * podAffinityTerm are intersected, i.e. all terms must be satisfied.
             */
            requiredDuringSchedulingIgnoredDuringExecution?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution[]
        }

        /**
         * The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecution {
            /**
             * Required. A pod affinity term, associated with the corresponding weight.
             */
            podAffinityTerm: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm
            /**
             * weight associated with matching the corresponding podAffinityTerm,
             * in the range 1-100.
             */
            weight: number
        }

        /**
         * Required. A pod affinity term, associated with the corresponding weight.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTerm {
            /**
             * A label query over a set of resources, in this case pods.
             * If it's null, this PodAffinityTerm matches with no Pods.
             */
            labelSelector?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector
            /**
             * MatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
             * Also, matchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            matchLabelKeys?: string[]
            /**
             * MismatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
             * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            mismatchLabelKeys?: string[]
            /**
             * A label query over the set of namespaces that the term applies to.
             * The term is applied to the union of the namespaces selected by this field
             * and the ones listed in the namespaces field.
             * null selector and null or empty namespaces list means "this pod's namespace".
             * An empty selector ({}) matches all namespaces.
             */
            namespaceSelector?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector
            /**
             * namespaces specifies a static list of namespace names that the term applies to.
             * The term is applied to the union of the namespaces listed in this field
             * and the ones selected by namespaceSelector.
             * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
             */
            namespaces?: string[]
            /**
             * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
             * the labelSelector in the specified namespaces, where co-located is defined as running on a node
             * whose value of the label with key topologyKey matches that of any node on which any of the
             * selected pods is running.
             * Empty topologyKey is not allowed.
             */
            topologyKey: string
        }

        /**
         * A label query over a set of resources, in this case pods.
         * If it's null, this PodAffinityTerm matches with no Pods.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions[]
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: { [key: string]: string }
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermLabelSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: string[]
        }

        /**
         * A label query over the set of namespaces that the term applies to.
         * The term is applied to the union of the namespaces selected by this field
         * and the ones listed in the namespaces field.
         * null selector and null or empty namespaces list means "this pod's namespace".
         * An empty selector ({}) matches all namespaces.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions[]
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: { [key: string]: string }
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAntiAffinityPreferredDuringSchedulingIgnoredDuringExecutionPodAffinityTermNamespaceSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: string[]
        }

        /**
         * Defines a set of pods (namely those matching the labelSelector
         * relative to the given namespace(s)) that this pod should be
         * co-located (affinity) or not co-located (anti-affinity) with,
         * where co-located is defined as running on a node whose value of
         * the label with key <topologyKey> matches that of any node on which
         * a pod of the set of pods is running
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecution {
            /**
             * A label query over a set of resources, in this case pods.
             * If it's null, this PodAffinityTerm matches with no Pods.
             */
            labelSelector?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector
            /**
             * MatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key in (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both matchLabelKeys and labelSelector.
             * Also, matchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            matchLabelKeys?: string[]
            /**
             * MismatchLabelKeys is a set of pod label keys to select which pods will
             * be taken into consideration. The keys are used to lookup values from the
             * incoming pod labels, those key-value labels are merged with `labelSelector` as `key notin (value)`
             * to select the group of existing pods which pods will be taken into consideration
             * for the incoming pod's pod (anti) affinity. Keys that don't exist in the incoming
             * pod labels will be ignored. The default value is empty.
             * The same key is forbidden to exist in both mismatchLabelKeys and labelSelector.
             * Also, mismatchLabelKeys cannot be set when labelSelector isn't set.
             * This is an alpha field and requires enabling MatchLabelKeysInPodAffinity feature gate.
             */
            mismatchLabelKeys?: string[]
            /**
             * A label query over the set of namespaces that the term applies to.
             * The term is applied to the union of the namespaces selected by this field
             * and the ones listed in the namespaces field.
             * null selector and null or empty namespaces list means "this pod's namespace".
             * An empty selector ({}) matches all namespaces.
             */
            namespaceSelector?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector
            /**
             * namespaces specifies a static list of namespace names that the term applies to.
             * The term is applied to the union of the namespaces listed in this field
             * and the ones selected by namespaceSelector.
             * null or empty namespaces list and null namespaceSelector means "this pod's namespace".
             */
            namespaces?: string[]
            /**
             * This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching
             * the labelSelector in the specified namespaces, where co-located is defined as running on a node
             * whose value of the label with key topologyKey matches that of any node on which any of the
             * selected pods is running.
             * Empty topologyKey is not allowed.
             */
            topologyKey: string
        }

        /**
         * A label query over a set of resources, in this case pods.
         * If it's null, this PodAffinityTerm matches with no Pods.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions[]
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: { [key: string]: string }
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionLabelSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: string[]
        }

        /**
         * A label query over the set of namespaces that the term applies to.
         * The term is applied to the union of the namespaces selected by this field
         * and the ones listed in the namespaces field.
         * null selector and null or empty namespaces list means "this pod's namespace".
         * An empty selector ({}) matches all namespaces.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelector {
            /**
             * matchExpressions is a list of label selector requirements. The requirements are ANDed.
             */
            matchExpressions?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions[]
            /**
             * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
             * map is equivalent to an element of matchExpressions, whose key field is "key", the
             * operator is "In", and the values array contains only "value". The requirements are ANDed.
             */
            matchLabels?: { [key: string]: string }
        }

        /**
         * A label selector requirement is a selector that contains values, a key, and an operator that
         * relates the key and values.
         */
        export interface RecorderSpecStatefulSetPodAffinityPodAntiAffinityRequiredDuringSchedulingIgnoredDuringExecutionNamespaceSelectorMatchExpressions {
            /**
             * key is the label key that the selector applies to.
             */
            key: string
            /**
             * operator represents a key's relationship to a set of values.
             * Valid operators are In, NotIn, Exists and DoesNotExist.
             */
            operator: string
            /**
             * values is an array of string values. If the operator is In or NotIn,
             * the values array must be non-empty. If the operator is Exists or DoesNotExist,
             * the values array must be empty. This array is replaced during a strategic
             * merge patch.
             */
            values?: string[]
        }

        /**
         * Configuration for the Recorder container running tailscale.
         */
        export interface RecorderSpecStatefulSetPodContainer {
            /**
             * List of environment variables to set in the container.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#environment-variables
             * Note that environment variables provided here will take precedence
             * over Tailscale-specific environment variables set by the operator,
             * however running proxies with custom values for Tailscale environment
             * variables (i.e TS_USERSPACE) is not recommended and might break in
             * the future.
             */
            env?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodContainerEnv[]
            /**
             * Container image name including tag. Defaults to docker.io/tailscale/tsrecorder
             * with the same tag as the operator, but the official images are also
             * available at ghcr.io/tailscale/tsrecorder.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#image
             */
            image?: string
            /**
             * Image pull policy. One of Always, Never, IfNotPresent. Defaults to Always.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#image
             */
            imagePullPolicy?: string
            /**
             * Container resource requirements.
             * By default, the operator does not apply any resource requirements. The
             * amount of resources required wil depend on the volume of recordings sent.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#resources
             */
            resources?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodContainerResources
            /**
             * Container security context. By default, the operator does not apply any
             * container security context.
             * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context
             */
            securityContext?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodContainerSecurityContext
        }

        export interface RecorderSpecStatefulSetPodContainerEnv {
            /**
             * Name of the environment variable. Must be a C_IDENTIFIER.
             */
            name: string
            /**
             * Variable references $(VAR_NAME) are expanded using the previously defined
             *  environment variables in the container and any service environment
             * variables. If a variable cannot be resolved, the reference in the input
             * string will be unchanged. Double $$ are reduced to a single $, which
             * allows for escaping the $(VAR_NAME) syntax: i.e. "$$(VAR_NAME)" will
             * produce the string literal "$(VAR_NAME)". Escaped references will never
             * be expanded, regardless of whether the variable exists or not. Defaults
             * to "".
             */
            value?: string
        }

        /**
         * Container resource requirements.
         * By default, the operator does not apply any resource requirements. The
         * amount of resources required wil depend on the volume of recordings sent.
         * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#resources
         */
        export interface RecorderSpecStatefulSetPodContainerResources {
            /**
             * Claims lists the names of resources, defined in spec.resourceClaims,
             * that are used by this container.
             *
             * This is an alpha field and requires enabling the
             * DynamicResourceAllocation feature gate.
             *
             * This field is immutable. It can only be set for containers.
             */
            claims?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodContainerResourcesClaims[]
            /**
             * Limits describes the maximum amount of compute resources allowed.
             * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
             */
            limits?: { [key: string]: number | string }
            /**
             * Requests describes the minimum amount of compute resources required.
             * If Requests is omitted for a container, it defaults to Limits if that is explicitly specified,
             * otherwise to an implementation-defined value. Requests cannot exceed Limits.
             * More info: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
             */
            requests?: { [key: string]: number | string }
        }

        /**
         * ResourceClaim references one entry in PodSpec.ResourceClaims.
         */
        export interface RecorderSpecStatefulSetPodContainerResourcesClaims {
            /**
             * Name must match the name of one entry in pod.spec.resourceClaims of
             * the Pod where this field is used. It makes that resource available
             * inside a container.
             */
            name: string
        }

        /**
         * Container security context. By default, the operator does not apply any
         * container security context.
         * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context
         */
        export interface RecorderSpecStatefulSetPodContainerSecurityContext {
            /**
             * AllowPrivilegeEscalation controls whether a process can gain more
             * privileges than its parent process. This bool directly controls if
             * the no_new_privs flag will be set on the container process.
             * AllowPrivilegeEscalation is true always when the container is:
             * 1) run as Privileged
             * 2) has CAP_SYS_ADMIN
             * Note that this field cannot be set when spec.os.name is windows.
             */
            allowPrivilegeEscalation?: boolean
            /**
             * appArmorProfile is the AppArmor options to use by this container. If set, this profile
             * overrides the pod's appArmorProfile.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            appArmorProfile?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodContainerSecurityContextAppArmorProfile
            /**
             * The capabilities to add/drop when running containers.
             * Defaults to the default set of capabilities granted by the container runtime.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            capabilities?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodContainerSecurityContextCapabilities
            /**
             * Run container in privileged mode.
             * Processes in privileged containers are essentially equivalent to root on the host.
             * Defaults to false.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            privileged?: boolean
            /**
             * procMount denotes the type of proc mount to use for the containers.
             * The default is DefaultProcMount which uses the container runtime defaults for
             * readonly paths and masked paths.
             * This requires the ProcMountType feature flag to be enabled.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            procMount?: string
            /**
             * Whether this container has a read-only root filesystem.
             * Default is false.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            readOnlyRootFilesystem?: boolean
            /**
             * The GID to run the entrypoint of the container process.
             * Uses runtime default if unset.
             * May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsGroup?: number
            /**
             * Indicates that the container must run as a non-root user.
             * If true, the Kubelet will validate the image at runtime to ensure that it
             * does not run as UID 0 (root) and fail to start the container if it does.
             * If unset or false, no such validation will be performed.
             * May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsNonRoot?: boolean
            /**
             * The UID to run the entrypoint of the container process.
             * Defaults to user specified in image metadata if unspecified.
             * May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsUser?: number
            /**
             * The SELinux context to be applied to the container.
             * If unspecified, the container runtime will allocate a random SELinux context for each
             * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            seLinuxOptions?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodContainerSecurityContextSeLinuxOptions
            /**
             * The seccomp options to use by this container. If seccomp options are
             * provided at both the pod & container level, the container options
             * override the pod options.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            seccompProfile?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodContainerSecurityContextSeccompProfile
            /**
             * The Windows specific settings applied to all containers.
             * If unspecified, the options from the PodSecurityContext will be used.
             * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is linux.
             */
            windowsOptions?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodContainerSecurityContextWindowsOptions
        }

        /**
         * appArmorProfile is the AppArmor options to use by this container. If set, this profile
         * overrides the pod's appArmorProfile.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface RecorderSpecStatefulSetPodContainerSecurityContextAppArmorProfile {
            /**
             * localhostProfile indicates a profile loaded on the node that should be used.
             * The profile must be preconfigured on the node to work.
             * Must match the loaded name of the profile.
             * Must be set if and only if type is "Localhost".
             */
            localhostProfile?: string
            /**
             * type indicates which kind of AppArmor profile will be applied.
             * Valid options are:
             *   Localhost - a profile pre-loaded on the node.
             *   RuntimeDefault - the container runtime's default profile.
             *   Unconfined - no AppArmor enforcement.
             */
            type: string
        }

        /**
         * The capabilities to add/drop when running containers.
         * Defaults to the default set of capabilities granted by the container runtime.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface RecorderSpecStatefulSetPodContainerSecurityContextCapabilities {
            /**
             * Added capabilities
             */
            add?: string[]
            /**
             * Removed capabilities
             */
            drop?: string[]
        }

        /**
         * The SELinux context to be applied to the container.
         * If unspecified, the container runtime will allocate a random SELinux context for each
         * container.  May also be set in PodSecurityContext.  If set in both SecurityContext and
         * PodSecurityContext, the value specified in SecurityContext takes precedence.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface RecorderSpecStatefulSetPodContainerSecurityContextSeLinuxOptions {
            /**
             * Level is SELinux level label that applies to the container.
             */
            level?: string
            /**
             * Role is a SELinux role label that applies to the container.
             */
            role?: string
            /**
             * Type is a SELinux type label that applies to the container.
             */
            type?: string
            /**
             * User is a SELinux user label that applies to the container.
             */
            user?: string
        }

        /**
         * The seccomp options to use by this container. If seccomp options are
         * provided at both the pod & container level, the container options
         * override the pod options.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface RecorderSpecStatefulSetPodContainerSecurityContextSeccompProfile {
            /**
             * localhostProfile indicates a profile defined in a file on the node should be used.
             * The profile must be preconfigured on the node to work.
             * Must be a descending path, relative to the kubelet's configured seccomp profile location.
             * Must be set if type is "Localhost". Must NOT be set for any other type.
             */
            localhostProfile?: string
            /**
             * type indicates which kind of seccomp profile will be applied.
             * Valid options are:
             *
             * Localhost - a profile defined in a file on the node should be used.
             * RuntimeDefault - the container runtime default profile should be used.
             * Unconfined - no profile should be applied.
             */
            type: string
        }

        /**
         * The Windows specific settings applied to all containers.
         * If unspecified, the options from the PodSecurityContext will be used.
         * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
         * Note that this field cannot be set when spec.os.name is linux.
         */
        export interface RecorderSpecStatefulSetPodContainerSecurityContextWindowsOptions {
            /**
             * GMSACredentialSpec is where the GMSA admission webhook
             * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
             * GMSA credential spec named by the GMSACredentialSpecName field.
             */
            gmsaCredentialSpec?: string
            /**
             * GMSACredentialSpecName is the name of the GMSA credential spec to use.
             */
            gmsaCredentialSpecName?: string
            /**
             * HostProcess determines if a container should be run as a 'Host Process' container.
             * All of a Pod's containers must have the same effective HostProcess value
             * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
             * In addition, if HostProcess is true then HostNetwork must also be set to true.
             */
            hostProcess?: boolean
            /**
             * The UserName in Windows to run the entrypoint of the container process.
             * Defaults to the user specified in image metadata if unspecified.
             * May also be set in PodSecurityContext. If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsUserName?: string
        }

        /**
         * LocalObjectReference contains enough information to let you locate the
         * referenced object inside the same namespace.
         */
        export interface RecorderSpecStatefulSetPodImagePullSecrets {
            /**
             * Name of the referent.
             * This field is effectively required, but due to backwards compatibility is
             * allowed to be empty. Instances of this type with an empty value here are
             * almost certainly wrong.
             * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
             */
            name?: string
        }
        /**
         * recorderSpecStatefulSetPodImagePullSecretsProvideDefaults sets the appropriate defaults for RecorderSpecStatefulSetPodImagePullSecrets
         */
        export function recorderSpecStatefulSetPodImagePullSecretsProvideDefaults(
            val: RecorderSpecStatefulSetPodImagePullSecrets,
        ): RecorderSpecStatefulSetPodImagePullSecrets {
            return {
                ...val,
                name: val.name ?? '',
            }
        }

        /**
         * Security context for Recorder Pods. By default, the operator does not
         * apply any Pod security context.
         * https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#security-context-2
         */
        export interface RecorderSpecStatefulSetPodSecurityContext {
            /**
             * appArmorProfile is the AppArmor options to use by the containers in this pod.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            appArmorProfile?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodSecurityContextAppArmorProfile
            /**
             * A special supplemental group that applies to all containers in a pod.
             * Some volume types allow the Kubelet to change the ownership of that volume
             * to be owned by the pod:
             *
             * 1. The owning GID will be the FSGroup
             * 2. The setgid bit is set (new files created in the volume will be owned by FSGroup)
             * 3. The permission bits are OR'd with rw-rw----
             *
             * If unset, the Kubelet will not modify the ownership and permissions of any volume.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            fsGroup?: number
            /**
             * fsGroupChangePolicy defines behavior of changing ownership and permission of the volume
             * before being exposed inside Pod. This field will only apply to
             * volume types which support fsGroup based ownership(and permissions).
             * It will have no effect on ephemeral volume types such as: secret, configmaps
             * and emptydir.
             * Valid values are "OnRootMismatch" and "Always". If not specified, "Always" is used.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            fsGroupChangePolicy?: string
            /**
             * The GID to run the entrypoint of the container process.
             * Uses runtime default if unset.
             * May also be set in SecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence
             * for that container.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsGroup?: number
            /**
             * Indicates that the container must run as a non-root user.
             * If true, the Kubelet will validate the image at runtime to ensure that it
             * does not run as UID 0 (root) and fail to start the container if it does.
             * If unset or false, no such validation will be performed.
             * May also be set in SecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsNonRoot?: boolean
            /**
             * The UID to run the entrypoint of the container process.
             * Defaults to user specified in image metadata if unspecified.
             * May also be set in SecurityContext.  If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence
             * for that container.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            runAsUser?: number
            /**
             * The SELinux context to be applied to all containers.
             * If unspecified, the container runtime will allocate a random SELinux context for each
             * container.  May also be set in SecurityContext.  If set in
             * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
             * takes precedence for that container.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            seLinuxOptions?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodSecurityContextSeLinuxOptions
            /**
             * The seccomp options to use by the containers in this pod.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            seccompProfile?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodSecurityContextSeccompProfile
            /**
             * A list of groups applied to the first process run in each container, in addition
             * to the container's primary GID, the fsGroup (if specified), and group memberships
             * defined in the container image for the uid of the container process. If unspecified,
             * no additional groups are added to any container. Note that group memberships
             * defined in the container image for the uid of the container process are still effective,
             * even if they are not included in this list.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            supplementalGroups?: number[]
            /**
             * Sysctls hold a list of namespaced sysctls used for the pod. Pods with unsupported
             * sysctls (by the container runtime) might fail to launch.
             * Note that this field cannot be set when spec.os.name is windows.
             */
            sysctls?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodSecurityContextSysctls[]
            /**
             * The Windows specific settings applied to all containers.
             * If unspecified, the options within a container's SecurityContext will be used.
             * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
             * Note that this field cannot be set when spec.os.name is linux.
             */
            windowsOptions?: outputs.tailscale.v1alpha1.RecorderSpecStatefulSetPodSecurityContextWindowsOptions
        }

        /**
         * appArmorProfile is the AppArmor options to use by the containers in this pod.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface RecorderSpecStatefulSetPodSecurityContextAppArmorProfile {
            /**
             * localhostProfile indicates a profile loaded on the node that should be used.
             * The profile must be preconfigured on the node to work.
             * Must match the loaded name of the profile.
             * Must be set if and only if type is "Localhost".
             */
            localhostProfile?: string
            /**
             * type indicates which kind of AppArmor profile will be applied.
             * Valid options are:
             *   Localhost - a profile pre-loaded on the node.
             *   RuntimeDefault - the container runtime's default profile.
             *   Unconfined - no AppArmor enforcement.
             */
            type: string
        }

        /**
         * The SELinux context to be applied to all containers.
         * If unspecified, the container runtime will allocate a random SELinux context for each
         * container.  May also be set in SecurityContext.  If set in
         * both SecurityContext and PodSecurityContext, the value specified in SecurityContext
         * takes precedence for that container.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface RecorderSpecStatefulSetPodSecurityContextSeLinuxOptions {
            /**
             * Level is SELinux level label that applies to the container.
             */
            level?: string
            /**
             * Role is a SELinux role label that applies to the container.
             */
            role?: string
            /**
             * Type is a SELinux type label that applies to the container.
             */
            type?: string
            /**
             * User is a SELinux user label that applies to the container.
             */
            user?: string
        }

        /**
         * The seccomp options to use by the containers in this pod.
         * Note that this field cannot be set when spec.os.name is windows.
         */
        export interface RecorderSpecStatefulSetPodSecurityContextSeccompProfile {
            /**
             * localhostProfile indicates a profile defined in a file on the node should be used.
             * The profile must be preconfigured on the node to work.
             * Must be a descending path, relative to the kubelet's configured seccomp profile location.
             * Must be set if type is "Localhost". Must NOT be set for any other type.
             */
            localhostProfile?: string
            /**
             * type indicates which kind of seccomp profile will be applied.
             * Valid options are:
             *
             * Localhost - a profile defined in a file on the node should be used.
             * RuntimeDefault - the container runtime default profile should be used.
             * Unconfined - no profile should be applied.
             */
            type: string
        }

        /**
         * Sysctl defines a kernel parameter to be set
         */
        export interface RecorderSpecStatefulSetPodSecurityContextSysctls {
            /**
             * Name of a property to set
             */
            name: string
            /**
             * Value of a property to set
             */
            value: string
        }

        /**
         * The Windows specific settings applied to all containers.
         * If unspecified, the options within a container's SecurityContext will be used.
         * If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
         * Note that this field cannot be set when spec.os.name is linux.
         */
        export interface RecorderSpecStatefulSetPodSecurityContextWindowsOptions {
            /**
             * GMSACredentialSpec is where the GMSA admission webhook
             * (https://github.com/kubernetes-sigs/windows-gmsa) inlines the contents of the
             * GMSA credential spec named by the GMSACredentialSpecName field.
             */
            gmsaCredentialSpec?: string
            /**
             * GMSACredentialSpecName is the name of the GMSA credential spec to use.
             */
            gmsaCredentialSpecName?: string
            /**
             * HostProcess determines if a container should be run as a 'Host Process' container.
             * All of a Pod's containers must have the same effective HostProcess value
             * (it is not allowed to have a mix of HostProcess containers and non-HostProcess containers).
             * In addition, if HostProcess is true then HostNetwork must also be set to true.
             */
            hostProcess?: boolean
            /**
             * The UserName in Windows to run the entrypoint of the container process.
             * Defaults to the user specified in image metadata if unspecified.
             * May also be set in PodSecurityContext. If set in both SecurityContext and
             * PodSecurityContext, the value specified in SecurityContext takes precedence.
             */
            runAsUserName?: string
        }

        /**
         * The pod this Toleration is attached to tolerates any taint that matches
         * the triple <key,value,effect> using the matching operator <operator>.
         */
        export interface RecorderSpecStatefulSetPodTolerations {
            /**
             * Effect indicates the taint effect to match. Empty means match all taint effects.
             * When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
             */
            effect?: string
            /**
             * Key is the taint key that the toleration applies to. Empty means match all taint keys.
             * If the key is empty, operator must be Exists; this combination means to match all values and all keys.
             */
            key?: string
            /**
             * Operator represents a key's relationship to the value.
             * Valid operators are Exists and Equal. Defaults to Equal.
             * Exists is equivalent to wildcard for value, so that a pod can
             * tolerate all taints of a particular category.
             */
            operator?: string
            /**
             * TolerationSeconds represents the period of time the toleration (which must be
             * of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
             * it is not set, which means tolerate the taint forever (do not evict). Zero and
             * negative values will be treated as 0 (evict immediately) by the system.
             */
            tolerationSeconds?: number
            /**
             * Value is the taint value the toleration matches to.
             * If the operator is Exists, the value should be empty, otherwise just a regular string.
             */
            value?: string
        }

        /**
         * Configure where to store session recordings. By default, recordings will
         * be stored in a local ephemeral volume, and will not be persisted past the
         * lifetime of a specific pod.
         */
        export interface RecorderSpecStorage {
            /**
             * Configure an S3-compatible API for storage. Required if the UI is not
             * enabled, to ensure that recordings are accessible.
             */
            s3?: outputs.tailscale.v1alpha1.RecorderSpecStorageS3
        }

        /**
         * Configure an S3-compatible API for storage. Required if the UI is not
         * enabled, to ensure that recordings are accessible.
         */
        export interface RecorderSpecStorageS3 {
            /**
             * Bucket name to write to. The bucket is expected to be used solely for
             * recordings, as there is no stable prefix for written object names.
             */
            bucket?: string
            /**
             * Configure environment variable credentials for managing objects in the
             * configured bucket. If not set, tsrecorder will try to acquire credentials
             * first from the file system and then the STS API.
             */
            credentials?: outputs.tailscale.v1alpha1.RecorderSpecStorageS3Credentials
            /**
             * S3-compatible endpoint, e.g. s3.us-east-1.amazonaws.com.
             */
            endpoint?: string
        }

        /**
         * Configure environment variable credentials for managing objects in the
         * configured bucket. If not set, tsrecorder will try to acquire credentials
         * first from the file system and then the STS API.
         */
        export interface RecorderSpecStorageS3Credentials {
            /**
             * Use a Kubernetes Secret from the operator's namespace as the source of
             * credentials.
             */
            secret?: outputs.tailscale.v1alpha1.RecorderSpecStorageS3CredentialsSecret
        }

        /**
         * Use a Kubernetes Secret from the operator's namespace as the source of
         * credentials.
         */
        export interface RecorderSpecStorageS3CredentialsSecret {
            /**
             * The name of a Kubernetes Secret in the operator's namespace that contains
             * credentials for writing to the configured bucket. Each key-value pair
             * from the secret's data will be mounted as an environment variable. It
             * should include keys for AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY if
             * using a static access key.
             */
            name?: string
        }

        /**
         * RecorderStatus describes the status of the recorder. This is set
         * and managed by the Tailscale operator.
         */
        export interface RecorderStatus {
            /**
             * List of status conditions to indicate the status of the Recorder.
             * Known condition types are `RecorderReady`.
             */
            conditions?: outputs.tailscale.v1alpha1.RecorderStatusConditions[]
            /**
             * List of tailnet devices associated with the Recorder StatefulSet.
             */
            devices?: outputs.tailscale.v1alpha1.RecorderStatusDevices[]
        }

        /**
         * Condition contains details for one aspect of the current state of this API Resource.
         */
        export interface RecorderStatusConditions {
            /**
             * lastTransitionTime is the last time the condition transitioned from one status to another.
             * This should be when the underlying condition changed.  If that is not known, then using the time when the API field changed is acceptable.
             */
            lastTransitionTime: string
            /**
             * message is a human readable message indicating details about the transition.
             * This may be an empty string.
             */
            message: string
            /**
             * observedGeneration represents the .metadata.generation that the condition was set based upon.
             * For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date
             * with respect to the current state of the instance.
             */
            observedGeneration?: number
            /**
             * reason contains a programmatic identifier indicating the reason for the condition's last transition.
             * Producers of specific condition types may define expected values and meanings for this field,
             * and whether the values are considered a guaranteed API.
             * The value should be a CamelCase string.
             * This field may not be empty.
             */
            reason: string
            /**
             * status of the condition, one of True, False, Unknown.
             */
            status: string
            /**
             * type of condition in CamelCase or in foo.example.com/CamelCase.
             */
            type: string
        }

        export interface RecorderStatusDevices {
            /**
             * Hostname is the fully qualified domain name of the device.
             * If MagicDNS is enabled in your tailnet, it is the MagicDNS name of the
             * node.
             */
            hostname: string
            /**
             * TailnetIPs is the set of tailnet IP addresses (both IPv4 and IPv6)
             * assigned to the device.
             */
            tailnetIPs?: string[]
            /**
             * URL where the UI is available if enabled for replaying recordings. This
             * will be an HTTPS MagicDNS URL. You must be connected to the same tailnet
             * as the recorder to access it.
             */
            url?: string
        }
    }
}
